<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>微积分第二章：极限与连续 - 优化版</title>
    <script src="../common-assets/js/d3-7.8.5.min.js"></script>
    <script src="../common-assets/js/mathjax-config.js"></script>
        <script type="text/javascript" id="MathJax-script" async
                src="../common-assets/js/mathjax-3.2.2-tex-svg.min.js">
        </script>
    <style>
         @import url('../common-assets/css/fonts.css');

         :root {
             --chalkboard-bg: transparent;
             --chalk-text: #ecf0f1;
             --visualization-bg: #fdfdfd00;
             --primary-color: #3498db;
             --accent-color: #e67e22;
             --success-color: #2ecc71;
             --danger-color: #e74c3c;
             --warning-color: #f39c12;
             --info-color: #9b59b6;
             --text-color: #34495e;
             --heading-font: 'Noto Serif SC', serif;
             --handwriting-font: 'Noto Serif SC', serif;
         }

         body {
             font-family: var(--heading-font);

             background-size: cover;
             background-position: center;
             background-repeat: no-repeat;
             overflow: auto;
             height: 100vh;
             width: 100vw;
             display: flex;
             justify-content: center;
             align-items: center;
             margin: 0;
         }

         #presentation-container {
             width: 100vw;
             height: 100vh;
             max-width: 100vw;
             aspect-ratio: 16 / 9;
             position: relative;
             background: rgba(255, 255, 255, 0);
             box-shadow: 0 15px 40px rgba(0, 0, 0, 0.2);
             border-radius: 8px;
             overflow: auto;
         }

         .slide {
             position: absolute;
             width: 100%;
             height: 100%;
             opacity: 0;
             visibility: hidden;
             display: flex;
             transition: opacity 0.6s ease-in-out;
             
         }

         .slide.active {
             opacity: 1;
             visibility: visible;
             z-index: 10;
         }

         .chalkboard {
             flex: 0 0 35%;
             background-color: #2c3e50 !important;
             border: 10px solid #8B4513; /* 木质边框 */
             box-shadow: 0 10px 20px rgba(0,0,0,0.5), inset 0 0 15px rgba(0,0,0,0.7);
             color: var(--chalk-text, #f0f0f0);
             padding: 15px;
             display: flex;
             flex-direction: column;
             justify-content: flex-start;
             overflow-y: auto;
             overflow-x: hidden;
             box-sizing: border-box;
             max-height: 100vh;
             word-wrap: break-word;
             word-break: break-word;
         }
         
         /* 自定义滚动条样式 */
         .chalkboard::-webkit-scrollbar {
             width: 8px;
         }
         
         .chalkboard::-webkit-scrollbar-track {
             background: rgba(0, 0, 0, 0.3);
             border-radius: 4px;
         }
         
         .chalkboard::-webkit-scrollbar-thumb {
             background: rgba(255, 255, 255, 0.3);
             border-radius: 4px;
         }
         
         .chalkboard::-webkit-scrollbar-thumb:hover {
             background: rgba(255, 255, 255, 0.5);
         }

         .chalkboard h2 {
             font-family: var(--handwriting-font);
             font-size: 2.2rem;
             color: #f1c40f;
             border-bottom: 2px solid rgba(241, 196, 15, 0.5);
             padding-bottom: 2px;
             margin-bottom:3px;
         }

         .chalkboard h3 {
             font-family: var(--handwriting-font);
             font-size: 1.5rem;
             color: var(--primary-color);
             margin-top: 5px;
             margin-bottom: 5px;
         }

         .chalkboard p, .chalkboard li {
             font-size: 1.1rem;
             line-height: 1.4;
             margin-bottom: 8px;
             word-wrap: break-word;
             overflow-wrap: break-word;
             max-width: 100%;
         }

         .chalkboard ul {
             list-style-type: '▸ ';
             padding-left: 20px;
             margin-bottom: 8px;
         }

         .math-formula {
             font-size: 1.2rem;
             color: #1abc9c;
             background: rgba(26, 188, 156, 0.1);
             padding: 12px;
             border-radius: 8px;
             text-align: center;
             margin: 15px 0;
             border: 2px solid rgba(26, 188, 156, 0.3);
             word-wrap: break-word;
             overflow-wrap: break-word;
             max-width: 100%;
         }

         .highlight {
             color: var(--warning-color);
             font-weight: bold;
             background: rgba(243, 156, 18, 0.1);
             padding: 2px 6px;
             border-radius: 4px;
         }

         .example-box {
             background: rgba(52, 152, 219, 0.1);
             border-left: 4px solid var(--primary-color);
             padding: 15px;
             margin: 20px 0;
         }

         .example-box h4 {
             color: var(--primary-color);
             margin-top: 0;
             font-size: 1rem;
         }

         .step-box {
             background: rgba(46, 204, 113, 0.1);
             border: 1px solid rgba(46, 204, 113, 0.3);
             padding: 10px;
             margin: 10px 0;
             border-radius: 5px;
         }

         .warning-box {
             background: rgba(231, 76, 60, 0.1);
             border: 2px solid rgba(231, 76, 60, 0.3);
             padding: 15px;
             margin: 20px 0;
             border-radius: 8px;
         }

         .visualization {
             flex: 1;
             padding: 30px;
             display: grid;
             grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
             gap: 20px;
             overflow-y: auto;
             background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
         }

         .vis-item {
             background: white;
             border-radius: 8px;
             padding: 15px;
             position: relative;
             cursor: pointer;
             transition: transform 0.2s, box-shadow 0.2s;
             box-shadow: 0 2px 8px rgba(0,0,0,0.1);
         }

         .vis-item:hover {
             transform: scale(1.02);
             box-shadow: 0 4px 12px rgba(0,0,0,0.15);
         }

         .vis-item svg {
             width: 100%;
             height: auto;
         }

         .vis-title {
             display: flex;
             flex-direction: row;
             align-items: center;
             justify-content: center;
             gap: 0.1em;
             font-size: 1rem;
             color: var(--text-color);
             margin-bottom: 10px;
             height: auto;
             line-height: 1.2;
         }

         .approach-indicator {
             position: absolute;
             top: 5px;
             right: 5px;
             background: rgba(52, 152, 219, 0.9);
             color: white;
             padding: 2px 6px;
             border-radius: 10px;
             font-size: 0.7rem;
             font-weight: bold;
         }

         .approach-left {
             background: rgba(231, 76, 60, 0.9);
         }

         .approach-right {
             background: rgba(46, 204, 113, 0.9);
         }

         .approach-both {
             background: rgba(155, 89, 182, 0.9);
         }

         .expanded-overlay {
             position: fixed;
             top: 0;
             left: 0;
             width: 100vw;
             height: 100vh;
             background: rgba(0,0,0,0.8);
             z-index: 1000;
             display: flex;
             justify-content: center;
             align-items: center;
             opacity: 0;
             visibility: hidden;
             transition: all 0.3s ease;
         }

         .expanded-overlay.active {
             opacity: 1;
             visibility: visible;
         }

         .expanded-content {
             background: white;
             border-radius: 12px;
             padding: 30px;
             width: 80vw;
             height: 80vh;
             position: relative;
             transform: scale(0.8);
             transition: transform 0.3s ease;
             display: flex;
             flex-direction: column;
         }

         .expanded-overlay.active .expanded-content {
             transform: scale(1);
         }

         .expanded-title {
             font-size: 1.5rem;
             margin-bottom: 20px;
             text-align: center;
             color: var(--text-color);
             line-height: 1.8;
             min-height: 3rem;
             display: flex;
             align-items: center;
             justify-content: center;
         }

         .expanded-title mjx-container {
             font-size: 1.2em !important;
         }

         .simple-annotation {
             font-family: var(--heading-font);
         }

         .simple-annotation mjx-container {
             font-size: 1.1em !important;
         }

         .expanded-annotation {
             text-align: center;
             margin-bottom: 15px;
             font-style: italic;
             color: #6c757d;
         }

         .expanded-svg-container {
             flex: 1;
             overflow: auto;
             position: relative;
         }

         .expanded-controls {
             display: flex;
             justify-content: space-between;
             align-items: center;
             padding: 15px 20px;
             background: #f8f9fa;
             border-radius: 10px;
             margin: 20px;
             flex-wrap: wrap;
             gap: 15px;
         }

         .control-group {
             display: flex;
             align-items: center;
             gap: 10px;
         }

         .control-group label {
             display: flex;
             align-items: center;
             gap: 8px;
             font-weight: 500;
             color: #495057;
         }

         .control-group input[type="range"] {
             width: 120px;
         }

         .control-group button {
             padding: 8px 16px;
             background: #007bff;
             color: white;
             border: none;
             border-radius: 5px;
             cursor: pointer;
             font-size: 14px;
             transition: background 0.3s;
         }

         .control-group button:hover {
             background: #0056b3;
         }

         .annotation-text {
             background: rgba(52, 152, 219, 0.1);
             color: #2980b9;
             padding: 5px 12px;
             border-radius: 15px;
             font-size: 14px;
             display: inline-block;
         }

         .close-btn {
             position: absolute;
             top: 10px;
             right: 10px;
             background: var(--danger-color);
             color: white;
             border: none;
             border-radius: 50%;
             width: 30px;
             height: 30px;
             cursor: pointer;
             font-size: 18px;
         }

         .close-btn:hover {
             background: #c0392b;
         }



         .navigation {
             position: absolute;
             top: 10px;
             right: 20px;
             display: flex;
             gap: 5px;
             z-index: 100;
         }
         
         .slide-nav-btn {
             background: rgba(0, 0, 0, 0.6);
             border: 1px solid rgba(255, 255, 255, 0.3);
             color: white;
             padding: 4px 8px;
             border-radius: 15px;
             font-size: 10px;
             cursor: pointer;
             transition: all 0.3s ease;
             backdrop-filter: blur(10px);
             user-select: none;
             min-width: 30px;
             text-align: center;
         }

         .slide-nav-btn:hover {
             background: rgba(0, 0, 0, 0.8);
             border-color: rgba(255, 255, 255, 0.6);
             transform: translateY(-1px);
         }

         .slide-nav-btn:active {
             transform: translateY(0);
             background: rgba(0, 0, 0, 0.9);
         }

         .slide-nav-btn:disabled {
             opacity: 0.4;
             cursor: not-allowed;
             transform: none;
         }

         .slide-nav-btn:disabled:hover {
             background: rgba(0, 0, 0, 0.6);
             border-color: rgba(255, 255, 255, 0.3);
             transform: none;
         }

         .page-info {
             display: flex;
             align-items: center;
             justify-content: center;
             font-size: 14px;
             font-weight: 600;
             color: #2c3e50;
             background: rgba(236, 240, 241, 0.9);
             padding: 8px 12px;
             border-radius: 15px;
             min-width: 60px;
             margin: 0 5px;
         }

         .interactive-panel {
             position: absolute;
             bottom: 30px;
             right: 70px;
             background: rgba(255, 255, 255, 0.95);
             padding: 20px;
             border-radius: 10px;
             box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
         }

         .draggable-panel {
             cursor: move;
             user-select: none;
         }

         .draggable-panel h3 {
             cursor: grab;
             margin: 0 0 15px 0;
             padding: 5px 0;
             border-bottom: 2px solid var(--primary-color);
             color: var(--primary-color);
             font-weight: bold;
         }

         .draggable-panel h3:hover {
             background: rgba(52, 152, 219, 0.1);
             border-radius: 5px;
             padding: 5px;
         }

         .draggable-panel.dragging {
             cursor: grabbing;
             box-shadow: 0 8px 30px rgba(0, 0, 0, 0.2);
             transform: scale(1.02);
             transition: transform 0.1s ease;
         }

         .draggable-panel.dragging h3 {
             cursor: grabbing;
         }

         .button-container {
             display: flex;
             flex-wrap: wrap;
             gap: 10px;
             margin: 15px 0;
             align-items: center;
         }

         .slider-container {
             display: flex;
             align-items: center;
             gap: 15px;
             margin: 10px 0;
         }

         .slider {
             flex: 1;
             -webkit-appearance: none;
             appearance: none;
             height: 8px;
             border-radius: 5px;
             background: linear-gradient(to right, var(--primary-color) 0%, var(--accent-color) 100%);
             outline: none;
         }

         .slider::-webkit-slider-thumb {
             -webkit-appearance: none;
             appearance: none;
             width: 20px;
             height: 20px;
             border-radius: 50%;
             background: white;
             border: 3px solid var(--primary-color);
             cursor: pointer;
         }


         .formula-step {
             display: flex;
             align-items: center;
             justify-content: center;
             gap: 20px;
             margin: 15px 0;
             font-size: 1.3rem;
         }

         .formula-arrow {
             color: var(--accent-color);
             font-size: 1.5rem;
         }

         @keyframes pulse {
             0%, 100% { 
                 opacity: 0.8; 
                 transform: scale(1); 
             }
             50% { 
                 opacity: 1; 
                 transform: scale(1.05); 
             }
         }

         @keyframes fadeIn {
             from { opacity: 0; transform: translateY(20px); }
             to { opacity: 1; transform: translateY(0); }
         }
         
         .animated-point, .fade-in, .pulse {
             will-change: transform, opacity;
             transform: translateZ(0);
             backface-visibility: hidden;
         }

         .animated-point {
             animation: pulse 2s ease-in-out infinite;
         }

         .fade-in {
             animation: fadeIn 0.8s ease-out;
         }

         .limit-arrow {
             stroke: var(--danger-color);
             stroke-width: 2;
             marker-end: url(#arrowhead);
             stroke-dasharray: 5, 5;
             animation: dash 2s linear infinite;
         }

         @keyframes dash {
             to { stroke-dashoffset: -10; }
         }

         .epsilon-band {
             fill: rgba(52, 152, 219, 0.2);
             stroke: rgba(52, 152, 219, 0.5);
             stroke-width: 1;
             stroke-dasharray: 3, 3;
         }

         .thinking-bubble {
             background: rgba(255, 255, 255, 0.95);
             border-radius: 20px;
             padding: 15px;
             position: relative;
             box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
         }

                 /* 极限动画增强样式 */
                 .limit-approach-container .approach-indicator {
             animation: pulse 2s infinite ease-in-out;
         }

         @keyframes pulse {
             0%, 100% { 
                 opacity: 0.8; 
                 transform: scale(1); 
             }
             50% { 
                 opacity: 1; 
                 transform: scale(1.05); 
             }
         }

         .left-approach-point, .right-approach-point {
             filter: drop-shadow(0 0 4px currentColor);
         }
         
         .chart-annotation {
             margin-top: 15px;
             padding: 12px 20px;
             background: rgba(52, 73, 94, 0.08);
             border-radius: 8px;
             font-size: 14px;
             line-height: 1.5;
             color: var(--text-color);
             border: none;
             font-family: 'Noto Serif SC', serif;
             max-width: 800px;
             margin-left: auto;
             margin-right: auto;
         }
         
         .chart-annotation .conclusion {
             font-weight: 600;
             color: var(--primary-color);
         }
         
         .chart-annotation .analysis {
             margin-top: 4px;
             opacity: 0.8;
         }

     /* 封面样式 */
     .cover-full {
         display: flex;
         flex-direction: column;
         width: 100%;
         height: 100%;
         background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
         justify-content: center;
         align-items: center;
         padding: 60px;
         box-sizing: border-box;
     }

     .cover-content {
         max-width: 1000px;
         text-align: center;
         background: rgba(255, 255, 255, 0.95);
         padding: 60px;
         border-radius: 20px;
         box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
     }

     .cover-header {
         margin-bottom: 50px;
     }

     .cover-title-main {
         font-size: 3.5rem;
         color: var(--primary-color);
         font-weight: bold;
         margin: 0 0 15px 0;
         text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
     }

     .cover-title-subtitle {
         font-size: 2.2rem;
         color: var(--accent-color);
         margin: 0;
         font-weight: 600;
     }

     .cover-version {
         font-size: 1.4rem;
         color: var(--success-color);
         margin-top: 20px;
         font-weight: 500;
     }

     .cover-center {
         margin: 50px 0;
     }

     .cover-icon {
         font-size: 5rem;
         margin-bottom: 40px;
         text-shadow: 2px 2px 8px rgba(0,0,0,0.2);
         animation: pulse 3s ease-in-out infinite;
     }

     .cover-objectives {
         margin-bottom: 40px;
     }

     .objectives-list {
         display: grid;
         grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
         gap: 20px;
         margin-top: 20px;
     }

     .objective-item {
         display: flex;
         align-items: center;
         gap: 15px;
         padding: 15px;
         background: rgba(52, 152, 219, 0.1);
         border-radius: 10px;
         border-left: 4px solid var(--primary-color);
         transition: transform 0.2s ease, box-shadow 0.2s ease;
     }

     .objective-item:hover {
         transform: translateY(-2px);
         box-shadow: 0 8px 15px rgba(0,0,0,0.15);
     }

     .objective-icon {
         font-size: 1.5rem;
         flex-shrink: 0;
     }

     .knowledge-flow {
         display: flex;
         align-items: center;
         gap: 20px;
         margin-top: 40px;
         padding: 25px;
         background: rgba(155, 89, 182, 0.1);
         border-radius: 15px;
         border: 2px solid rgba(155, 89, 182, 0.3);
     }

     .flow-item {
         padding: 12px 25px;
         background: linear-gradient(135deg, var(--primary-color), var(--accent-color));
         color: white;
         border-radius: 25px;
         font-weight: 600;
         font-size: 0.95rem;
         text-align: center;
         min-width: 140px;
         box-shadow: 0 4px 15px rgba(0,0,0,0.2);
         transition: transform 0.3s ease;
     }

     .current {
         background: linear-gradient(135deg, var(--success-color), #27ae60) !important;
         transform: scale(1.05);
     }

     .flow-arrow {
         font-size: 1.5rem;
         color: var(--accent-color);
         font-weight: bold;
     }

     .cover-footer {
         margin-top: 60px;
         border-top: 2px solid rgba(0,0,0,0.1);
         padding-top: 30px;
     }

     .nav-guide {
         display: flex;
         justify-content: center;
         gap: 20px;
         margin-bottom: 30px;
     }

     .nav-item {
         display: flex;
         flex-direction: column;
         align-items: center;
         gap: 8px;
         padding: 15px 20px;
         background: rgba(52, 152, 219, 0.1);
         border-radius: 10px;
         transition: background 0.3s ease;
     }

     .nav-item:hover {
         background: rgba(52, 152, 219, 0.2);
     }

     .nav-icon {
         font-size: 1.5rem;
     }

     .tech-info {
         color: var(--info-color);
         font-size: 0.9rem;
         font-weight: 500;
         padding: 10px 20px;
         background: rgba(26, 188, 156, 0.1);
         border-radius: 20px;
         display: inline-block;
     }

     /* 首页导航按钮样式 */
     .home-nav-buttons {
         display: flex;
         justify-content: center;
         gap: 20px;
         margin-top: 40px;
         flex-wrap: wrap;
     }

     .nav-btn {
         display: flex;
         flex-direction: column;
         align-items: center;
         padding: 15px 20px;
         background: rgba(255, 255, 255, 0.1);
         border: 2px solid rgba(255, 255, 255, 0.3);
         border-radius: 15px;
         text-decoration: none;
         color: white;
         transition: all 0.3s ease;
         backdrop-filter: blur(10px);
         min-width: 120px;
         box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
     }

     .nav-btn:hover {
         background: rgba(255, 255, 255, 0.2);
         border-color: rgba(255, 255, 255, 0.5);
         transform: translateY(-5px);
         box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
     }

     .nav-btn .btn-icon {
         font-size: 1.2rem;
         margin-bottom: 8px;
         font-weight: bold;
         letter-spacing: 1px;
     }

     .nav-btn .btn-text {
         font-size: 1.1rem;
         font-weight: 500;
     }

     /* 不同按钮的特殊颜色 */
     .home-btn:hover {
         background: rgba(52, 152, 219, 0.3);
         border-color: rgba(52, 152, 219, 0.6);
     }

     .story-btn:hover {
         background: rgba(155, 89, 182, 0.3);
         border-color: rgba(155, 89, 182, 0.6);
     }

     .exercise-btn:hover {
         background: rgba(46, 204, 113, 0.3);
         border-color: rgba(46, 204, 113, 0.6);
     }

     .resource-btn:hover {
         background: rgba(230, 126, 34, 0.3);
         border-color: rgba(230, 126, 34, 0.6);
     }

     /* 响应式设计 */
     @media (max-width: 768px) {
         .home-nav-buttons {
             gap: 15px;
             margin-top: 30px;
         }
         
         .nav-btn {
             padding: 12px 16px;
             min-width: 100px;
         }
         
         .nav-btn .btn-icon {
             font-size: 1rem;
         }
         
         .nav-btn .btn-text {
             font-size: 1rem;
         }
         
         .slide-nav-btn {
             padding: 6px 10px;
             font-size: 12px;
         }
     }

     /* 浮动菜单样式 */
     #floating-menu {
         position: fixed;
         bottom: 20px;
         right: 200px;
         z-index: 9999;
         font-family: var(--heading-font);
     }

     /* 章节目录菜单样式 */
     #chapter-menu {
         position: fixed;
         bottom: 20px;
         right: 20px;
         z-index: 9999;
         font-family: var(--heading-font);
     }

     .menu-toggle {
         background: rgba(0, 0, 0, 0.3);
         border: 1px solid rgba(255, 255, 255, 0.2);
         color: rgba(255, 255, 255, 0.8);
         padding: 6px 12px;
         border-radius: 4px;
         cursor: pointer;
         font-size: 12px;
         font-weight: normal;
         transition: all 0.2s ease;
         backdrop-filter: blur(5px);
         min-width: 50px;
         text-align: center;
         display: flex;
         align-items: center;
         justify-content: center;
     }

     .menu-toggle:hover {
         background: rgba(0, 0, 0, 0.5);
         color: rgba(255, 255, 255, 1);
         border-color: rgba(255, 255, 255, 0.4);
     }

     .menu-toggle:active {
         transform: scale(0.95);
     }

     .menu-toggle .menu-icon {
         font-size: 10px;
         font-weight: normal;
         transition: transform 0.3s ease;
     }

     .menu-toggle.active .menu-icon {
         transform: rotate(45deg);
     }

     .menu-content {
         position: absolute;
         bottom: 50px;
         right: 0;
         background: rgba(255, 255, 255, 0.95);
         border-radius: 15px;
         padding: 10px 0;
         box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
         backdrop-filter: blur(10px);
         border: 1px solid rgba(255, 255, 255, 0.3);
         opacity: 0;
         visibility: hidden;
         transform: translateY(20px);
         transition: all 0.3s ease;
         min-width: 220px;
         max-height: 400px;
         overflow-y: auto;
     }

     .menu-content.active {
         opacity: 1;
         visibility: visible;
         transform: translateY(0);
     }

     /* 自定义滚动条样式 */
     .menu-content::-webkit-scrollbar {
         width: 6px;
     }

     .menu-content::-webkit-scrollbar-track {
         background: rgba(0, 0, 0, 0.1);
         border-radius: 3px;
     }

     .menu-content::-webkit-scrollbar-thumb {
         background: rgba(102, 126, 234, 0.5);
         border-radius: 3px;
     }

     .menu-content::-webkit-scrollbar-thumb:hover {
         background: rgba(102, 126, 234, 0.7);
     }

     .menu-item {
         display: flex;
         align-items: center;
         padding: 10px 15px;
         text-decoration: none;
         color: #333;
         transition: all 0.3s ease;
         border-radius: 10px;
         margin: 0 8px;
     }

     .menu-item:hover {
         background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
         color: white;
         transform: translateX(5px);
     }

     .menu-item .menu-icon {
         font-size: 12px;
         margin-right: 10px;
         width: 40px;
         text-align: center;
         font-weight: bold;
         letter-spacing: 0.5px;
     }

     .menu-item .menu-text {
         font-size: 14px;
         font-weight: 500;
     }

     /* 响应式设计 */
     @media (max-width: 768px) {
         #floating-menu {
             bottom: 15px;
             right: 150px;
         }
         
         .menu-content {
             min-width: 200px;
         }
         
         .menu-item {
             padding: 8px 12px;
         }
         
         .menu-item .menu-text {
             font-size: 13px;
         }
     }

    </style>

    <style>
        .return-home-panel {
            position: fixed;
            top: 16px;
            left: 16px;
            display: flex;
            gap: 10px;
            z-index: 9999;
            flex-wrap: wrap;
        }
        .return-home-panel .return-link {
            padding: 8px 14px;
            border-radius: 999px;
            background: rgba(15, 23, 42, 0.8);
            color: #f8fafc;
            font-size: 14px;
            text-decoration: none;
            box-shadow: 0 6px 20px rgba(15, 23, 42, 0.25);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .return-home-panel .return-link:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 24px rgba(15, 23, 42, 0.35);
        }
        .return-home-panel .return-link.return-main {
            background: rgba(79, 70, 229, 0.85);
        }
        @media (max-width: 640px) {
            .return-home-panel {
                top: 12px;
                left: 12px;
                right: 12px;
                justify-content: center;
            }
            .return-home-panel .return-link {
                width: 100%;
                text-align: center;
            }
        }
    </style>
</head>
<body>
    <div class="return-home-panel">
        <a class="return-link return-sub" href="index.html">← 返回目录</a>
        <a class="return-link return-main" href="../index.html">⌂ 返回主站</a>
    </div>

<div id="presentation-container">

    <div class="slide active">
        <div class="chalkboard" style="flex: 1; text-align: center; ">
            <h2 style="font-size: 4rem; border: none;">第二章</h2>
            <p style="font-size: 2.5rem; color: white;">极限与连续</p>
            
            <div class="home-nav-buttons">
                <a href="../index.html" class="nav-btn home-btn">
                    <span class="btn-icon">HOME</span>
                    <span class="btn-text">主页</span>
                </a>
                <a href="../故事书/index.html" class="nav-btn story-btn">
                    <span class="btn-icon">STORY</span>
                    <span class="btn-text">故事书</span>
                </a>
                <a href="../习题/index.html" class="nav-btn exercise-btn">
                    <span class="btn-icon">EXERCISE</span>
                    <span class="btn-text">习题</span>
                </a>
                <a href="../网页资源/index.html" class="nav-btn resource-btn">
                    <span class="btn-icon">RESOURCE</span>
                    <span class="btn-text">网页资源</span>
                </a>
            </div>
        </div>
    </div>

    <div class="slide">
        <div class="chalkboard" style="flex: 1; text-align: center;   overflow-y: auto; align-items: flex-start; justify-content: flex-start;">
            <div style="writing-mode: vertical-rl; text-orientation: mixed; font-size: 3rem; border: none; margin-bottom: 1.5rem; height: 8rem; display: flex; align-items: flex-start; justify-content: center;">
                目录
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 1.5rem; margin: 0 auto; max-width: 1400px; text-align: left;">
                <div style="background: rgba(255,255,255,0.1); padding: 0.8rem; border-radius: 10px; backdrop-filter: blur(10px);">
                    <h3 style="color: #e74c3c; font-size: 1.3rem; margin-bottom: 0.5rem; border-bottom: 2px solid #e74c3c; padding-bottom: 0.2rem;">1. 极限概念入门</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; font-size: 1rem; line-height: 1.3;">
                        <div>• 为什么要学极限</div>
                        <div>• 极限的直观理解</div>
                        <div>• 函数极限</div>
                        <div>• 左右极限</div>
                        <div>• 极限存在条件</div>
                    </div>
                </div>
                
                <div style="background: rgba(255,255,255,0.1); padding: 0.8rem; border-radius: 10px; backdrop-filter: blur(10px);">
                    <h3 style="color: #e74c3c; font-size: 1.3rem; margin-bottom: 0.5rem; border-bottom: 2px solid #e74c3c; padding-bottom: 0.2rem;">2. 极限计算方法</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; font-size: 1rem; line-height: 1.3;">
                        <div>• 直接代入法</div>
                        <div>• 极限运算法则</div>
                        <div>• 不定式处理</div>
                        <div>• 因式分解</div>
                        <div>• 有理化</div>
                        <div>• 同除最高次幂</div>
                    </div>
                </div>
                
                <div style="background: rgba(255,255,255,0.1); padding: 0.8rem; border-radius: 10px; backdrop-filter: blur(10px);">
                    <h3 style="color: #e74c3c; font-size: 1.3rem; margin-bottom: 0.5rem; border-bottom: 2px solid #e74c3c; padding-bottom: 0.2rem;">3. 计算进阶与技巧</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; font-size: 1rem; line-height: 1.3;">
                        <div>• 两个重要极限</div>
                        <div>• 无穷小与无穷大</div>
                        <div>• 无穷小的比较</div>
                        <div>• 等价无穷小替换</div>
                    </div>
                </div>
                
                <div style="background: rgba(255,255,255,0.1); padding: 0.8rem; border-radius: 10px; backdrop-filter: blur(10px);">
                    <h3 style="color: #e74c3c; font-size: 1.3rem; margin-bottom: 0.5rem; border-bottom: 2px solid #e74c3c; padding-bottom: 0.2rem;">4. 函数的连续性</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; font-size: 1rem; line-height: 1.3;">
                        <div>• 连续的定义</div>
                        <div>• 间断点分类</div>
                        <div>• 初等函数的连续性</div>
                        <div>• 连续函数的性质</div>
                    </div>
                </div>

                <div style="background: rgba(255,255,255,0.1); padding: 0.8rem; border-radius: 10px; backdrop-filter: blur(10px);">
                    <h3 style="color: #e74c3c; font-size: 1.3rem; margin-bottom: 0.5rem; border-bottom: 2px solid #e74c3c; padding-bottom: 0.2rem;">5. 总结与应用</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; font-size: 1rem; line-height: 1.3;">
                        <div>• 实际应用</div>
                        <div>• 知识点总结</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="slide">
        <div class="chalkboard">
            <h2>为什么要学极限？</h2>

            <h3>古代难题</h3>
            <p>古希腊哲学家芝诺提出：<span class="highlight">阿基里斯追龟悖论</span></p>
            <p>跑得快的阿基里斯永远追不上前面的乌龟？因为当他跑到乌龟原来的位置时，乌龟又向前爬了一段...</p>

            <h3>现实问题</h3>
            <ul>
                <li><strong>瞬时速度</strong>：汽车速度表显示的是瞬间速度，怎么算？</li>
                <li><strong>曲线切线</strong>：GPS导航的转弯提示需要计算道路切线</li>
                <li><strong>经济决策</strong>：当产量增加一个单位时，成本增加多少？</li>
                <li><strong>图像压缩</strong>：JPEG如何用有限数据逼近原始图像？</li>
            </ul>

            <div class="warning-box">
                <p><strong>核心矛盾：</strong>我们想知道"瞬间"的变化率，但"瞬间"意味着时间为0，而0不能做分母！</p>
                <p>极限就是解决这个矛盾的<span class="highlight">数学工具</span>。</p>
            </div>
        </div>
        <div class="visualization" id="vis-why-limit"></div>
    </div>

    <div class="slide">
        <div class="chalkboard">
            <h2>什么是极限？(直观理解)</h2>
            
            <h3>核心思想</h3>
            <p>极限描述的是一个<span class="highlight">无限靠近的过程</span>，和它最终<span class="highlight">趋向于</span>的那个目标值。</p>
            <p>关键词：<span class="highlight">“越来越接近，但不必到达”</span></p>
            
            <div class="example-box">
                <h4>生活例子1：往杯子里倒水</h4>
                <p>假设杯子容量是1升，你每次倒入剩余空间的一半：</p>
                <ul>
                    <li>第1次：倒入0.5升（杯中0.5升）</li>
                    <li>第2次：倒入0.25升（杯中0.75升）</li>
                    <li>第3次：倒入0.125升（杯中0.875升）</li>
                    <li>... ...</li>
                </ul>
                <p>理论上永远倒不满，但水量<span class="highlight">无限接近1升</span>！我们就说这个过程的<span class="highlight">极限是1</span>。</p>
            </div>
            
            <div class="example-box" style="background: rgba(155, 89, 182, 0.1);">
                <h4>生活例子2：和朋友约见面</h4>
                <p>"马上到" → "还有5分钟" → "还有1分钟" → "到楼下了"</p>
                <p>你和朋友的距离越来越小，<span class="highlight">无限趋向于0</span>，极限的目标就是“见面”。</p>
            </div>
            
        </div>
        <div class="visualization" id="vis-intuitive-limit"></div>
    </div>
    
    <div class="slide">
        <div class="chalkboard">
            <h2>函数极限与左右极限</h2>
            
            <h3>函数极限的定义</h3>
            <p>当变量 $x$ <span class="highlight">无限接近</span>某个值 $a$ 时，函数值 $f(x)$ <span class="highlight">无限接近</span>一个确定的数 $L$。</p>
            <div class="math-formula">
                $\lim\limits_{x \to a} f(x) = L$
            </div>
            
            <h3>左右极限：从两边靠近</h3>
            <p>为了判断极限是否存在，我们需要像侦探一样从两边侦查：</p>
            <ul>
                <li><span style="color:#e74c3c;">左极限</span>: 从比 $a$ 小的一侧靠近 ($x \to a^-$)</li>
                <li><span style="color:#3498db;">右极限</span>: 从比 $a$ 大的一侧靠近 ($x \to a^+$)</li>
            </ul>
            
            <div class="warning-box">
                <h4>极限存在的充要条件</h4>
                <p>极限存在的唯一标准：<span class="highlight">左右手必须相遇！</span></p>
                <p>$\lim\limits_{x \to a} f(x)$ 存在 $\Longleftrightarrow$ 左极限 = 右极限</p>
                <p>$\lim\limits_{x \to a^-} f(x) = \lim\limits_{x \to a^+} f(x) = L$</p>
            </div>
        </div>
        <div class="visualization" id="vis-one-sided-limits"></div>
    </div>
    
    <div class="slide">
        <div class="chalkboard">
            <h2>计算极限(1): 直接代入法</h2>
            
            <h3>最简单的方法</h3>
            <p>对于大部分我们学过的“正常”函数（即<span class="highlight">连续函数</span>），求极限就像求函数值一样简单。</p>
            
            <div class="step-box">
                <p><strong>方法:</strong> 直接把 $x \to a$ 中的 $a$ 代入函数表达式中计算。</p>
                <p><strong>前提:</strong> 代入后分母不为0，根号下不为负数等。</p>
            </div>
            
            <div class="example-box">
                <h4>例1：求 $\lim\limits_{x \to 2} (x^2 + 3x - 1)$</h4>
                <p>直接代入 $x=2$:</p>
                <p>$= (2)^2 + 3(2) - 1 = 4 + 6 - 1 = 9$</p>
            </div>
            
            <div class="example-box">
                <h4>例2：求 $\lim\limits_{x \to 0} \frac{\cos x}{x+1}$</h4>
                <p>直接代入 $x=0$:</p>
                <p>$= \frac{\cos 0}{0+1} = \frac{1}{1} = 1$</p>
            </div>

            <h3>极限的运算法则</h3>
            <p>直接代入法之所以成立，是因为极限满足<span class="highlight">加、减、乘、除</span>四则运算法则。</p>
            <div class="math-formula">
                和的极限 = 极限的和 <br>
                积的极限 = 极限的积 ...
            </div>
        </div>
        <div class="visualization" id="vis-limit-operations"></div>
    </div>

    <div class="slide">
        <div class="chalkboard">
            <h2>计算极限(2): "不定式"</h2>
            <p>当直接代入得到 $\frac{0}{0}$ 或 $\frac{\infty}{\infty}$ 时，称为<span class="highlight">不定式</span>。这说明有“隐藏”的答案，需要通过变形来求。</p>
            
            <h3>技巧1: 因式分解 (针对 $\frac{0}{0}$ 型)</h3>
            <p>分子分母中一定有导致它们为0的“坏蛋”因子，约掉它！</p>
            <div class="example-box">
                <h4>求 $\lim\limits_{x \to 1} \frac{x^2 - 1}{x - 1}$</h4>
                <p>1. 分解因式: $= \lim\limits_{x \to 1} \frac{(x-1)(x+1)}{x-1}$</p>
                <p>2. 约掉 $(x-1)$: $= \lim\limits_{x \to 1} (x+1)$</p>
                <p>3. 直接代入: $= 1+1 = 2$</p>
            </div>
            
            <h3>技巧2: 有理化 (针对带根号的 $\frac{0}{0}$ 型)</h3>
            <div class="example-box">
                <h4>求 $\lim\limits_{x \to 0} \frac{\sqrt{x+1} - 1}{x}$</h4>
                <p>分子分母同乘 $\sqrt{x+1}+1$:</p>
                <p>$= \lim\limits_{x \to 0} \frac{(x+1)-1}{x(\sqrt{x+1}+1)} = \lim\limits_{x \to 0} \frac{x}{x(\sqrt{x+1}+1)}$</p>
                <p>$= \lim\limits_{x \to 0} \frac{1}{\sqrt{x+1}+1} = \frac{1}{2}$</p>
            </div>
            
            <h3>技巧3: 同除最高次幂 (针对 $\frac{\infty}{\infty}$ 型)</h3>
             <div class="example-box">
                <h4>求 $\lim\limits_{x \to \infty} \frac{2x^2+1}{3x^2-x}$</h4>
                <p>分子分母同除以 $x^2$:</p>
                <p>$= \lim\limits_{x \to \infty} \frac{2+\frac{1}{x^2}}{3-\frac{1}{x}} = \frac{2+0}{3-0} = \frac{2}{3}$</p>
                <p><span class="highlight">规律：只看最高次幂的系数比。</span></p>
            </div>
        </div>
        <div class="visualization" id="vis-limit-methods"></div>
    </div>
    
    <div class="slide">
        <div class="chalkboard">
            <h2>两个重要极限 (公式)</h2>
            <p>这是两个非常有用的公式，专门解决特定类型的不定式。</p>
            
            <h3>重要极限 I</h3>
            <p>解决 $\frac{\sin(\cdot)}{(\cdot)}$ 型的不定式。</p>
            <div class="math-formula">
                $\lim\limits_{x \to 0} \frac{\sin x}{x} = 1$
            </div>
            <p><strong>理解：</strong>当角度 $x$ 很小很小时，$\sin x$ 的值几乎就等于 $x$ 本身。</p>
            <div class="example-box">
                <h4>应用：求 $\lim\limits_{x \to 0} \frac{\sin 3x}{x}$</h4>
                <p>凑出标准形式：</p>
                <p>$= \lim\limits_{x \to 0} \frac{\sin 3x}{3x} \cdot 3 = 1 \cdot 3 = 3$</p>
            </div>
            
            <h3>重要极限 II</h3>
            <p>解决 $1^\infty$ 型的不定式，与自然常数 $e$ 相关。</p>
            <div class="math-formula">
                $\lim\limits_{x \to \infty} \left(1 + \frac{1}{x}\right)^x = e \approx 2.718$
            </div>
            <p><strong>理解：</strong>银行“分无数次计息”的最终结果。</p>
            <div class="example-box">
                <h4>应用：求 $\lim\limits_{x \to \infty} \left(1 + \frac{2}{x}\right)^x$</h4>
                <p>凑出标准形式：</p>
                <p>$= \lim\limits_{x \to \infty} \left[\left(1 + \frac{1}{x/2}\right)^{x/2}\right]^2 = e^2$</p>
            </div>
        </div>
        <div class="visualization" id="vis-important-limits-detailed"></div>
    </div>

    <div class="slide">
        <div class="chalkboard">
            <h2>新视角：无穷小与无穷大</h2>
            
            <h3>无穷小 (Infinitesimal)</h3>
            <p>不是一个很小的数，而是一个<span class="highlight">以0为极限的变量</span>。</p>
            <p>例如，当 $x \to 0$ 时，$x$, $x^2$, $\sin x$ 都是无穷小。</p>
            
            <h3>无穷大 (Infinity)</h3>
            <p>一个<span class="highlight">极限为无穷的变量</span>。</p>
            <p>例如，当 $x \to \infty$ 时，$x$, $x^2$ 都是无穷大。</p>
            
            <div class="warning-box">
                <p><strong>重要关系：</strong></p>
                <p>在同一个过程中，一个非零的无穷小的倒数是无穷大。</p>
                <p>若 $\lim f(x) = 0$ 且 $f(x) \neq 0$，则 $\lim \frac{1}{f(x)} = \infty$</p>
            </div>
            
            <h3>无穷小的比较</h3>
            <p>无穷小奔向0的速度有快有慢。比如当 $x \to 0$ 时，$x^2$ 比 $x$ 更快地趋近于0。</p>
            <ul>
                <li><strong>高阶无穷小:</strong> 跑得更快，例如 $x^2$ 是 $x$ 的高阶。</li>
                <li><strong>低阶无穷小:</strong> 跑得更慢。</li>
                <li><strong>同阶无穷小:</strong> 速度差不多。</li>
                <li><strong>等价无穷小:</strong> 速度几乎完全一样，可以互相替换。</li>
            </ul>
        </div>
        <div class="visualization" id="vis-infinitesimal-comparison"></div>
    </div>
    
    <div class="slide">
        <div class="chalkboard">
            <h2>计算技巧：等价无穷小替换</h2>
            <p>当 $x \to 0$ 时，一些复杂的无穷小可以用简单的无穷小来替换，极大简化计算！</p>
            
            <h3>常用等价无穷小公式</h3>
            <div class="math-formula">
                <p>$\sin x \sim x$</p>
                <p>$\tan x \sim x$</p>
                <p>$1 - \cos x \sim \frac{1}{2}x^2$</p>
                <p>$e^x - 1 \sim x$</p>
                <p>$\ln(1+x) \sim x$</p>
            </div>
            
            <div class="warning-box">
                <p><strong>替换规则 (非常重要):</strong></p>
                <p>✔️ 只有当无穷小是<span class="highlight">乘除因子</span>时才能替换。</p>
                <p>❌ <span class="highlight">加减法中不能随便替换</span>，否则会出错！</p>
            </div>
            
            <div class="example-box">
                <h4>应用例子</h4>
                <p>求 $\lim\limits_{x \to 0} \frac{\tan x \cdot (e^x-1)}{1-\cos x}$</p>
                <p>替换后:</p>
                <p>$= \lim\limits_{x \to 0} \frac{x \cdot x}{\frac{1}{2}x^2} = \lim\limits_{x \to 0} \frac{x^2}{\frac{1}{2}x^2} = 2$</p>
            </div>
        </div>
        <div class="visualization" id="vis-equivalent-infinitesimal"></div>
    </div>
    
    <div class="slide">
        <div class="chalkboard">
            <h2>连续性: 极限的应用</h2>
            
            <h3>直观理解</h3>
            <p>一个函数是连续的，意味着它的图像是<span class="highlight">一笔画出来的，没有断点</span>。</p>
            
            <h3>严格定义</h3>
            <p>函数 $f(x)$ 在点 $x_0$ 处连续，必须<span class="highlight">同时满足</span>以下三个条件：</p>
            <div class="step-box">
                <p><strong>1. 在该点有定义:</strong> $f(x_0)$ 存在。</p>
                <p><strong>2. 在该点极限存在:</strong> $\lim\limits_{x \to x_0} f(x)$ 存在 (即左极限 = 右极限)。</p>
                <p><strong>3. 极限值等于函数值:</strong> $\lim\limits_{x \to x_0} f(x) = f(x_0)$。</p>
            </div>
            <p><strong>核心：</strong><span class="highlight">极限值 = 函数值</span></p>
            
            <div class="example-box">
                <h4>为什么直接代入法有效？</h4>
                <p>因为我们学过的大部分函数（如多项式、指数、对数、三角函数）在它们的定义域内都是<span class="highlight">连续的</span>。</p>
                <p>对于连续函数，求极限就等于求函数值。</p>
            </div>
        </div>
        <div class="visualization" id="vis-continuous-functions"></div>
    </div>

    <div class="slide">
        <div class="chalkboard">
            <h2>间断点: 函数在哪里“断开”？</h2>
            <p>如果一个函数在某点不连续，那么这个点就是它的<span class="highlight">间断点</span>。</p>
            
            <h3>第一类间断点 (左右极限都存在)</h3>
            <div class="example-box">
                <h4>1. 可去间断点</h4>
                <p>特点: 左右极限相等，但<span class="highlight">不等于函数值</span> (或该点无定义)。就像路上有个小坑，可以补上。</p>
                <p>例: $f(x) = \frac{\sin x}{x}$ 在 $x=0$ 处。</p>
            </div>
            
            <div class="example-box">
                <h4>2. 跳跃间断点</h4>
                <p>特点: <span class="highlight">左右极限不相等</span>。就像楼梯，从一边跳到另一边。</p>
                <p>例: 符号函数 $\text{sgn}(x)$ 在 $x=0$ 处。</p>
            </div>
            
            <h3>第二类间断点 (至少一侧极限不存在)</h3>
            <div class="example-box">
                <p>例如<span class="highlight">无穷间断点</span> ($f(x) = \frac{1}{x}$ 在 $x=0$) 或<span class="highlight">振荡间断点</span> ($f(x) = \sin\frac{1}{x}$ 在 $x=0$)。</p>
            </div>
        </div>
        <div class="visualization" id="vis-discontinuities"></div>
    </div>

    <div class="slide">
        <div class="chalkboard">
            <h2>连续函数的基本性质</h2>
            
            <h3>关键结论</h3>
            <p><span class="highlight">所有初等函数在其定义域内都是连续的！</span></p>
            <p>这意味着，只要代入的值在定义域内，你就可以放心地使用“直接代入法”求极限。</p>
            
            <h3>零点定理 (介值定理的应用)</h3>
            <p>这是一个非常直观且有用的定理。</p>
            <div class="example-box">
                <p>如果一个<span class="highlight">连续函数</span>的图像，一端在x轴下方($f(a) < 0$)，另一端在x轴上方($f(b) > 0$)，那么它的图像<span class="highlight">必然会穿过x轴至少一次</span>。</p>
                <p>这个穿越点 $c$ 就是函数的<span class="highlight">零点</span>，即 $f(c)=0$。</p>
                <p><strong>应用：</strong>可以用来判断方程有没有根。</p>
            </div>
            
            <h3>最值定理</h3>
             <div class="example-box">
                <p>在一个<span class="highlight">封闭区间</span> $[a,b]$ 上的连续函数，<span class="highlight">必定有最大值和最小值</span>。</p>
                <p><strong>注意：</strong>必须是闭区间，开区间不一定成立。</p>
            </div>
        </div>
        <div class="visualization" id="vis-continuity-determination"></div>
    </div>
    
    <div class="slide">
        <div class="chalkboard">
            <h2>极限的实际应用</h2>
            
            <h3>1. 瞬时速度</h3>
            <div class="example-box">
                <h4>问题：汽车t秒时的瞬时速度</h4>
                <p>平均速度 = $\frac{\Delta s}{\Delta t}$ (路程差 / 时间差)</p>
                <p>让时间差 $\Delta t \to 0$，取极限，就得到了瞬时速度！</p>
                <p>瞬时速度 = $\lim\limits_{\Delta t \to 0} \frac{s(t+\Delta t) - s(t)}{\Delta t}$</p>
            </div>
            
            <h3>2. 边际成本 (经济学)</h3>
            <div class="example-box">
                <h4>问题：多生产一件产品，成本增加多少？</h4>
                <p>当产量增加量 $\Delta x \to 0$ 时，成本变化率的极限就是边际成本。</p>
                <p>边际成本 = $\lim\limits_{\Delta x \to 0} \frac{C(x+\Delta x) - C(x)}{\Delta x}$</p>
            </div>
            
            <h3>3. 图像压缩 (JPEG)</h3>
            <div class="example-box">
                <h4>渐进式压缩</h4>
                <p>网页上模糊的图片逐渐变清晰的过程，就是用一系列不断优化的图像 $\{P_n\}$ 来逼近原始图像 $P_{原始}$。</p>
                <p>这个过程的极限就是清晰的原图。</p>
            </div>
            
            <p><strong>本质：</strong>极限是微积分的基石，它让我们能研究<span class="highlight">瞬间的变化率</span>，也就是<span class="highlight">导数</span>！</p>
        </div>
        <div class="visualization" id="vis-applications"></div>
    </div>

    <div class="slide">
        <div class="chalkboard">
            <h2>章节总结</h2>
            
            <h3>核心概念网络</h3>
            <div class="step-box" style="font-size: 1rem; line-height: 1.5;">
                <p><strong>极限 (核心思想)</strong> → 描述“无限趋近”</p>
                <p>├─ <strong>函数极限</strong> → 如何定义？(左右极限相等)</p>
                <p>├─ <strong>计算极限 (核心技能)</strong></p>
                <p>│  ├─ 简单情况: <span class="highlight">直接代入</span></p>
                <p>│  └─ 不定式: <span class="highlight">变形</span> (因式分解, 有理化...)</p>
                <p>├─ <strong>计算工具 (两大公式)</strong></p>
                <p>│  ├─ <span class="highlight">重要极限 I</span> ($\frac{\sin x}{x}$)</p>
                <p>│  └─ <span class="highlight">重要极限 II</span> ($e$)</p>
                <p>├─ <strong>高级技巧 (一个捷径)</strong></p>
                <p>│  └─ <span class="highlight">等价无穷小替换</span></p>
                <p>└─ <strong>极限的应用</strong></p>
                <p>   └─ <strong>连续性</strong> (极限值 = 函数值)</p>
            </div>
            
            <h3>学习要点</h3>
            <ul>
                <li>极限是<span class="highlight">过程</span>和<span class="highlight">趋势</span>。</li>
                <li>计算极限先<span class="highlight">代入尝试</span>，不行再变形。</li>
                <li>$\frac{0}{0}$ 型要<span class="highlight">约掉公因子</span>。</li>
                <li>$\frac{\infty}{\infty}$ 型看<span class="highlight">最高次幂</span>。</li>
                <li>等价无穷小是<span class="highlight">乘除法</span>的利器。</li>
            </ul>
            
            <div class="warning-box">
                <p><strong>下一步预告：</strong></p>
                <p>有了极限这个工具，我们就可以定义微积分最核心的概念——<span class="highlight">导数</span>！</p>
            </div>
        </div>
        <div class="visualization" id="vis-summary"></div>
    </div>

    <div class="navigation">
        <button class="slide-nav-btn" onclick="previousSlide()" title="上一页 (← / ↑ / PageUp)">‹</button>
        <span class="page-info"><span id="current-page">1</span>/<span id="total-pages">15</span></span>
        <button class="slide-nav-btn" onclick="nextSlide()" title="下一页 (→ / ↓ / PageDown)">›</button>
    </div>
</div>

<script>
    // ============ 全局变量和初始化 ============
    const slides = document.querySelectorAll('.slide');
    const totalSlides = slides.length;
    const currentPageElement = document.getElementById('current-page');
    const totalPagesElement = document.getElementById('total-pages');
    let currentSlide = 0;
    let currentAnimations = [];
    let globalAnimationSpeed = 1.0;

    // MathJax重新渲染
    const renderMathJax = async (container) => {
        if (window.MathJax && window.MathJax.typesetPromise) {
            try {
                await window.MathJax.typesetPromise([container]);
            } catch (error) {
                console.warn('MathJax rendering failed:', error);
            }
        }
    };

    // 幻灯片控制
    function showSlide(index) {
        if (index < 0 || index >= totalSlides) return;
        
        // 清理之前的动画
        cleanupAnimations();
        
        slides.forEach(slide => slide.classList.remove('active'));
        currentSlide = index;
        slides[currentSlide].classList.add('active');
        
        // 更新导航器中的页面信息
        if (currentPageElement) {
            currentPageElement.textContent = currentSlide + 1;
        }
        if (totalPagesElement) {
            totalPagesElement.textContent = totalSlides;
        }

        // 渲染当前页面的MathJax
        setTimeout(() => {
            const currentSlideElement = slides[currentSlide];
            renderMathJax(currentSlideElement);
        }, 100);

        // 运行当前页的可视化
        runVisualization(currentSlide);
    }

    function cleanupAnimations() {
        currentAnimations.forEach(cleanup => {
            if (typeof cleanup === 'function') {
                cleanup();
            }
        });
        currentAnimations = [];
    }

    function nextSlide() {
        showSlide((currentSlide + 1) % totalSlides);
    }

    function previousSlide() {
        showSlide((currentSlide - 1 + totalSlides) % totalSlides);
    }

    // 跳转到指定页面
    function goToSlide(index) {
        showSlide(index);
    }

    // 键盘控制
    document.addEventListener('keydown', (e) => {
        if (e.key === 'ArrowRight' || e.key === 'PageDown' || e.key === 'ArrowDown' || e.key === ' ') {
            e.preventDefault();
            nextSlide();
        } else if (e.key === 'ArrowLeft' || e.key === 'PageUp' || e.key === 'ArrowUp') {
            e.preventDefault();
            previousSlide();
        } else if (e.key === 'Home') {
            e.preventDefault();
            showSlide(0);
        } else if (e.key === 'End') {
            e.preventDefault();
            showSlide(totalSlides - 1);
        }
    });

    // ============ D3.js 辅助函数 (保持不变) ============
    function setupD3(containerId, margins = {top: 40, right: 40, bottom: 60, left: 60}) {
     const container = d3.select(`#${containerId}`);
     if (container.empty()) return null;
     
     container.html('');
     const bounds = container.node().getBoundingClientRect();
     
     const svg = container.append('svg')
         .attr('width', bounds.width)
         .attr('height', bounds.height);
         
     const width = bounds.width - margins.left - margins.right;
     const height = bounds.height - margins.top - margins.bottom;
     
     const g = svg.append('g')
         .attr('transform', `translate(${margins.left}, ${margins.top})`);
     
     // 添加箭头标记
     svg.append('defs').append('marker')
         .attr('id', 'arrowhead')
         .attr('viewBox', '0 -5 10 10')
         .attr('refX', 8)
         .attr('refY', 0)
         .attr('markerWidth', 8)
         .attr('markerHeight', 8)
         .attr('orient', 'auto')
         .append('path')
         .attr('d', 'M0,-5L10,0L0,5')
         .attr('fill', 'var(--danger-color)');
         
     return { container, svg, g, width, height };
    }
    
    // ... (其余辅助函数如 drawAxes, animatePath, expandVisualization 等保持不变) ...

    // ============ 可视化函数 (更新后的逻辑) ============
    function runVisualization(slideIndex) {
        // Updated Switch Statement for new slide order
        switch(slideIndex) {
            case 0: break; // 封面页
            case 1: break; // 目录页
            case 2: visualizeWhyLimit(); break;
            case 3: visualizeIntuitiveLimit(); break;
            case 4: visualizeOneSidedLimits(); break; // 新: 函数极限与左右极限
            case 5: visualizeLimitOperations(); break; // 新: 直接代入与法则
            case 6: visualizeLimitMethods(); break; // 新: 不定式处理
            case 7: visualizeImportantLimitsDetailed(); break; // 新: 两个重要极限
            case 8: visualizeInfinitesimalComparison(); break; // 新: 无穷小
            case 9: visualizeEquivalentInfinitesimal(); break; // 新: 等价无穷小
            case 10: visualizeContinuousFunctions(); break; // 新: 连续性
            case 11: visualizeDiscontinuities(); break; // 新: 间断点
            case 12: visualizeContinuityDetermination(); break; // 新: 连续性质
            case 13: visualizeApplications(); break;
            case 14: visualizeSummary(); break;
        }
    }
    
    // ==========================================================
    // Placeholder visualization functions
    // (In a real implementation, you would move the original JS functions here,
    // matching the new slide order defined in the runVisualization function)
    // For brevity, I'll show the structure, assuming original functions are available.
    // ==========================================================
    
    // Existing JS functions (visualizeWhyLimit, visualizeIntuitiveLimit, etc.) would go here.
    // Make sure they are correctly named and called by the updated runVisualization switch statement.
    // No changes are needed inside the visualization functions themselves.
    
    // ... [Paste ALL ORIGINAL visualize...() functions here, they don't need to be changed] ...
    
         // 第1页：为什么要学极限
     function visualizeWhyLimit() {
         const setup = setupD3('vis-why-limit');
         if (!setup) return;
         const { g, width, height } = setup;
         
         // 阿基里斯追龟动画
         const trackY = height / 2;
         g.append('line')
             .attr('x1', 0)
             .attr('x2', width)
             .attr('y1', trackY)
             .attr('y2', trackY)
             .attr('stroke', '#34495e')
             .attr('stroke-width', 3);
         
         // 阿基里斯
         const achilles = g.append('g');
         achilles.append('circle')
             .attr('r', 15)
             .attr('fill', '#3498db')
             .attr('cy', trackY - 30);
         achilles.append('text')
             .attr('y', trackY - 50)
             .attr('text-anchor', 'middle')
             .attr('fill', '#34495e')
             .text('阿基里斯');
         
         // 乌龟
         const tortoise = g.append('g');
         tortoise.append('circle')
             .attr('r', 10)
             .attr('fill', '#2ecc71')
             .attr('cy', trackY + 30);
         tortoise.append('text')
             .attr('y', trackY + 50)
             .attr('text-anchor', 'middle')
             .attr('fill', '#34495e')
             .text('乌龟');
         
         // 距离标记
         const distanceText = g.append('text')
             .attr('x', width / 2)
             .attr('y', 30)
             .attr('text-anchor', 'middle')
             .attr('fill', '#34495e')
             .style('font-size', '18px');
         
         let step = 0;
         const steps = [
             { achilles: 0, tortoise: 200, text: "初始：乌龟领先200米" },
             { achilles: 200, tortoise: 220, text: "第1步：阿基里斯跑到200米，乌龟到220米" },
             { achilles: 220, tortoise: 222, text: "第2步：阿基里斯跑到220米，乌龟到222米" },
             { achilles: 222, tortoise: 222.2, text: "第3步：距离越来越小..." },
             { achilles: 222.2, tortoise: 222.22, text: "第4步：差距仅0.02米" },
             { achilles: 222.22, tortoise: 222.222, text: "无限接近！极限思想的体现" }
         ];
         
         function animate() {
             if (step >= steps.length) {
                 step = 0;
             }
             
             const currentStep = steps[step];
             const scale = width / 300;
             
             achilles.transition()
                 .duration(2000 / globalAnimationSpeed)
                 .attr('transform', `translate(${currentStep.achilles * scale}, 0)`);
             
             tortoise.transition()
                 .duration(2000 / globalAnimationSpeed)
                 .attr('transform', `translate(${currentStep.tortoise * scale}, 0)`);
             
             distanceText.text(currentStep.text);
             
             step++;
             const timeoutId = setTimeout(animate, 3000 / globalAnimationSpeed);
             currentAnimations.push(() => clearTimeout(timeoutId));
         }
         
         animate();
     }

     // 第2页：极限的直观理解
     function visualizeIntuitiveLimit() {
         const setup = setupD3('vis-intuitive-limit');
         if (!setup) return;
         const { g, width, height } = setup;
         
         // 杯子倒水动画
         const cupWidth = 100;
         const cupHeight = 200;
         const cupX = width / 2 - cupWidth / 2;
         const cupY = height / 2 - cupHeight / 2;
         
         // 杯子轮廓
         g.append('rect')
             .attr('x', cupX)
             .attr('y', cupY)
             .attr('width', cupWidth)
             .attr('height', cupHeight)
             .attr('fill', 'none')
             .attr('stroke', '#34495e')
             .attr('stroke-width', 3);
         
         // 刻度线
         for (let i = 1; i <= 10; i++) {
             const y = cupY + cupHeight - (cupHeight * i / 10);
             g.append('line')
                 .attr('x1', cupX - 10)
                 .attr('x2', cupX)
                 .attr('y1', y)
                 .attr('y2', y)
                 .attr('stroke', '#34495e')
                 .attr('stroke-width', 1);
             
             if (i % 2 === 0) {
                 g.append('text')
                     .attr('x', cupX - 15)
                     .attr('y', y + 3)
                     .attr('text-anchor', 'end')
                     .attr('fill', '#34495e')
                     .style('font-size', '12px')
                     .text(`${i / 10}L`);
             }
         }
         
         // 水位
         const water = g.append('rect')
             .attr('x', cupX + 2)
             .attr('y', cupY + cupHeight - 2)
             .attr('width', cupWidth - 4)
             .attr('height', 0)
             .attr('fill', 'rgba(52, 152, 219, 0.7)');
         
         // 显示当前水量
         const volumeText = g.append('text')
             .attr('x', width / 2)
             .attr('y', cupY - 20)
             .attr('text-anchor', 'middle')
             .attr('fill', '#34495e')
             .style('font-size', '18px');
         
         let totalVolume = 0;
         let pourCount = 0;
         
         function pour() {
             if (pourCount > 8) {
                 totalVolume = 0;
                 pourCount = 0;
                 water.attr('height', 0).attr('y', cupY + cupHeight - 2);
             }
             
             const pourAmount = 0.5 * Math.pow(0.5, pourCount);
             totalVolume += pourAmount;
             
             water.transition()
                 .duration(1000 / globalAnimationSpeed)
                 .attr('height', cupHeight * totalVolume)
                 .attr('y', cupY + cupHeight - cupHeight * totalVolume);
             
             volumeText.text(`当前：${totalVolume.toFixed(4)}L，本次倒入：${pourAmount.toFixed(4)}L`);
             
             pourCount++;
             const timeoutId = setTimeout(pour, 2000 / globalAnimationSpeed);
             currentAnimations.push(() => clearTimeout(timeoutId));
         }
         
         pour();
     }
    
    // 第4页：函数极限与左右极限
    function visualizeOneSidedLimits() {
        const setup = setupD3('vis-one-sided-limits');
        if (!setup) return;
        const { g, width, height } = setup;
        
        const centerX = width / 2;
        const centerY = height / 2;
        
        // 绘制函数 f(x) = (x^2 - 1)/(x - 1) 在 x=1 处的极限
        const xScale = d3.scaleLinear().domain([-2, 4]).range([0, width]);
        const yScale = d3.scaleLinear().domain([-3, 5]).range([height, 0]);
        
        // 绘制坐标轴
        g.append('line')
            .attr('x1', xScale(-2)).attr('x2', xScale(4))
            .attr('y1', yScale(0)).attr('y2', yScale(0))
            .attr('stroke', '#34495e').attr('stroke-width', 2);
            
        g.append('line')
            .attr('x1', xScale(0)).attr('x2', xScale(0))
            .attr('y1', yScale(-3)).attr('y2', yScale(5))
            .attr('stroke', '#34495e').attr('stroke-width', 2);
        
        // 绘制函数 f(x) = x + 1 (当 x ≠ 1 时)
        const lineData = [];
        for (let x = -2; x <= 4; x += 0.1) {
            if (Math.abs(x - 1) > 0.1) {
                lineData.push({x: x, y: x + 1});
            }
        }
        
        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y))
            .curve(d3.curveLinear);
            
        g.append('path')
            .datum(lineData)
            .attr('d', line)
            .attr('stroke', '#3498db')
            .attr('stroke-width', 3)
            .attr('fill', 'none');
        
        // 标记 x = 1 处的空洞
        g.append('circle')
            .attr('cx', xScale(1))
            .attr('cy', yScale(2))
            .attr('r', 6)
            .attr('fill', '#2c3e50')
            .attr('stroke', '#3498db')
            .attr('stroke-width', 3);
            
        // 标记极限值 y = 2
        g.append('line')
            .attr('x1', xScale(0.8))
            .attr('x2', xScale(1.2))
            .attr('y1', yScale(2))
            .attr('y2', yScale(2))
            .attr('stroke', '#e74c3c')
            .attr('stroke-width', 4)
            .attr('stroke-dasharray', '5,5');
        
        // 左极限点
        const leftPoint = g.append('circle')
            .attr('cx', xScale(0.8))
            .attr('cy', yScale(1.8))
            .attr('r', 8)
            .attr('fill', '#e74c3c');
            
        // 右极限点
        const rightPoint = g.append('circle')
            .attr('cx', xScale(1.2))
            .attr('cy', yScale(2.2))
            .attr('r', 8)
            .attr('fill', '#2ecc71');
        
        // 动画：左右极限点向中心移动
        function animateApproach() {
            leftPoint.transition()
                .duration(2000 / globalAnimationSpeed)
                .attr('cx', xScale(1))
                .attr('cy', yScale(2))
                .transition()
                .duration(500 / globalAnimationSpeed)
                .attr('r', 4);
                
            rightPoint.transition()
                .duration(2000 / globalAnimationSpeed)
                .attr('cx', xScale(1))
                .attr('cy', yScale(2))
                .transition()
                .duration(500 / globalAnimationSpeed)
                .attr('r', 4);
        }
        
        // 重置并重复动画
        function resetAndAnimate() {
            leftPoint.attr('cx', xScale(0.8)).attr('cy', yScale(1.8)).attr('r', 8);
            rightPoint.attr('cx', xScale(1.2)).attr('cy', yScale(2.2)).attr('r', 8);
            
            setTimeout(() => {
                animateApproach();
                setTimeout(resetAndAnimate, 4000 / globalAnimationSpeed);
            }, 1000 / globalAnimationSpeed);
        }
        
        resetAndAnimate();
        
        // 添加标签
        g.append('text')
            .attr('x', xScale(1))
            .attr('y', yScale(2) - 20)
            .attr('text-anchor', 'middle')
            .attr('fill', '#34495e')
            .style('font-size', '16px')
            .text('极限 = 2');
    }
    
    // 第5页：直接代入法与运算法则
    function visualizeLimitOperations() {
        const setup = setupD3('vis-limit-operations');
        if (!setup) return;
        const { g, width, height } = setup;
        
        const centerX = width / 2;
        const centerY = height / 2;
        
        // 创建三个示例函数
        const examples = [
            {
                title: '例1: 多项式函数',
                formula: 'f(x) = x² + 3x - 1',
                limit: 'lim(x→2) f(x)',
                steps: [
                    'f(2) = 2² + 3×2 - 1',
                    '= 4 + 6 - 1',
                    '= 9'
                ],
                color: '#3498db'
            },
            {
                title: '例2: 三角函数',
                formula: 'g(x) = cos(x)/(x+1)',
                limit: 'lim(x→0) g(x)',
                steps: [
                    'g(0) = cos(0)/(0+1)',
                    '= 1/1',
                    '= 1'
                ],
                color: '#2ecc71'
            },
            {
                title: '例3: 有理函数',
                formula: 'h(x) = (x²-4)/(x-2)',
                limit: 'lim(x→2) h(x)',
                steps: [
                    'h(2) = (2²-4)/(2-2)',
                    '= 0/0 (不定式!)',
                    '需要变形处理'
                ],
                color: '#e74c3c'
            }
        ];
        
        // 绘制示例卡片
        examples.forEach((example, index) => {
            const cardX = (index * width) / 3 + width / 6;
            const cardY = centerY;
            
            // 卡片背景
            const card = g.append('g');
            
            card.append('rect')
                .attr('x', cardX - 120)
                .attr('y', cardY - 100)
                .attr('width', 240)
                .attr('height', 200)
                .attr('fill', 'rgba(255,255,255,0.9)')
                .attr('stroke', example.color)
                .attr('stroke-width', 2)
                .attr('rx', 10);
            
            // 标题
            card.append('text')
                .attr('x', cardX)
                .attr('y', cardY - 70)
                .attr('text-anchor', 'middle')
                .attr('fill', example.color)
                .style('font-size', '14px')
                .style('font-weight', 'bold')
                .text(example.title);
            
            // 公式
            card.append('text')
                .attr('x', cardX)
                .attr('y', cardY - 45)
                .attr('text-anchor', 'middle')
                .attr('fill', '#34495e')
                .style('font-size', '12px')
                .text(example.formula);
            
            // 极限表达式
            card.append('text')
                .attr('x', cardX)
                .attr('y', cardY - 20)
                .attr('text-anchor', 'middle')
                .attr('fill', '#34495e')
                .style('font-size', '12px')
                .text(example.limit);
            
            // 计算步骤
            example.steps.forEach((step, stepIndex) => {
                card.append('text')
                    .attr('x', cardX)
                    .attr('y', cardY + 10 + stepIndex * 20)
                    .attr('text-anchor', 'middle')
                    .attr('fill', '#34495e')
                    .style('font-size', '11px')
                    .text(step);
            });
        });
        
        // 添加运算法则说明
        g.append('text')
            .attr('x', centerX)
            .attr('y', height - 30)
            .attr('text-anchor', 'middle')
            .attr('fill', '#34495e')
            .style('font-size', '16px')
            .style('font-weight', 'bold')
            .text('核心：连续函数的极限 = 函数值');
    }
    
    // 第6页：不定式处理方法
    function visualizeLimitMethods() {
        const setup = setupD3('vis-limit-methods');
        if (!setup) return;
        const { g, width, height } = setup;
        
        const centerX = width / 2;
        const centerY = height / 2;
        
        // 创建方法卡片
        const methods = [
            {
                title: '方法1: 因式分解',
                example: 'lim(x→1) (x²-1)/(x-1)',
                solution: '= lim(x→1) (x+1) = 2',
                color: '#3498db'
            },
            {
                title: '方法2: 有理化',
                example: 'lim(x→0) (√(x+1)-1)/x',
                solution: '= lim(x→0) 1/(√(x+1)+1) = 1/2',
                color: '#2ecc71'
            },
            {
                title: '方法3: 同除最高次幂',
                example: 'lim(x→∞) (2x²+1)/(3x²-x)',
                solution: '= lim(x→∞) (2+1/x²)/(3-1/x) = 2/3',
                color: '#e67e22'
            }
        ];
        
        // 绘制方法卡片
        methods.forEach((method, index) => {
            const cardX = centerX;
            const cardY = 100 + index * 120;
            
            // 卡片背景
            const card = g.append('g');
            
            card.append('rect')
                .attr('x', cardX - 200)
                .attr('y', cardY - 40)
                .attr('width', 400)
                .attr('height', 80)
                .attr('fill', 'rgba(255,255,255,0.9)')
                .attr('stroke', method.color)
                .attr('stroke-width', 2)
                .attr('rx', 8);
            
            // 标题
            card.append('text')
                .attr('x', cardX - 180)
                .attr('y', cardY - 15)
                .attr('fill', method.color)
                .style('font-size', '14px')
                .style('font-weight', 'bold')
                .text(method.title);
            
            // 示例
            card.append('text')
                .attr('x', cardX - 180)
                .attr('y', cardY + 5)
                .attr('fill', '#34495e')
                .style('font-size', '12px')
                .text(method.example);
            
            // 解答
            card.append('text')
                .attr('x', cardX - 180)
                .attr('y', cardY + 25)
                .attr('fill', '#2c3e50')
                .style('font-size', '12px')
                .style('font-weight', 'bold')
                .text(method.solution);
        });
        
        // 添加提示
        g.append('text')
            .attr('x', centerX)
            .attr('y', height - 30)
            .attr('text-anchor', 'middle')
            .attr('fill', '#e74c3c')
            .style('font-size', '16px')
            .style('font-weight', 'bold')
            .text('关键：识别不定式类型，选择合适方法');
    }


    // 第7页：两个重要极限
    function visualizeImportantLimitsDetailed() {
        const setup = setupD3('vis-important-limits-detailed');
        if (!setup) return;
        const { g, width, height } = setup;
        
        const centerX = width / 2;
        const centerY = height / 2;
        
        // 重要极限1：sin(x)/x
        const limit1 = g.append('g').attr('transform', `translate(0, ${height/4})`);
        
        // 绘制sin(x)/x的图形
        const xScale1 = d3.scaleLinear().domain([-3, 3]).range([0, width]);
        const yScale1 = d3.scaleLinear().domain([0, 2]).range([height/4, 0]);
        
        // 坐标轴
        limit1.append('line')
            .attr('x1', xScale1(-3)).attr('x2', xScale1(3))
            .attr('y1', yScale1(0)).attr('y2', yScale1(0))
            .attr('stroke', '#34495e').attr('stroke-width', 2);
            
        limit1.append('line')
            .attr('x1', xScale1(0)).attr('x2', xScale1(0))
            .attr('y1', yScale1(0)).attr('y2', yScale1(2))
            .attr('stroke', '#34495e').attr('stroke-width', 2);
        
        // 绘制sin(x)/x曲线
        const sinData = [];
        for (let x = -3; x <= 3; x += 0.1) {
            if (Math.abs(x) > 0.05) {
                sinData.push({x: x, y: Math.sin(x) / x});
            }
        }
        
        const sinLine = d3.line()
            .x(d => xScale1(d.x))
            .y(d => yScale1(d.y))
            .curve(d3.curveLinear);
            
        limit1.append('path')
            .datum(sinData)
            .attr('d', sinLine)
            .attr('stroke', '#3498db')
            .attr('stroke-width', 3)
            .attr('fill', 'none');
        
        // 标记极限值1
        limit1.append('line')
            .attr('x1', xScale1(-0.5))
            .attr('x2', xScale1(0.5))
            .attr('y1', yScale1(1))
            .attr('y2', yScale1(1))
            .attr('stroke', '#e74c3c')
            .attr('stroke-width', 4)
            .attr('stroke-dasharray', '5,5');
        
        // 标记x=0处的空洞
        limit1.append('circle')
            .attr('cx', xScale1(0))
            .attr('cy', yScale1(1))
            .attr('r', 4)
            .attr('fill', '#2c3e50')
            .attr('stroke', '#3498db')
            .attr('stroke-width', 2);
        
        // 添加标签
        limit1.append('text')
            .attr('x', xScale1(-2.5))
            .attr('y', yScale1(1.8))
            .attr('fill', '#34495e')
            .style('font-size', '14px')
            .text('重要极限1: lim(x→0) sin(x)/x = 1');
        
        // 重要极限2：(1+1/x)^x
        const limit2 = g.append('g').attr('transform', `translate(0, ${height/2})`);
        
        const xScale2 = d3.scaleLinear().domain([0, 10]).range([0, width]);
        const yScale2 = d3.scaleLinear().domain([2, 3]).range([height/4, 0]);
        
        // 坐标轴
        limit2.append('line')
            .attr('x1', xScale2(0)).attr('x2', xScale2(10))
            .attr('y1', yScale2(2)).attr('y2', yScale2(2))
            .attr('stroke', '#34495e').attr('stroke-width', 2);
            
        limit2.append('line')
            .attr('x1', xScale2(0)).attr('x2', xScale2(0))
            .attr('y1', yScale2(2)).attr('y2', yScale2(3))
            .attr('stroke', '#34495e').attr('stroke-width', 2);
        
        // 绘制(1+1/x)^x曲线
        const eData = [];
        for (let x = 0.1; x <= 10; x += 0.1) {
            eData.push({x: x, y: Math.pow(1 + 1/x, x)});
        }
        
        const eLine = d3.line()
            .x(d => xScale2(d.x))
            .y(d => yScale2(d.y))
            .curve(d3.curveLinear);
            
        limit2.append('path')
            .datum(eData)
            .attr('d', eLine)
            .attr('stroke', '#2ecc71')
            .attr('stroke-width', 3)
            .attr('fill', 'none');
        
        // 标记极限值e
        limit2.append('line')
            .attr('x1', xScale2(8))
            .attr('x2', xScale2(10))
            .attr('y1', yScale2(Math.E))
            .attr('y2', yScale2(Math.E))
            .attr('stroke', '#e74c3c')
            .attr('stroke-width', 4)
            .attr('stroke-dasharray', '5,5');
        
        // 添加标签
        limit2.append('text')
            .attr('x', xScale2(1))
            .attr('y', yScale2(2.9))
            .attr('fill', '#34495e')
            .style('font-size', '14px')
            .text('重要极限2: lim(x→∞) (1+1/x)^x = e ≈ 2.718');
    }
    
    // 第8页：无穷小与无穷大
    function visualizeInfinitesimalComparison() {
        const setup = setupD3('vis-infinitesimal-comparison');
        if (!setup) return;
        const { g, width, height } = setup;
        
        const centerX = width / 2;
        const centerY = height / 2;
        
        // 创建无穷小比较动画
        const infinitesimals = [
            { name: 'x', fn: x => x, color: '#3498db' },
            { name: 'x²', fn: x => x * x, color: '#2ecc71' },
            { name: 'x³', fn: x => x * x * x, color: '#e74c3c' },
            { name: 'sin(x)', fn: x => Math.sin(x), color: '#9b59b6' }
        ];
        
        // 绘制坐标轴
        const xScale = d3.scaleLinear().domain([0, 2]).range([0, width]);
        const yScale = d3.scaleLinear().domain([0, 2]).range([height, 0]);
        
        g.append('line')
            .attr('x1', xScale(0)).attr('x2', xScale(2))
            .attr('y1', yScale(0)).attr('y2', yScale(0))
            .attr('stroke', '#34495e').attr('stroke-width', 2);
            
        g.append('line')
            .attr('x1', xScale(0)).attr('x2', xScale(0))
            .attr('y1', yScale(0)).attr('y2', yScale(2))
            .attr('stroke', '#34495e').attr('stroke-width', 2);
        
        // 绘制各无穷小函数
        infinitesimals.forEach((inf, index) => {
            const data = [];
            for (let x = 0.01; x <= 2; x += 0.01) {
                data.push({x: x, y: inf.fn(x)});
            }
            
            const line = d3.line()
                .x(d => xScale(d.x))
                .y(d => yScale(d.y))
                .curve(d3.curveLinear);
                
            g.append('path')
                .datum(data)
                .attr('d', line)
                .attr('stroke', inf.color)
                .attr('stroke-width', 3)
                .attr('fill', 'none');
            
            // 添加图例
            g.append('text')
                .attr('x', xScale(1.5))
                .attr('y', yScale(1.8) - index * 30)
                .attr('fill', inf.color)
                .style('font-size', '14px')
                .style('font-weight', 'bold')
                .text(inf.name);
        });
        
        // 添加说明
        g.append('text')
            .attr('x', xScale(1))
            .attr('y', yScale(0.3))
            .attr('text-anchor', 'middle')
            .attr('fill', '#34495e')
            .style('font-size', '16px')
            .style('font-weight', 'bold')
            .text('当 x → 0 时，各函数趋向0的速度不同');
    }
    
    // 第9页：等价无穷小替换
    function visualizeEquivalentInfinitesimal() {
        const setup = setupD3('vis-equivalent-infinitesimal');
        if (!setup) return;
        const { g, width, height } = setup;
        
        const centerX = width / 2;
        const centerY = height / 2;
        
        // 创建等价无穷小对
        const pairs = [
            { 
                original: 'sin(x)', 
                equivalent: 'x', 
                formula: 'sin(x) ~ x',
                color: '#3498db'
            },
            { 
                original: 'tan(x)', 
                equivalent: 'x', 
                formula: 'tan(x) ~ x',
                color: '#2ecc71'
            },
            { 
                original: '1-cos(x)', 
                equivalent: 'x²/2', 
                formula: '1-cos(x) ~ x²/2',
                color: '#e74c3c'
            },
            { 
                original: 'e^x-1', 
                equivalent: 'x', 
                formula: 'e^x-1 ~ x',
                color: '#9b59b6'
            }
        ];
        
        // 绘制等价对
        pairs.forEach((pair, index) => {
            const cardY = 80 + index * 100;
            
            // 卡片背景
            const card = g.append('g');
            
            card.append('rect')
                .attr('x', centerX - 250)
                .attr('y', cardY - 30)
                .attr('width', 500)
                .attr('height', 60)
                .attr('fill', 'rgba(255,255,255,0.9)')
                .attr('stroke', pair.color)
                .attr('stroke-width', 2)
                .attr('rx', 8);
            
            // 原始函数
            card.append('text')
                .attr('x', centerX - 200)
                .attr('y', cardY - 5)
                .attr('fill', '#34495e')
                .style('font-size', '16px')
                .text(pair.original);
            
            // 等价符号
            card.append('text')
                .attr('x', centerX - 50)
                .attr('y', cardY - 5)
                .attr('text-anchor', 'middle')
                .attr('fill', pair.color)
                .style('font-size', '18px')
                .style('font-weight', 'bold')
                .text('~');
            
            // 等价函数
            card.append('text')
                .attr('x', centerX + 100)
                .attr('y', cardY - 5)
                .attr('fill', '#34495e')
                .style('font-size', '16px')
                .text(pair.equivalent);
            
            // 公式
            card.append('text')
                .attr('x', centerX)
                .attr('y', cardY + 20)
                .attr('text-anchor', 'middle')
                .attr('fill', pair.color)
                .style('font-size', '14px')
                .style('font-weight', 'bold')
                .text(pair.formula);
        });
        
        // 添加使用规则
        g.append('text')
            .attr('x', centerX)
            .attr('y', height - 30)
            .attr('text-anchor', 'middle')
            .attr('fill', '#e74c3c')
            .style('font-size', '16px')
            .style('font-weight', 'bold')
            .text('规则：只能用于乘除法，不能用于加减法！');
    }
    
    // 第10页：连续性
    function visualizeContinuousFunctions() {
        const setup = setupD3('vis-continuous-functions');
        if (!setup) return;
        const { g, width, height } = setup;
        
        const centerX = width / 2;
        const centerY = height / 2;
        
        // 绘制连续函数示例
        const xScale = d3.scaleLinear().domain([-3, 3]).range([0, width]);
        const yScale = d3.scaleLinear().domain([-2, 4]).range([height, 0]);
        
        // 坐标轴
        g.append('line')
            .attr('x1', xScale(-3)).attr('x2', xScale(3))
            .attr('y1', yScale(0)).attr('y2', yScale(0))
            .attr('stroke', '#34495e').attr('stroke-width', 2);
            
        g.append('line')
            .attr('x1', xScale(0)).attr('x2', xScale(0))
            .attr('y1', yScale(-2)).attr('y2', yScale(4))
            .attr('stroke', '#34495e').attr('stroke-width', 2);
        
        // 连续函数：f(x) = x² + 1
        const continuousData = [];
        for (let x = -3; x <= 3; x += 0.1) {
            continuousData.push({x: x, y: x * x + 1});
        }
        
        const continuousLine = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y))
            .curve(d3.curveLinear);
            
        g.append('path')
            .datum(continuousData)
            .attr('d', continuousLine)
            .attr('stroke', '#2ecc71')
            .attr('stroke-width', 4)
            .attr('fill', 'none');
        
        // 标记一个连续点
        const pointX = 1;
        const pointY = pointX * pointX + 1;
        
        g.append('circle')
            .attr('cx', xScale(pointX))
            .attr('cy', yScale(pointY))
            .attr('r', 8)
            .attr('fill', '#2ecc71')
            .attr('stroke', '#27ae60')
            .attr('stroke-width', 3);
        
        // 添加连续性的三个条件
        const conditions = [
            '1. 函数在该点有定义',
            '2. 极限存在 (左右极限相等)',
            '3. 极限值 = 函数值'
        ];
        
        conditions.forEach((condition, index) => {
            g.append('text')
                .attr('x', xScale(-2.5))
                .attr('y', yScale(3.5) - index * 25)
                .attr('fill', '#34495e')
                .style('font-size', '14px')
                .text(condition);
        });
        
        // 添加标题
        g.append('text')
            .attr('x', xScale(0))
            .attr('y', yScale(-1.5))
            .attr('text-anchor', 'middle')
            .attr('fill', '#2ecc71')
            .style('font-size', '18px')
            .style('font-weight', 'bold')
            .text('连续函数：一笔画成，无断点');
    }
    
    // 第11页：间断点
    function visualizeDiscontinuities() {
        const setup = setupD3('vis-discontinuities');
        if (!setup) return;
        const { g, width, height } = setup;
        
        const centerX = width / 2;
        const centerY = height / 2;
        
        // 可去间断点示例
        const removable = g.append('g').attr('transform', `translate(0, ${height/6})`);
        
        const xScale1 = d3.scaleLinear().domain([-2, 4]).range([0, width]);
        const yScale1 = d3.scaleLinear().domain([0, 4]).range([height/6, 0]);
        
        // 绘制 f(x) = (x²-1)/(x-1) = x+1 (x≠1)
        const removableData = [];
        for (let x = -2; x <= 4; x += 0.1) {
            if (Math.abs(x - 1) > 0.05) {
                removableData.push({x: x, y: x + 1});
            }
        }
        
        const removableLine = d3.line()
            .x(d => xScale1(d.x))
            .y(d => yScale1(d.y))
            .curve(d3.curveLinear);
            
        removable.append('path')
            .datum(removableData)
            .attr('d', removableLine)
            .attr('stroke', '#3498db')
            .attr('stroke-width', 3)
            .attr('fill', 'none');
        
        // 标记空洞
        removable.append('circle')
            .attr('cx', xScale1(1))
            .attr('cy', yScale1(2))
            .attr('r', 6)
            .attr('fill', '#2c3e50')
            .attr('stroke', '#3498db')
            .attr('stroke-width', 3);
        
        removable.append('text')
            .attr('x', xScale1(-1.5))
            .attr('y', yScale1(3.5))
            .attr('fill', '#34495e')
            .style('font-size', '14px')
            .text('可去间断点：左右极限相等，但函数值不匹配');
        
        // 跳跃间断点示例
        const jump = g.append('g').attr('transform', `translate(0, ${height/2})`);
        
        const xScale2 = d3.scaleLinear().domain([-2, 4]).range([0, width]);
        const yScale2 = d3.scaleLinear().domain([-1, 3]).range([height/6, 0]);
        
        // 绘制分段函数
        const jumpData1 = [];
        const jumpData2 = [];
        
        for (let x = -2; x <= 1; x += 0.1) {
            jumpData1.push({x: x, y: x + 1});
        }
        
        for (let x = 1; x <= 4; x += 0.1) {
            jumpData2.push({x: x, y: x + 2});
        }
        
        const jumpLine = d3.line()
            .x(d => xScale2(d.x))
            .y(d => yScale2(d.y))
            .curve(d3.curveLinear);
            
        jump.append('path')
            .datum(jumpData1)
            .attr('d', jumpLine)
            .attr('stroke', '#e74c3c')
            .attr('stroke-width', 3)
            .attr('fill', 'none');
            
        jump.append('path')
            .datum(jumpData2)
            .attr('d', jumpLine)
            .attr('stroke', '#e74c3c')
            .attr('stroke-width', 3)
            .attr('fill', 'none');
        
        // 标记跳跃点
        jump.append('circle')
            .attr('cx', xScale2(1))
            .attr('cy', yScale2(2))
            .attr('r', 6)
            .attr('fill', '#e74c3c');
            
        jump.append('circle')
            .attr('cx', xScale2(1))
            .attr('cy', yScale2(3))
            .attr('r', 6)
            .attr('fill', 'white')
            .attr('stroke', '#e74c3c')
            .attr('stroke-width', 3);
        
        jump.append('text')
            .attr('x', xScale2(-1.5))
            .attr('y', yScale2(2.5))
            .attr('fill', '#34495e')
            .style('font-size', '14px')
            .text('跳跃间断点：左右极限不相等');
    }
    
    // 第12页：连续函数性质
    function visualizeContinuityDetermination() {
        const setup = setupD3('vis-continuity-determination');
        if (!setup) return;
        const { g, width, height } = setup;
        
        const centerX = width / 2;
        const centerY = height / 2;
        
        // 零点定理图示
        const xScale = d3.scaleLinear().domain([-2, 4]).range([0, width]);
        const yScale = d3.scaleLinear().domain([-2, 3]).range([height, 0]);
        
        // 坐标轴
        g.append('line')
            .attr('x1', xScale(-2)).attr('x2', xScale(4))
            .attr('y1', yScale(0)).attr('y2', yScale(0))
            .attr('stroke', '#34495e').attr('stroke-width', 2);
            
        g.append('line')
            .attr('x1', xScale(0)).attr('x2', xScale(0))
            .attr('y1', yScale(-2)).attr('y2', yScale(3))
            .attr('stroke', '#34495e').attr('stroke-width', 2);
        
        // 绘制连续函数 f(x) = x³ - 2x + 1
        const functionData = [];
        for (let x = -2; x <= 4; x += 0.1) {
            functionData.push({x: x, y: x*x*x - 2*x + 1});
        }
        
        const functionLine = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y))
            .curve(d3.curveLinear);
            
        g.append('path')
            .datum(functionData)
            .attr('d', functionLine)
            .attr('stroke', '#3498db')
            .attr('stroke-width', 3)
            .attr('fill', 'none');
        
        // 标记函数在区间端点的值
        g.append('circle')
            .attr('cx', xScale(-1))
            .attr('cy', yScale(-1 * -1 * -1 - 2 * -1 + 1))
            .attr('r', 8)
            .attr('fill', '#2ecc71');
            
        g.append('circle')
            .attr('cx', xScale(2))
            .attr('cy', yScale(2 * 2 * 2 - 2 * 2 + 1))
            .attr('r', 8)
            .attr('fill', '#e74c3c');
        
        // 标记零点
        const zeroPoint = g.append('circle')
            .attr('cx', xScale(0.618))
            .attr('cy', yScale(0))
            .attr('r', 8)
            .attr('fill', '#f39c12')
            .attr('opacity', 0);
        
        // 动画显示零点
        setTimeout(() => {
            zeroPoint.transition()
                .duration(1000 / globalAnimationSpeed)
                .attr('opacity', 1);
        }, 2000 / globalAnimationSpeed);
        
        // 添加说明
        g.append('text')
            .attr('x', xScale(-1.5))
            .attr('y', yScale(2.5))
            .attr('fill', '#34495e')
            .style('font-size', '14px')
            .text('零点定理：连续函数必过x轴');
        
        g.append('text')
            .attr('x', xScale(0.618))
            .attr('y', yScale(-0.5))
            .attr('text-anchor', 'middle')
            .attr('fill', '#f39c12')
            .style('font-size', '12px')
            .style('font-weight', 'bold')
            .text('零点');
    }
    
    // 第13页：实际应用
    function visualizeApplications() {
        const setup = setupD3('vis-applications');
        if (!setup) return;
        const { g, width, height } = setup;
        
        const centerX = width / 2;
        const centerY = height / 2;
        
        // 瞬时速度示例
        const velocity = g.append('g').attr('transform', `translate(0, ${height/8})`);
        
        const xScale1 = d3.scaleLinear().domain([0, 6]).range([0, width]);
        const yScale1 = d3.scaleLinear().domain([0, 20]).range([height/8, 0]);
        
        // 绘制位移函数 s(t) = t²
        const displacementData = [];
        for (let t = 0; t <= 6; t += 0.1) {
            displacementData.push({t: t, s: t * t});
        }
        
        const displacementLine = d3.line()
            .x(d => xScale1(d.t))
            .y(d => yScale1(d.s))
            .curve(d3.curveLinear);
            
        velocity.append('path')
            .datum(displacementData)
            .attr('d', displacementLine)
            .attr('stroke', '#3498db')
            .attr('stroke-width', 3)
            .attr('fill', 'none');
        
        // 标记t=3处的切线
        const tangentData = [];
        for (let t = 2; t <= 4; t += 0.1) {
            // 在t=3处的切线：s = 6(t-3) + 9 = 6t - 9
            tangentData.push({t: t, s: 6 * t - 9});
        }
        
        const tangentLine = d3.line()
            .x(d => xScale1(d.t))
            .y(d => yScale1(d.s))
            .curve(d3.curveLinear);
            
        velocity.append('path')
            .datum(tangentData)
            .attr('d', tangentLine)
            .attr('stroke', '#e74c3c')
            .attr('stroke-width', 2)
            .attr('stroke-dasharray', '5,5')
            .attr('fill', 'none');
        
        velocity.append('text')
            .attr('x', xScale1(1))
            .attr('y', yScale1(18))
            .attr('fill', '#34495e')
            .style('font-size', '14px')
            .text('瞬时速度 = 位移函数的导数');
        
        // 边际成本示例
        const cost = g.append('g').attr('transform', `translate(0, ${height/2})`);
        
        const xScale2 = d3.scaleLinear().domain([0, 10]).range([0, width]);
        const yScale2 = d3.scaleLinear().domain([0, 100]).range([height/4, 0]);
        
        // 绘制成本函数 C(x) = x² + 10x + 50
        const costData = [];
        for (let x = 0; x <= 10; x += 0.1) {
            costData.push({x: x, c: x * x + 10 * x + 50});
        }
        
        const costLine = d3.line()
            .x(d => xScale2(d.x))
            .y(d => yScale2(d.c))
            .curve(d3.curveLinear);
            
        cost.append('path')
            .datum(costData)
            .attr('d', costLine)
            .attr('stroke', '#2ecc71')
            .attr('stroke-width', 3)
            .attr('fill', 'none');
        
        cost.append('text')
            .attr('x', xScale2(1))
            .attr('y', yScale2(90))
            .attr('fill', '#34495e')
            .style('font-size', '14px')
            .text('边际成本 = 成本函数的导数');
        
        // 添加总结
        g.append('text')
            .attr('x', centerX)
            .attr('y', height - 30)
            .attr('text-anchor', 'middle')
            .attr('fill', '#e74c3c')
            .style('font-size', '16px')
            .style('font-weight', 'bold')
            .text('极限是导数的基石：导数 = 极限');
    }
    
    // 第14页：章节总结
    function visualizeSummary() {
        const setup = setupD3('vis-summary');
        if (!setup) return;
        const { g, width, height } = setup;
        
        const centerX = width / 2;
        const centerY = height / 2;
        
        // 创建知识网络图
        const nodes = [
            { id: 'limit', name: '极限', x: centerX, y: 100, color: '#e74c3c', size: 20 },
            { id: 'calculation', name: '计算极限', x: centerX - 150, y: 200, color: '#3498db', size: 16 },
            { id: 'continuity', name: '连续性', x: centerX + 150, y: 200, color: '#2ecc71', size: 16 },
            { id: 'direct', name: '直接代入', x: centerX - 200, y: 300, color: '#3498db', size: 12 },
            { id: 'indeterminate', name: '不定式', x: centerX - 100, y: 300, color: '#e67e22', size: 12 },
            { id: 'important', name: '重要极限', x: centerX + 100, y: 300, color: '#9b59b6', size: 12 },
            { id: 'equivalent', name: '等价无穷小', x: centerX + 200, y: 300, color: '#f39c12', size: 12 },
            { id: 'derivative', name: '导数', x: centerX, y: 400, color: '#e74c3c', size: 18 }
        ];
        
        const links = [
            { source: 'limit', target: 'calculation' },
            { source: 'limit', target: 'continuity' },
            { source: 'calculation', target: 'direct' },
            { source: 'calculation', target: 'indeterminate' },
            { source: 'continuity', target: 'important' },
            { source: 'continuity', target: 'equivalent' },
            { source: 'limit', target: 'derivative' }
        ];
        
        // 绘制连接线
        links.forEach(link => {
            const source = nodes.find(n => n.id === link.source);
            const target = nodes.find(n => n.id === link.target);
            
            g.append('line')
                .attr('x1', source.x)
                .attr('y1', source.y)
                .attr('x2', target.x)
                .attr('y2', target.y)
                .attr('stroke', '#34495e')
                .attr('stroke-width', 2);
        });
        
        // 绘制节点
        nodes.forEach(node => {
            g.append('circle')
                .attr('cx', node.x)
                .attr('cy', node.y)
                .attr('r', node.size)
                .attr('fill', node.color)
                .attr('stroke', '#2c3e50')
                .attr('stroke-width', 2);
            
            g.append('text')
                .attr('x', node.x)
                .attr('y', node.y + 5)
                .attr('text-anchor', 'middle')
                .attr('fill', '#2c3e50')
                .style('font-size', '12px')
                .style('font-weight', 'bold')
                .text(node.name);
        });
        
        // 添加箭头指向导数
        g.append('text')
            .attr('x', centerX)
            .attr('y', height - 50)
            .attr('text-anchor', 'middle')
            .attr('fill', '#e74c3c')
            .style('font-size', '18px')
            .style('font-weight', 'bold')
            .text('下一步：学习导数');
    }

    // 初始化第一页
    showSlide(0);

    // ============ 辅助函数 ============
    function drawAxes(g, xScale, yScale, width, height, options = {}) {
        const { 
            showGrid = false, 
            gridOpacity = 0.1,
            showLabels = true,
            xLabel = 'x',
            yLabel = 'y'
        } = options;
        
        // 绘制网格
        if (showGrid) {
            const xTicks = xScale.ticks(10);
            const yTicks = yScale.ticks(10);
            
            xTicks.forEach(d => {
                g.append('line')
                    .attr('x1', xScale(d))
                    .attr('x2', xScale(d))
                    .attr('y1', 0)
                    .attr('y2', height)
                    .attr('stroke', '#ccc')
                    .attr('stroke-width', 1)
                    .attr('opacity', gridOpacity);
            });
            
            yTicks.forEach(d => {
                g.append('line')
                    .attr('x1', 0)
                    .attr('x2', width)
                    .attr('y1', yScale(d))
                    .attr('y2', yScale(d))
                    .attr('stroke', '#ccc')
                    .attr('stroke-width', 1)
                    .attr('opacity', gridOpacity);
            });
        }
        
        // 绘制坐标轴
        g.append('line')
            .attr('x1', xScale.range()[0])
            .attr('x2', xScale.range()[1])
            .attr('y1', yScale(0))
            .attr('y2', yScale(0))
            .attr('stroke', '#34495e')
            .attr('stroke-width', 2);
            
        g.append('line')
            .attr('x1', xScale(0))
            .attr('x2', xScale(0))
            .attr('y1', yScale.range()[1])
            .attr('y2', yScale.range()[0])
            .attr('stroke', '#34495e')
            .attr('stroke-width', 2);
        
        // 添加标签
        if (showLabels) {
            g.append('text')
                .attr('x', width - 10)
                .attr('y', yScale(0) - 10)
                .attr('text-anchor', 'end')
                .attr('fill', '#34495e')
                .style('font-size', '12px')
                .text(xLabel);
                
            g.append('text')
                .attr('x', xScale(0) + 10)
                .attr('y', 20)
                .attr('fill', '#34495e')
                .style('font-size', '12px')
                .text(yLabel);
        }
    }
    
    function animatePath(path, duration = 2000) {
        const totalLength = path.node().getTotalLength();
        
        path.attr('stroke-dasharray', totalLength + ' ' + totalLength)
            .attr('stroke-dashoffset', totalLength)
            .transition()
            .duration(duration / globalAnimationSpeed)
            .ease(d3.easeLinear)
            .attr('stroke-dashoffset', 0);
    }
    
    function expandVisualization(containerId, title, content) {
        const overlay = document.createElement('div');
        overlay.className = 'expanded-overlay';
        overlay.innerHTML = `
            <div class="expanded-content">
                <button class="close-btn" onclick="this.parentElement.parentElement.remove()">×</button>
                <div class="expanded-title">${title}</div>
                <div class="expanded-annotation">${content}</div>
                <div class="expanded-svg-container">
                    <div id="expanded-${containerId}"></div>
                </div>
            </div>
        `;
        
        document.body.appendChild(overlay);
        
        // 触发动画
        setTimeout(() => {
            overlay.classList.add('active');
        }, 10);
        
        // 复制SVG内容到展开区域
        const originalSVG = document.querySelector(`#${containerId} svg`);
        if (originalSVG) {
            const expandedContainer = document.getElementById(`expanded-${containerId}`);
            expandedContainer.appendChild(originalSVG.cloneNode(true));
        }
    }
    
    // 全局函数定义
    window.previousSlide = previousSlide;
    window.nextSlide = nextSlide;
    window.goToSlide = goToSlide;
    window.toggleChapterMenu = function() {
        const toggle = document.getElementById('chapter-toggle');
        const content = document.getElementById('chapter-content');
        
        if (toggle && content) {
            toggle.classList.toggle('active');
            content.classList.toggle('active');
        }
    };

    // 浮动菜单功能
    document.addEventListener('DOMContentLoaded', function() {
        // 点击外部关闭菜单
        document.addEventListener('click', function(e) {
            const menu = document.getElementById('chapter-menu');
            if (menu && !menu.contains(e.target)) {
                const toggle = document.getElementById('chapter-toggle');
                const content = document.getElementById('chapter-content');
                if (toggle && content) {
                    toggle.classList.remove('active');
                    content.classList.remove('active');
                }
            }
        });
        
        // 键盘快捷键
        document.addEventListener('keydown', function(e) {
            if (e.ctrlKey || e.metaKey) {
                switch(e.key) {
                    case 'h':
                        e.preventDefault();
                        window.location.href = '../index.html';
                        break;
                    case 's':
                        e.preventDefault();
                        window.location.href = '../故事书/index.html';
                        break;
                    case 'e':
                        e.preventDefault();
                        window.location.href = '../习题/index.html';
                        break;
                    case 'r':
                        e.preventDefault();
                        window.location.href = '../网页资源/index.html';
                        break;
                }
            }
        });
    });

</script>

<div id="floating-menu">
    </div>

<div id="chapter-menu">
    <div id="chapter-toggle" class="menu-toggle" onclick="toggleChapterMenu()">
        <span class="menu-icon">📚</span>
    </div>
    <div id="chapter-content" class="menu-content">
        <a href="#" class="menu-item" onclick="goToSlide(0); toggleChapterMenu();"><span class="menu-icon">🏠</span><span class="menu-text">标题页</span></a>
        <a href="#" class="menu-item" onclick="goToSlide(1); toggleChapterMenu();"><span class="menu-icon">📋</span><span class="menu-text">目录</span></a>
        <a href="#" class="menu-item" onclick="goToSlide(2); toggleChapterMenu();"><span class="menu-icon">1</span><span class="menu-text">为什么要学极限</span></a>
        <a href="#" class="menu-item" onclick="goToSlide(3); toggleChapterMenu();"><span class="menu-icon">2</span><span class="menu-text">什么是极限(直观)</span></a>
        <a href="#" class="menu-item" onclick="goToSlide(4); toggleChapterMenu();"><span class="menu-icon">3</span><span class="menu-text">函数极限与左右极限</span></a>
        <a href="#" class="menu-item" onclick="goToSlide(5); toggleChapterMenu();"><span class="menu-icon">4</span><span class="menu-text">计算(1): 直接代入</span></a>
        <a href="#" class="menu-item" onclick="goToSlide(6); toggleChapterMenu();"><span class="menu-icon">5</span><span class="menu-text">计算(2): 不定式</span></a>
        <a href="#" class="menu-item" onclick="goToSlide(7); toggleChapterMenu();"><span class="menu-icon">6</span><span class="menu-text">两个重要极限</span></a>
        <a href="#" class="menu-item" onclick="goToSlide(8); toggleChapterMenu();"><span class="menu-icon">7</span><span class="menu-text">无穷小与无穷大</span></a>
        <a href="#" class="menu-item" onclick="goToSlide(9); toggleChapterMenu();"><span class="menu-icon">8</span><span class="menu-text">等价无穷小替换</span></a>
        <a href="#" class="menu-item" onclick="goToSlide(10); toggleChapterMenu();"><span class="menu-icon">9</span><span class="menu-text">连续性</span></a>
        <a href="#" class="menu-item" onclick="goToSlide(11); toggleChapterMenu();"><span class="menu-icon">10</span><span class="menu-text">间断点</span></a>
        <a href="#" class="menu-item" onclick="goToSlide(12); toggleChapterMenu();"><span class="menu-icon">11</span><span class="menu-text">连续函数性质</span></a>
        <a href="#" class="menu-item" onclick="goToSlide(13); toggleChapterMenu();"><span class="menu-icon">12</span><span class="menu-text">实际应用</span></a>
        <a href="#" class="menu-item" onclick="goToSlide(14); toggleChapterMenu();"><span class="menu-icon">13</span><span class="menu-text">章节总结</span></a>
    </div>
</div>

</body>
</html>