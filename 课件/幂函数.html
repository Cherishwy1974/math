<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>幂函数 y = xᵃ 可视化工具</title>
    <!-- 引入Tailwind CSS框架 -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 自定义滑块样式 */
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #3b82f6; /* blue-500 */
            cursor: pointer;
            border-radius: 50%;
            margin-top: -6px; /* 调整拇指位置使其居中 */
        }

        input[type=range]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #3b82f6;
            cursor: pointer;
            border-radius: 50%;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 font-sans flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-4xl bg-gray-800 rounded-xl shadow-2xl p-6 md:p-8 space-y-6">
        <!-- 标题和描述 -->
        <div class="text-center">
            <h1 class="text-3xl md:text-4xl font-bold text-white">幂函数可视化工具</h1>
            <p class="text-gray-400 mt-2 text-lg">探索 y = x<sup class="text-xl font-semibold text-blue-400">a</sup> 的图形</p>
        </div>

        <!-- 控制区域 -->
        <div class="bg-gray-900 p-4 rounded-lg flex flex-col md:flex-row items-center justify-center gap-4 md:gap-6">
            <label for="exponent" class="text-lg font-medium">指数 a:</label>
            <input id="exponent" type="range" min="-4" max="4" value="2" step="0.01" class="w-full md:w-64 h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
            <div class="bg-blue-500 text-white text-lg font-semibold w-24 h-10 flex items-center justify-center rounded-md shadow-lg">
                <span id="exponentValue">2.00</span>
            </div>
        </div>

        <!-- 绘图区域 -->
        <div class="bg-gray-900 p-2 rounded-lg">
            <canvas id="functionCanvas" width="800" height="600" class="w-full h-auto bg-gray-900 rounded-md"></canvas>
        </div>
    </div>

    <script>
        // 获取DOM元素
        const canvas = document.getElementById('functionCanvas');
        const ctx = canvas.getContext('2d');
        const exponentSlider = document.getElementById('exponent');
        const exponentValueSpan = document.getElementById('exponentValue');

        // 初始绘图
        draw();

        // 为滑块添加事件监听
        exponentSlider.addEventListener('input', () => {
            const exponent = parseFloat(exponentSlider.value);
            exponentValueSpan.textContent = exponent.toFixed(2); // 更新显示的值
            draw();
        });

        // 响应窗口大小变化
        window.addEventListener('resize', draw);

        function draw() {
            // 设置canvas的实际像素，以获得高清绘图
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * devicePixelRatio;
            canvas.height = rect.height * devicePixelRatio;
            ctx.scale(devicePixelRatio, devicePixelRatio);
            
            const canvasWidth = canvas.clientWidth;
            const canvasHeight = canvas.clientHeight;
            
            // 清空画布
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);

            // 定义绘图范围和参数
            const xMin = -10;
            const xMax = 10;
            const exponent = parseFloat(exponentSlider.value);
            
            // 动态计算y轴范围
            let yMin = -10;
            let yMax = 10;
            const testPoints = [];
            for (let x = xMin; x <= xMax; x += 0.1) {
                const y = Math.pow(x, exponent);
                if (!isNaN(y) && isFinite(y)) {
                    testPoints.push(y);
                }
            }
            if (testPoints.length > 0) {
                const calculatedYMax = Math.max(...testPoints);
                const calculatedYMin = Math.min(...testPoints);
                const padding = Math.max(1, Math.abs(calculatedYMax - calculatedYMin) * 0.1);
                yMax = Math.max(10, calculatedYMax + padding);
                yMin = Math.min(-10, calculatedYMin - padding);
            }


            // 坐标转换函数
            const toCanvasX = (x) => (x - xMin) / (xMax - xMin) * canvasWidth;
            const toCanvasY = (y) => canvasHeight - (y - yMin) / (yMax - yMin) * canvasHeight;

            // 绘制网格线
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            // 垂直网格线 (步长为1)
            for (let i = Math.floor(xMin); i <= Math.ceil(xMax); i++) {
                if(i === 0) continue;
                const xCanvas = toCanvasX(i);
                ctx.beginPath();
                ctx.moveTo(xCanvas, 0);
                ctx.lineTo(xCanvas, canvasHeight);
                ctx.stroke();
            }
             // 水平网格线
            const yGridStep = Math.pow(10, Math.floor(Math.log10((yMax-yMin)/10)));
            for (let i = Math.floor(yMin/yGridStep)*yGridStep; i <= Math.ceil(yMax/yGridStep)*yGridStep; i += yGridStep) {
                if(i === 0) continue;
                const yCanvas = toCanvasY(i);
                ctx.beginPath();
                ctx.moveTo(0, yCanvas);
                ctx.lineTo(canvasWidth, yCanvas);
                ctx.stroke();
            }


            // 绘制坐标轴
            ctx.strokeStyle = '#6b7280'; // gray-500
            ctx.lineWidth = 2;
            const xAxisY = toCanvasY(0);
            const yAxisX = toCanvasX(0);
            // x轴
            ctx.beginPath();
            ctx.moveTo(0, xAxisY);
            ctx.lineTo(canvasWidth, xAxisY);
            ctx.stroke();
            // y轴
            ctx.beginPath();
            ctx.moveTo(yAxisX, 0);
            ctx.lineTo(yAxisX, canvasHeight);
            ctx.stroke();

            // 绘制坐标轴刻度和标签
            ctx.fillStyle = '#9ca3af'; // gray-400
            ctx.font = '12px Arial';
            // x轴刻度
            for (let i = Math.floor(xMin); i <= xMax; i++) {
                 if (i === 0) continue;
                 const text = i.toString();
                 const textWidth = ctx.measureText(text).width;
                 ctx.fillText(text, toCanvasX(i) - textWidth / 2, xAxisY + 15);
            }
             // y轴刻度
             for (let i = Math.floor(yMin/yGridStep)*yGridStep; i <= Math.ceil(yMax/yGridStep)*yGridStep; i += yGridStep) {
                 if (i === 0) continue;
                 const text = i.toPrecision(2);
                 ctx.fillText(text, yAxisX + 8, toCanvasY(i) + 4);
            }
            // 原点
            ctx.fillText('0', yAxisX - 12, xAxisY + 15);


            // 绘制函数图像
            ctx.strokeStyle = '#3b82f6'; // blue-500
            ctx.lineWidth = 3;
            ctx.beginPath();

            let firstPoint = true;
            // 使用更小的步长来获得平滑的曲线
            for (let x = xMin; x <= xMax; x += 0.01) {
                const y = Math.pow(x, exponent);

                if (isNaN(y) || !isFinite(y)) {
                    // 如果y是无效值 (如对负数开平方根)，则重置路径
                    firstPoint = true;
                    continue;
                }

                const canvasX = toCanvasX(x);
                const canvasY = toCanvasY(y);
                
                // 检查点是否在画布范围内
                if (canvasY < -10 || canvasY > canvasHeight + 10) {
                     firstPoint = true;
                     continue;
                }

                if (firstPoint) {
                    ctx.moveTo(canvasX, canvasY);
                    firstPoint = false;
                } else {
                    ctx.lineTo(canvasX, canvasY);
                }
            }
            ctx.stroke();
        }
    </script>
</body>
</html>
