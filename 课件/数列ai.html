<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>数列可视化工具 | DeepSeek API</title>
    <script src="../common-assets/js/tailwind.min.js"></script>
    <script src="../common-assets/js/d3-7.8.5.min.js"></script>
    <script>
        MathJax = {
          tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$'], ['\\[', '\\]']],
            processEscapes: true,
            tags: 'ams'
          },
          svg: {
            fontCache: 'global'
          }
        };
    </script>
    <script async src="../common-assets/js/mathjax-3.2.2-tex-svg.min.js" type="text/javascript"></script>
    <style>
        body {
            font-family: 'Inter', 'Helvetica Neue', 'Arial', 'PingFang SC', 'Microsoft YaHei', sans-serif;
        }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .btn-spinner {
            border-top-color: white;
            width: 20px;
            height: 20px;
        }

        /* Navigation Button Styles */
        .nav-button {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 50px;
            padding: 12px 20px;
            font-weight: bold;
            font-size: 14px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .nav-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
            background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
        }

        .nav-button:active {
            transform: translateY(0);
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen">

    <!-- Navigation Button -->
    <button class="nav-button" onclick="navigateToFunctions()" title="切换到函数课件">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M3 3v18h18"/>
            <path d="m19 9-5 5-4-4-3 3"/>
        </svg>
        函数课件
    </button>

    <div class="w-full max-w-4xl mx-auto p-4 md:p-8">
        <div class="bg-white rounded-2xl shadow-lg p-6 md:p-8">
            <div class="text-center mb-6">
                <h1 class="text-3xl md:text-4xl font-bold text-gray-800">数列可视化生成器</h1>
                <p class="text-gray-500 mt-2">输入一个数列公式, AI将为您绘制图像并计算极限。</p>
            </div>

            <!-- Input Section -->
            <div class="flex flex-col md:flex-row gap-4 mb-4">
                <div class="relative flex-grow">
                    <span class="absolute left-4 top-1/2 -translate-y-1/2 font-bold text-gray-500">a<sub>n</sub> =</span>
                    <input type="text" id="formula-input" placeholder="例如: n方加1除以2n方减1 或 an = (-1)^n / n"
                           class="w-full pl-16 pr-4 py-3 text-lg border-2 border-gray-200 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-all duration-300">
                </div>
                <button id="visualize-btn"
                        class="w-full md:w-auto bg-blue-600 text-white font-bold text-lg px-6 py-3 rounded-lg hover:bg-blue-700 active:scale-95 transition-all duration-300 flex items-center justify-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 20a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.9a2 2 0 0 1-1.69-.9L8.6 3.3a2 2 0 0 0-1.7-.9H3a2 2 0 0 0-2 2v13a2 2 0 0 0 2 2Z"></path><path d="M2 10h20"></path><path d="m9 14 2 2 4-4"></path></svg>
                    <span>生成图像</span>
                </button>
                 <button id="show-limit-btn"
                        class="w-full md:w-auto bg-green-600 text-white font-bold text-lg px-6 py-3 rounded-lg hover:bg-green-700 active:scale-95 transition-all duration-300 flex items-center justify-center gap-2 disabled:bg-gray-400 disabled:cursor-not-allowed">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17.7 7.7a2.5 2.5 0 1 1-5 0"/><path d="M12 22s-8-4.5-8-11.5a8 8 0 0 1 16 0c0 7-8 11.5-8 11.5z"/></svg>
                    <span>展示极限</span>
                </button>
            </div>

            <!-- Status & Formula Display -->
            <div id="status-container" class="h-12 flex items-center justify-center text-center">
                <div id="loader" class="loader hidden"></div>
                <p id="status-text" class="text-gray-600"></p>
                <div id="parsed-formula-container" class="hidden bg-blue-50 border border-blue-200 text-blue-800 px-4 py-2 rounded-lg text-lg">
                    <span class="font-semibold">解析公式: </span>
                    <span id="parsed-formula"></span>
                </div>
            </div>

            <!-- Visualization Area -->
            <div id="chart-container" class="w-full h-[400px] bg-gray-50 rounded-lg border border-gray-200 mt-4">
                 <svg id="chart-svg" width="100%" height="100%"></svg>
            </div>
        </div>
        <footer class="text-center mt-6 text-sm text-gray-500">
            <p>由 DeepSeek API 和 D3.js 驱动</p>
        </footer>
    </div>

    <script>
        // --- DOM Elements ---
        const formulaInput = document.getElementById('formula-input');
        const visualizeBtn = document.getElementById('visualize-btn');
        const showLimitBtn = document.getElementById('show-limit-btn');
        const loader = document.getElementById('loader');
        const statusText = document.getElementById('status-text');
        const parsedFormulaContainer = document.getElementById('parsed-formula-container');
        const parsedFormulaSpan = document.getElementById('parsed-formula');
        const chartContainer = document.getElementById('chart-container');
        const svg = d3.select("#chart-svg");

        // --- State ---
        let currentFormula = {
            formulaString: null,
            jsFunction: null,
            sequenceFunction: null
        };

        // --- API Configuration ---
        const DEEPSEEK_API_KEY = 'sk-de3f3fed16ae4f3a9b0ba53538d238f7';
        const API_URL = 'https://api.deepseek.com/chat/completions';

        // --- Event Listeners ---
        visualizeBtn.addEventListener('click', (e) => {
            e.preventDefault();
            handleVisualizeClick();
        });
        showLimitBtn.addEventListener('click', (e) => {
            e.preventDefault();
            handleShowLimitClick();
        });
        formulaInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                handleVisualizeClick();
            }
        });

        /**
         * Main handler for the "Generate Image" button.
         */
        async function handleVisualizeClick() {
            const userInput = formulaInput.value.trim();
            if (!userInput) {
                updateStatus('请输入一个数列公式！', 'error');
                return;
            }

            setLoadingState(true, 'visualize');
            
            try {
                const { formulaString, jsFunction } = await getFormulaFromAPI(userInput);
                
                if (!jsFunction) {
                    throw new Error("API 未能返回有效的函数。");
                }

                currentFormula.formulaString = formulaString;
                currentFormula.jsFunction = jsFunction;
                currentFormula.sequenceFunction = new Function('n', jsFunction);

                updateStatus('', 'success');
                // Set the LaTeX content and trigger MathJax rendering
                parsedFormulaSpan.innerHTML = `\\(a_n = ${formulaString}\\)`;
                parsedFormulaContainer.classList.remove('hidden');
                if (window.MathJax && window.MathJax.typesetPromise) {
                    await MathJax.typesetPromise([parsedFormulaContainer]);
                }

                const data = generateSequenceData(currentFormula.sequenceFunction, 50);
                drawSequence(data);
                
                showLimitBtn.disabled = false;

            } catch (error) {
                console.error('Error during visualization:', error);
                updateStatus(`处理失败: ${error.message}`, 'error');
                clearChart();
                showLimitBtn.disabled = true;
                currentFormula = {};
            } finally {
                setLoadingState(false, 'visualize');
            }
        }
        
        /**
         * Main handler for the "Show Limit" button.
         */
        async function handleShowLimitClick() {
            if (!currentFormula.formulaString) {
                updateStatus('请先生成一个图像。', 'error');
                return;
            }

            setLoadingState(true, 'limit');

            try {
                const limitResult = await getLimitFromAPI(currentFormula.formulaString);
                
                if (limitResult.exists) {
                    const limitValue = limitResult.value;
                    updateStatus(`极限存在: ${limitResult.reason}`, 'info');
                    const data = generateSequenceData(currentFormula.sequenceFunction, 50);
                    drawSequence(data, limitValue);
                } else {
                    updateStatus(`极限不存在: ${limitResult.reason}`, 'info');
                     const data = generateSequenceData(currentFormula.sequenceFunction, 50);
                    drawSequence(data, null); 
                }

            } catch(error) {
                console.error('Error during limit calculation:', error);
                updateStatus(`极限计算失败: ${error.message}`, 'error');
            } finally {
                setLoadingState(false, 'limit');
            }
        }


        /**
         * Sets the UI loading state for different buttons.
         * @param {boolean} isLoading - Whether the app is loading.
         * @param {'visualize'|'limit'} type - The type of action.
         */
        function setLoadingState(isLoading, type) {
            if (isLoading) {
                if (type === 'visualize') {
                    // Disable both buttons during visualization to prevent conflicts
                    visualizeBtn.disabled = true;
                    visualizeBtn.innerHTML = `<div class="loader btn-spinner"></div><span>解析中...</span>`;
                    showLimitBtn.disabled = true;
                    showLimitBtn.style.opacity = '0.5';
                    loader.classList.remove('hidden');
                    statusText.classList.add('hidden');
                    parsedFormulaContainer.classList.add('hidden');
                    clearChart();
                } else if (type === 'limit') {
                    // Disable both buttons during limit calculation
                    showLimitBtn.disabled = true;
                    showLimitBtn.innerHTML = `<div class="loader btn-spinner"></div><span>计算中...</span>`;
                    visualizeBtn.disabled = true;
                    visualizeBtn.style.opacity = '0.5';
                }
            } else {
                if (type === 'visualize') {
                    visualizeBtn.disabled = false;
                    visualizeBtn.style.opacity = '1';
                    visualizeBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 20a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.9a2 2 0 0 1-1.69-.9L8.6 3.3a2 2 0 0 0-1.7-.9H3a2 2 0 0 0-2 2v13a2 2 0 0 0 2 2Z"></path><path d="M2 10h20"></path><path d="m9 14 2 2 4-4"></path></svg><span>生成图像</span>`;
                    loader.classList.add('hidden');
                    // Re-enable limit button if formula is available
                    if (currentFormula.formulaString) {
                        showLimitBtn.disabled = false;
                        showLimitBtn.style.opacity = '1';
                    }
                } else if (type === 'limit') {
                    showLimitBtn.disabled = false;
                    showLimitBtn.style.opacity = '1';
                    showLimitBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17.7 7.7a2.5 2.5 0 1 1-5 0"/><path d="M12 22s-8-4.5-8-11.5a8 8 0 0 1 16 0c0 7-8 11.5-8 11.5z"/></svg><span>展示极限</span>`;
                    // Re-enable visualize button
                    visualizeBtn.disabled = false;
                    visualizeBtn.style.opacity = '1';
                }
            }
        }
        
        function updateStatus(message, type = 'info') {
            statusText.textContent = message;
            statusText.classList.remove('hidden', 'text-red-500', 'text-green-500', 'text-gray-600');
            if(type !== 'success') parsedFormulaContainer.classList.add('hidden');
            
            switch(type) {
                case 'error': statusText.classList.add('text-red-500'); break;
                case 'success': statusText.classList.add('hidden'); break;
                default: statusText.classList.add('text-gray-600');
            }
        }

        async function getFormulaFromAPI(rawFormula) {
            updateStatus('正在请求 AI 解析公式...', 'info');
            const systemPrompt = `You are an expert mathematician and JavaScript programmer. Your task is to parse a user's natural language description of a mathematical sequence, a_n. The user's input will be informal. You MUST respond with ONLY a valid JSON object. The JSON object must have two keys: "formulaString" and "jsFunction". "formulaString": A string containing a clean, human-readable LaTeX-style representation of the formula (e.g., "\\\\frac{3n+1}{2n}"). "jsFunction": A string containing ONLY the body of a JavaScript function that takes 'n' and returns the term value. Use 'Math' object for functions. Example user input "an=3n+1chushang 2n", your response: {"formulaString": "\\\\frac{3n + 1}{2n}", "jsFunction": "return (3 * n + 1) / (2 * n);"}. IMPORTANT: Do not include any text outside of the JSON object.`;

            const response = await fetch(API_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${DEEPSEEK_API_KEY}` },
                body: JSON.stringify({
                    model: "deepseek-chat", messages: [{ "role": "system", "content": systemPrompt }, { "role": "user", "content": rawFormula }],
                    stream: false, response_format: { "type": "json_object" }
                })
            });

            if (!response.ok) {
                const errorBody = await response.json();
                throw new Error(`API 请求失败: ${response.status} ${errorBody.error?.message || ''}`);
            }

            const result = await response.json();
            const content = result.choices[0]?.message?.content;
            if (!content) throw new Error("API 返回了无效的响应。");
            
            return JSON.parse(content);
        }

        async function getLimitFromAPI(formulaString) {
            updateStatus('正在请求 AI 计算极限...', 'info');
            const systemPrompt = `You are a calculus expert. Analyze the provided sequence formula a_n and determine its limit as n approaches infinity. You MUST respond with ONLY a valid JSON object with three keys: "exists" (boolean), "value" (number if exists, else null), and "reason" (a brief explanation in Chinese).
            RULES:
            1. For rational functions (polynomials divided by polynomials), STRICTLY compare the degrees of the numerator and denominator.
               - If degrees are equal, the limit is the ratio of the leading coefficients.
               - If denominator's degree is higher, the limit is 0.
               - If numerator's degree is higher, the limit does not exist (diverges).
            2. Do not perform incorrect algebraic simplifications.
            
            Example input "a_n = (n^2+n)/(3n^2)", your response: {"exists": true, "value": 0.33333, "reason": "分子分母最高次幂相同(均为2)，极限为系数比 1/3。"}.
            Example input "a_n = (-1)^n", your response: {"exists": false, "value": null, "reason": "数列在-1和1之间振荡，无极限。"}.
            
            IMPORTANT: Respond ONLY with the JSON object.`;

            const response = await fetch(API_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${DEEPSEEK_API_KEY}` },
                body: JSON.stringify({
                    model: "deepseek-chat", messages: [{ "role": "system", "content": systemPrompt }, { "role": "user", "content": `a_n = ${formulaString}` }],
                    stream: false, response_format: { "type": "json_object" }
                })
            });

             if (!response.ok) {
                const errorBody = await response.json();
                throw new Error(`API 请求失败: ${response.status} ${errorBody.error?.message || ''}`);
            }

            const result = await response.json();
            const content = result.choices[0]?.message?.content;
            if (!content) throw new Error("API 返回了无效的响应。");
            
            return JSON.parse(content);
        }

        function generateSequenceData(func, count) {
            const data = [];
            for (let i = 1; i <= count; i++) {
                try {
                    const value = func(i);
                    data.push({ n: i, value: Number.isFinite(value) ? value : null });
                } catch(e) {
                    data.push({ n: i, value: null });
                }
            }
            return data;
        }
        
        function clearChart() {
            svg.selectAll('*').remove();
        }

        /**
         * Draws the sequence chart using D3.js.
         * @param {Array<{n: number, value: number|null}>} data - The sequence data.
         * @param {number|null} [limit=undefined] - The limit of the sequence.
         */
        function drawSequence(data, limit = undefined) {
            clearChart();

            const validData = data.filter(d => d.value !== null);
            if (validData.length === 0) {
                 updateStatus('无法生成图像，因为所有计算值都无效。', 'error');
                 return;
            }

            const margin = { top: 20, right: 80, bottom: 40, left: 50 };
            const width = chartContainer.clientWidth - margin.left - margin.right;
            const height = chartContainer.clientHeight - margin.top - margin.bottom;

            const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

            const xScale = d3.scaleLinear().domain([1, data.length]).range([0, width]);
            
            const yExtent = d3.extent(validData, d => d.value);
            const yDomainValues = [...yExtent];
            if(limit !== undefined && limit !== null) {
                yDomainValues.push(limit);
            }
            const finalYExtent = d3.extent(yDomainValues);
            const yPadding = (finalYExtent[1] - finalYExtent[0]) * 0.1 || 1;
            const yScale = d3.scaleLinear()
                .domain([finalYExtent[0] - yPadding, finalYExtent[1] + yPadding])
                .range([height, 0]);

            g.append("g").attr("transform", `translate(0, ${height})`).call(d3.axisBottom(xScale).ticks(10))
                .append("text").attr("x", width / 2).attr("y", 35).attr("fill", "currentColor").attr("text-anchor", "middle").text("项 (n)");

            g.append("g").call(d3.axisLeft(yScale).ticks(5))
                .append("text").attr("x", -margin.left + 15).attr("y", -10).attr("fill", "currentColor").attr("text-anchor", "start").text("值 (aₙ)");
            
            g.append("g").call(d3.axisLeft(yScale).ticks(5).tickSize(-width)).attr("stroke-opacity", 0.1).select(".domain").remove();

            const line = d3.line().defined(d => d.value !== null).x(d => xScale(d.n)).y(d => yScale(d.value));

            g.append("path").datum(data).attr("fill", "none").attr("stroke", "#4f46e5").attr("stroke-width", 1.5);

            g.selectAll("circle").data(validData).enter().append("circle")
                .attr("cx", d => xScale(d.n)).attr("cy", d => yScale(d.value)).attr("r", 2.5).attr("fill", "#4f46e5");

            if (limit !== undefined && limit !== null) {
                g.append('line').attr('class', 'limit-line')
                    .attr('x1', 0).attr('x2', width)
                    .attr('y1', yScale(limit)).attr('y2', yScale(limit))
                    .attr('stroke', '#ef4444').attr('stroke-width', 2).attr('stroke-dasharray', '6 4');
                g.append('text').attr('class', 'limit-line')
                    .attr('x', width + 8).attr('y', yScale(limit)).attr('dy', '0.32em')
                    .text(`极限=${limit.toFixed(3)}`).attr('fill', '#ef4444').attr('font-size', '12px').attr('font-weight', 'bold');
            }
        }
        
        // Navigation function
        function navigateToFunctions() {
            window.location.href = '函数ai.html';
        }

        // Initial state
        showLimitBtn.disabled = true;
        updateStatus('请在上方输入框中描述一个数列公式。');

    </script>
</body>
</html>
