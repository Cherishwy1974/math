<!DOCTYPE html>

<html lang="zh-CN">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>微积分第二章：极限与连续 - 完整版</title>
<script src="../common-assets/js/d3-7.8.5.min.js"></script>
<!-- 使用统一的MathJax配置文件，避免配置冲突 -->
<script src="../common-assets/js/mathjax-config.js"></script>
<script async="" id="MathJax-script" src="../common-assets/js/mathjax-3.2.2-tex-svg.min.js" type="text/javascript">
</script>
<style>
        @import url('../common-assets/css/fonts.css');

        :root {
            --chalkboard-bg: #2c3e50;
            --chalk-text: #ecf0f1;
            --visualization-bg: #ffffff;
            --primary-color: #3498db;
            --accent-color: #e67e22;
            --success-color: #2ecc71;
            --danger-color: #e74c3c;
            --warning-color: #f39c12;
            --info-color: #9b59b6;
            --text-color: #34495e;
            --heading-font: 'Noto Serif SC', serif;
            --handwriting-font: 'Noto Serif SC', serif;
        }

        body {
            font-family: var(--heading-font);
            margin: 0;
            background-color: #f0f2f5;
        }

        .scrolly-container {
            display: flex;
            width: 100%;
            min-height: 100vh;
        }

        .lecture-notes {
            flex: 0 0 40%;
            max-width: 40%;
            word-wrap: break-word;
        }

        .step {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            padding: 40px;
            background-color: var(--chalkboard-bg);
            background-image: url('../common-assets/images/black-felt.png');
            border-bottom: 1px solid #444;
            color: var(--chalk-text);
            box-sizing: border-box;
            opacity: 0.3;
            transition: opacity 0.5s;
        }

        .step.is-active {
            opacity: 1;
        }

        .step:last-child {
            border-bottom: none;
        }

        .step h2 {
            font-family: var(--handwriting-font);
            font-size: 2.2rem;
            color: #f1c40f;
            border-bottom: 2px solid rgba(241, 196, 15, 0.5);
        }

        .step h3 {
            font-family: var(--handwriting-font);
            font-size: 1.5rem;
            color: var(--primary-color);
        }

        .step p, .step li {
            font-size: 1.1rem;
            line-height: 1.7;
        }

        .step ul {
            list-style-type: '→ ';
        }

        .visualization-panel {
            flex: 1;
            position: relative;
        }

        #sticky-vis-container {
            position: sticky;
            top: 0;
            width: 100%;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: var(--visualization-bg);
            transition: opacity 0.5s;
        }

        #sticky-vis-container.visualization-flex {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 30px;
            box-sizing: border-box;
        }

        #sticky-vis-container.visualization-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            padding: 30px;
            box-sizing: border-box;
            overflow-y: auto;
        }

        .visualization-flex {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 30px;
            box-sizing: border-box;
        }

        .visualization-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            padding: 30px;
            box-sizing: border-box;
            overflow-y: auto;
        }

        .step.fullscreen {
            padding: 0;
            border: none;
        }

        .step.fullscreen .fullscreen-vis-container {
            width: 100%;
            height: 100vh;
            background-color: var(--visualization-bg);
        }

        .step.fullscreen[data-theme="dark"] .fullscreen-vis-container {
            background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
        }

        .chalkboard {
            background-color: #2c3e50 !important;
            border: 10px solid #8B4513; /* 木质边框 */
            box-shadow: 0 10px 20px rgba(0,0,0,0.5), inset 0 0 15px rgba(0,0,0,0.7);
            color: var(--chalk-text, #f0f0f0);
            padding: 15px;
            box-sizing: border-box;
            word-wrap: break-word;
            word-break: break-word;
        }
        
        /* 自定义滚动条样式 */
        .chalkboard::-webkit-scrollbar {
            width: 8px;
        }
        
        .chalkboard::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }
        
        .chalkboard::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 4px;
        }
        
        .chalkboard::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.5);
        }

        .chalkboard h2 {
            font-family: var(--handwriting-font);
            font-size: 2.2rem;
            color: #f1c40f;
            border-bottom: 2px solid rgba(241, 196, 15, 0.5);
            padding-bottom: 2px;
            margin-bottom:3px;
        }

        .chalkboard h3 {
            font-family: var(--handwriting-font);
            font-size: 1.5rem;
            color: var(--primary-color);
            margin-top: 5px;
            margin-bottom: 5px;
        }

        .chalkboard p, .chalkboard li {
            font-size: 1.1rem;
            line-height: 1.4;
            margin-bottom: 8px;
            word-wrap: break-word;
            overflow-wrap: break-word;
            max-width: 100%;
        }

        .chalkboard ul {
            list-style-type: '▸ ';
            padding-left: 20px;
            margin-bottom: 8px;
        }

        .math-formula {
            font-size: 1.2rem;
            color: #1abc9c;
            background: rgba(26, 188, 156, 0.1);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
            margin: 15px 0;
            border: 2px solid rgba(26, 188, 156, 0.3);
            word-wrap: break-word;
            overflow-wrap: break-word;
            max-width: 100%;
        }

        .highlight {
            color: var(--warning-color);
            font-weight: bold;
            background: rgba(243, 156, 18, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
        }

        .example-box {
            background: rgba(52, 152, 219, 0.1);
            border-left: 4px solid var(--primary-color);
            padding: 15px;
            margin: 20px 0;
        }

        .example-box h4 {
            color: var(--primary-color);
            margin-top: 0;
            font-size: 1rem;
        }

        .step-box {
            background: rgba(46, 204, 113, 0.1);
            border: 1px solid rgba(46, 204, 113, 0.3);
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
        }

        .warning-box {
            background: rgba(231, 76, 60, 0.1);
            border: 2px solid rgba(231, 76, 60, 0.3);
            padding: 15px;
            margin: 20px 0;
            border-radius: 8px;
        }

        .visualization {
            flex: 1;
            padding: 30px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            overflow-y: auto;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
        }

        .vis-item {
            background: white;
            border-radius: 8px;
            padding: 15px;
            position: relative;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .vis-item:hover {
            transform: scale(1.02);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .vis-item svg {
            width: 100%;
            height: auto;
        }

        .vis-title {
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            gap: 0.1em;
            font-size: 1rem;
            color: var(--text-color);
            margin-bottom: 10px;
            height: auto;
            line-height: 1.2;
        }

        .approach-indicator {
            position: absolute;
            top: 5px;
            right: 5px;
            background: rgba(52, 152, 219, 0.9);
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.7rem;
            font-weight: bold;
        }

        .approach-left {
            background: rgba(231, 76, 60, 0.9);
        }

        .approach-right {
            background: rgba(46, 204, 113, 0.9);
        }

        .approach-both {
            background: rgba(155, 89, 182, 0.9);
        }

        .expanded-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .expanded-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .expanded-content {
            background: white;
            border-radius: 12px;
            padding: 30px;
            width: 80vw;
            height: 80vh;
            position: relative;
            transform: scale(0.8);
            transition: transform 0.3s ease;
            display: flex;
            flex-direction: column;
        }

        .expanded-overlay.active .expanded-content {
            transform: scale(1);
        }

        .expanded-title {
            font-size: 1.5rem;
            margin-bottom: 20px;
            text-align: center;
            color: var(--text-color);
            line-height: 1.8;
            min-height: 3rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .expanded-title mjx-container {
            font-size: 1.2em !important;
        }

        .simple-annotation {
            font-family: var(--heading-font);
        }

        .simple-annotation mjx-container {
            font-size: 1.1em !important;
        }

        .expanded-annotation {
            text-align: center;
            margin-bottom: 15px;
            font-style: italic;
            color: #6c757d;
        }

        .expanded-svg-container {
            flex: 1;
            overflow: auto;
            position: relative;
        }

        .expanded-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            background: #f8f9fa;
            border-radius: 10px;
            margin: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .control-group label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 500;
            color: #495057;
        }

        .control-group input[type="range"] {
            width: 120px;
        }

        .control-group button {
            padding: 8px 16px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }

        .control-group button:hover {
            background: #0056b3;
        }

        .annotation-text {
            background: rgba(52, 152, 219, 0.1);
            color: #2980b9;
            padding: 5px 12px;
            border-radius: 15px;
            font-size: 14px;
            display: inline-block;
        }

        .close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: var(--danger-color);
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            cursor: pointer;
            font-size: 18px;
        }

        .close-btn:hover {
            background: #c0392b;
        }



        .page-info {
            display: none;
        }

        .interactive-panel {
            position: absolute;
            bottom: 30px;
            right: 70px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
        }

        .draggable-panel {
            cursor: move;
            user-select: none;
        }

        .draggable-panel h3 {
            cursor: grab;
            margin: 0 0 15px 0;
            padding: 5px 0;
            border-bottom: 2px solid var(--primary-color);
            color: var(--primary-color);
            font-weight: bold;
        }

        .draggable-panel h3:hover {
            background: rgba(52, 152, 219, 0.1);
            border-radius: 5px;
            padding: 5px;
        }

        .draggable-panel.dragging {
            cursor: grabbing;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.2);
            transform: scale(1.02);
            transition: transform 0.1s ease;
        }

        .draggable-panel.dragging h3 {
            cursor: grabbing;
        }

        .button-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 15px 0;
            align-items: center;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 15px;
            margin: 10px 0;
        }

        .slider {
            flex: 1;
            -webkit-appearance: none;
            height: 8px;
            border-radius: 5px;
            background: linear-gradient(to right, var(--primary-color) 0%, var(--accent-color) 100%);
            outline: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            border: 3px solid var(--primary-color);
            cursor: pointer;
        }


        .formula-step {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin: 15px 0;
            font-size: 1.3rem;
        }

        .formula-arrow {
            color: var(--accent-color);
            font-size: 1.5rem;
        }

        @keyframes pulse {
            0%, 100% { 
                opacity: 0.8; 
                transform: scale(1); 
            }
            50% { 
                opacity: 1; 
                transform: scale(1.05); 
            }
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .animated-point, .fade-in, .pulse {
            will-change: transform, opacity;
            transform: translateZ(0);
            backface-visibility: hidden;
        }

        .animated-point {
            animation: pulse 2s ease-in-out infinite;
        }

        .fade-in {
            animation: fadeIn 0.8s ease-out;
        }

        .limit-arrow {
            stroke: var(--danger-color);
            stroke-width: 2;
            marker-end: url(#arrowhead);
            stroke-dasharray: 5, 5;
            animation: dash 2s linear infinite;
        }

        @keyframes dash {
            to { stroke-dashoffset: -10; }
        }

        .epsilon-band {
            fill: rgba(52, 152, 219, 0.2);
            stroke: rgba(52, 152, 219, 0.5);
            stroke-width: 1;
            stroke-dasharray: 3, 3;
        }

        .thinking-bubble {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 15px;
            position: relative;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

               /* 极限动画增强样式 */
               .limit-approach-container .approach-indicator {
            animation: pulse 2s infinite ease-in-out;
        }

        @keyframes pulse {
            0%, 100% { 
                opacity: 0.8; 
                transform: scale(1); 
            }
            50% { 
                opacity: 1; 
                transform: scale(1.05); 
            }
        }

        .left-approach-point, .right-approach-point {
            filter: drop-shadow(0 0 4px currentColor);
        }
        
        .chart-annotation {
            margin-top: 15px;
            padding: 12px 20px;
            background: rgba(52, 73, 94, 0.08);
            border-radius: 8px;
            font-size: 14px;
            line-height: 1.5;
            color: var(--text-color);
            border: none;
            font-family: 'Noto Serif SC', serif;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
        }
        
        .chart-annotation .conclusion {
            font-weight: 600;
            color: var(--primary-color);
        }
        
        .chart-annotation .analysis {
            margin-top: 4px;
            opacity: 0.8;
        }

    /* 封面样式 */
    .cover-full {
        display: flex;
        flex-direction: column;
        width: 100%;
        height: 100%;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        justify-content: center;
        align-items: center;
        padding: 60px;
        box-sizing: border-box;
    }

    .cover-content {
        max-width: 1000px;
        text-align: center;
        background: rgba(255, 255, 255, 0.95);
        padding: 60px;
        border-radius: 20px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    }

    .cover-header {
        margin-bottom: 50px;
    }

    .cover-title-main {
        font-size: 3.5rem;
        color: var(--primary-color);
        font-weight: bold;
        margin: 0 0 15px 0;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    }

    .cover-title-subtitle {
        font-size: 2.2rem;
        color: var(--accent-color);
        margin: 0;
        font-weight: 600;
    }

    .cover-version {
        font-size: 1.4rem;
        color: var(--success-color);
        margin-top: 20px;
        font-weight: 500;
    }

    .cover-center {
        margin: 50px 0;
    }

    .cover-icon {
        font-size: 5rem;
        margin-bottom: 40px;
        text-shadow: 2px 2px 8px rgba(0,0,0,0.2);
        animation: pulse 3s ease-in-out infinite;
    }

    .cover-objectives {
        margin-bottom: 40px;
    }

    .objectives-list {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 20px;
        margin-top: 20px;
    }

    .objective-item {
        display: flex;
        align-items: center;
        gap: 15px;
        padding: 15px;
        background: rgba(52, 152, 219, 0.1);
        border-radius: 10px;
        border-left: 4px solid var(--primary-color);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .objective-item:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 15px rgba(0,0,0,0.15);
    }

    .objective-icon {
        font-size: 1.5rem;
        flex-shrink: 0;
    }

    .knowledge-flow {
        display: flex;
        align-items: center;
        gap: 20px;
        margin-top: 40px;
        padding: 25px;
        background: rgba(155, 89, 182, 0.1);
        border-radius: 15px;
        border: 2px solid rgba(155, 89, 182, 0.3);
    }

    .flow-item {
        padding: 12px 25px;
        background: linear-gradient(135deg, var(--primary-color), var(--accent-color));
        color: white;
        border-radius: 25px;
        font-weight: 600;
        font-size: 0.95rem;
        text-align: center;
        min-width: 140px;
        box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        transition: transform 0.3s ease;
    }

    .current {
        background: linear-gradient(135deg, var(--success-color), #27ae60) !important;
        transform: scale(1.05);
    }

    .flow-arrow {
        font-size: 1.5rem;
        color: var(--accent-color);
        font-weight: bold;
    }

    .cover-footer {
        margin-top: 60px;
        border-top: 2px solid rgba(0,0,0,0.1);
        padding-top: 30px;
    }

    .nav-guide {
        display: flex;
        justify-content: center;
        gap: 20px;
        margin-bottom: 30px;
    }

    .nav-item {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
        padding: 15px 20px;
        background: rgba(52, 152, 219, 0.1);
        border-radius: 10px;
        transition: background 0.3s ease;
    }

    .nav-item:hover {
        background: rgba(52, 152, 219, 0.2);
    }

    .nav-icon {
        font-size: 1.5rem;
    }

    .tech-info {
        color: var(--info-color);
        font-size: 0.9rem;
        font-weight: 500;
        padding: 10px 20px;
        background: rgba(26, 188, 156, 0.1);
        border-radius: 20px;
        display: inline-block;
    }

    /* 首页导航按钮样式 */
    .home-nav-buttons {
        display: flex;
        justify-content: center;
        gap: 20px;
        margin-top: 40px;
        flex-wrap: wrap;
    }

    .nav-btn {
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 15px 20px;
        background: rgba(255, 255, 255, 0.1);
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 15px;
        text-decoration: none;
        color: white;
        transition: all 0.3s ease;
        backdrop-filter: blur(10px);
        min-width: 120px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    }

    .nav-btn:hover {
        background: rgba(255, 255, 255, 0.2);
        border-color: rgba(255, 255, 255, 0.5);
        transform: translateY(-5px);
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
    }

    .nav-btn .btn-icon {
        font-size: 1.2rem;
        margin-bottom: 8px;
        font-weight: bold;
        letter-spacing: 1px;
    }

    .nav-btn .btn-text {
        font-size: 1.1rem;
        font-weight: 500;
    }

    /* 不同按钮的特殊颜色 */
    .home-btn:hover {
        background: rgba(52, 152, 219, 0.3);
        border-color: rgba(52, 152, 219, 0.6);
    }

    .story-btn:hover {
        background: rgba(155, 89, 182, 0.3);
        border-color: rgba(155, 89, 182, 0.6);
    }

    .exercise-btn:hover {
        background: rgba(46, 204, 113, 0.3);
        border-color: rgba(46, 204, 113, 0.6);
    }

    .resource-btn:hover {
        background: rgba(230, 126, 34, 0.3);
        border-color: rgba(230, 126, 34, 0.6);
    }

    /* 响应式设计 */
    @media (max-width: 768px) {
        .home-nav-buttons {
            gap: 15px;
            margin-top: 30px;
        }
        
        .nav-btn {
            padding: 12px 16px;
            min-width: 100px;
        }
        
        .nav-btn .btn-icon {
            font-size: 1rem;
        }
        
        .nav-btn .btn-text {
            font-size: 1rem;
        }
    }

    /* 浮动菜单样式 */
    #floating-menu {
        position: fixed;
        bottom: 20px;
        right: 200px;
        z-index: 9999;
        font-family: var(--heading-font);
    }

    /* 章节目录菜单样式 */
    #chapter-menu {
        position: fixed;
        bottom: 20px;
        right: 20px;
        z-index: 9999;
        font-family: var(--heading-font);
    }

    .menu-toggle {
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: rgba(255, 255, 255, 0.8);
        padding: 6px 12px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px;
        font-weight: normal;
        transition: all 0.2s ease;
        backdrop-filter: blur(5px);
        min-width: 50px;
        text-align: center;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .menu-toggle:hover {
        background: rgba(0, 0, 0, 0.5);
        color: rgba(255, 255, 255, 1);
        border-color: rgba(255, 255, 255, 0.4);
    }

    .menu-toggle:active {
        transform: scale(0.95);
    }

    .menu-toggle .menu-icon {
        font-size: 10px;
        font-weight: normal;
        transition: transform 0.3s ease;
    }

    .menu-toggle.active .menu-icon {
        transform: rotate(45deg);
    }

    .menu-content {
        position: absolute;
        bottom: 50px;
        right: 0;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 15px;
        padding: 10px 0;
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.3);
        opacity: 0;
        visibility: hidden;
        transform: translateY(20px);
        transition: all 0.3s ease;
        min-width: 220px;
        max-height: 400px;
        overflow-y: auto;
    }

    .menu-content.active {
        opacity: 1;
        visibility: visible;
        transform: translateY(0);
    }

    /* 自定义滚动条样式 */
    .menu-content::-webkit-scrollbar {
        width: 6px;
    }

    .menu-content::-webkit-scrollbar-track {
        background: rgba(0, 0, 0, 0.1);
        border-radius: 3px;
    }

    .menu-content::-webkit-scrollbar-thumb {
        background: rgba(102, 126, 234, 0.5);
        border-radius: 3px;
    }

    .menu-content::-webkit-scrollbar-thumb:hover {
        background: rgba(102, 126, 234, 0.7);
    }

    .menu-item {
        display: flex;
        align-items: center;
        padding: 10px 15px;
        text-decoration: none;
        color: #333;
        transition: all 0.3s ease;
        border-radius: 10px;
        margin: 0 8px;
    }

    .menu-item:hover {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        transform: translateX(5px);
    }

    .menu-item .menu-icon {
        font-size: 12px;
        margin-right: 10px;
        width: 40px;
        text-align: center;
        font-weight: bold;
        letter-spacing: 0.5px;
    }

    .menu-item .menu-text {
        font-size: 14px;
        font-weight: 500;
    }

    /* 响应式设计 */
    @media (max-width: 768px) {
        #floating-menu {
            bottom: 15px;
            right: 150px;
        }
        
        .menu-content {
            min-width: 200px;
        }
        
        .menu-item {
            padding: 8px 12px;
        }
        
        .menu-item .menu-text {
            font-size: 13px;
        }
    }

    </style>
<style>
        .return-home-panel {
            position: fixed;
            top: 16px;
            left: 16px;
            display: flex;
            gap: 10px;
            z-index: 9999;
            flex-wrap: wrap;
        }
        .return-home-panel .return-link {
            padding: 8px 14px;
            border-radius: 999px;
            background: rgba(15, 23, 42, 0.8);
            color: #f8fafc;
            font-size: 14px;
            text-decoration: none;
            box-shadow: 0 6px 20px rgba(15, 23, 42, 0.25);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .return-home-panel .return-link:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 24px rgba(15, 23, 42, 0.35);
        }
        .return-home-panel .return-link.return-main {
            background: rgba(79, 70, 229, 0.85);
        }
        @media (max-width: 640px) {
            .return-home-panel {
                top: 12px;
                left: 12px;
                right: 12px;
                justify-content: center;
            }
            .return-home-panel .return-link {
                width: 100%;
                text-align: center;
            }
        }
    </style>
</head>
<body>
<div class="return-home-panel">
<a class="return-link return-sub" href="index.html">← 返回目录</a>
<a class="return-link return-main" href="../index.html">⌂ 返回主站</a>
</div>
<div class="scrolly-container">
<div class="lecture-notes">
<section class="step" data-animation="intro" id="step-intro">
<div class="chalkboard" style="flex: 1; text-align: center; ">
<h2 style="font-size: 4rem; border: none;">第二章</h2>
<p style="font-size: 2.5rem; color: white;">极限与连续</p>
<!-- 导航按钮组 -->
<div class="home-nav-buttons">
<a class="nav-btn home-btn" href="../index.html">
<span class="btn-icon">HOME</span>
<span class="btn-text">主页</span>
</a>
<a class="nav-btn story-btn" href="../故事书/index.html">
<span class="btn-icon">STORY</span>
<span class="btn-text">故事书</span>
</a>
<a class="nav-btn exercise-btn" href="../习题/index.html">
<span class="btn-icon">EXERCISE</span>
<span class="btn-text">习题</span>
</a>
<a class="nav-btn resource-btn" href="../网页资源/index.html">
<span class="btn-icon">RESOURCE</span>
<span class="btn-text">网页资源</span>
</a>
</div>
</div>
</section>
<section class="step" data-animation="toc" id="step-toc"><!-- 目录页 -->
<div class="chalkboard" style="flex: 1; text-align: center;   overflow-y: auto; align-items: flex-start; justify-content: flex-start;">
<div style="writing-mode: vertical-rl; text-orientation: mixed; font-size: 3rem; border: none; margin-bottom: 1.5rem; height: 8rem; display: flex; align-items: flex-start; justify-content: center;">
                目录
            </div>
<div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 1.5rem; margin: 0 auto; max-width: 1400px; text-align: left;">
<div style="background: rgba(255,255,255,0.1); padding: 0.8rem; border-radius: 10px; backdrop-filter: blur(10px);">
<h3 style="color: #e74c3c; font-size: 1.3rem; margin-bottom: 0.5rem; border-bottom: 2px solid #e74c3c; padding-bottom: 0.2rem;">1. 极限概念</h3>
<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; font-size: 1rem; line-height: 1.3;">
<div>• 极限的直观理解</div>
<div>• 数列极限</div>
<div>• 函数极限</div>
<div>• 左右极限</div>
<div></div>
<div></div>
</div>
</div>
<div style="background: rgba(255,255,255,0.1); padding: 0.8rem; border-radius: 10px; backdrop-filter: blur(10px);">
<h3 style="color: #e74c3c; font-size: 1.3rem; margin-bottom: 0.5rem; border-bottom: 2px solid #e74c3c; padding-bottom: 0.2rem;">2. 极限计算</h3>
<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; font-size: 1rem; line-height: 1.3;">
<div>• 四则运算法则</div>
<div>• 直接代入法</div>
<div>• 因式分解法</div>
<div>• 有理化方法</div>
<div>• 计算技巧</div>
<div></div>
</div>
</div>
<div style="background: rgba(255,255,255,0.1); padding: 0.8rem; border-radius: 10px; backdrop-filter: blur(10px);">
<h3 style="color: #e74c3c; font-size: 1.3rem; margin-bottom: 0.5rem; border-bottom: 2px solid #e74c3c; padding-bottom: 0.2rem;">3. 两个重要极限</h3>
<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; font-size: 1rem; line-height: 1.3;">
<div>• 第一重要极限</div>
<div>• 第二重要极限</div>
<div>• 重要极限应用</div>
<div>• 极限变形技巧</div>
<div></div>
<div></div>
</div>
</div>
<div style="background: rgba(255,255,255,0.1); padding: 0.8rem; border-radius: 10px; backdrop-filter: blur(10px);">
<h3 style="color: #e74c3c; font-size: 1.3rem; margin-bottom: 0.5rem; border-bottom: 2px solid #e74c3c; padding-bottom: 0.2rem;">4. 无穷小的比较</h3>
<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; font-size: 1rem; line-height: 1.3;">
<div>• 无穷小定义</div>
<div>• 无穷大定义</div>
<div>• 无穷小比较</div>
<div>• 等价无穷小</div>
<div>• 等价替换应用</div>
<div></div>
</div>
</div>
<div style="background: rgba(255,255,255,0.1); padding: 0.8rem; border-radius: 10px; backdrop-filter: blur(10px);">
<h3 style="color: #e74c3c; font-size: 1.3rem; margin-bottom: 0.5rem; border-bottom: 2px solid #e74c3c; padding-bottom: 0.2rem;">5. 连续性与间断点</h3>
<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; font-size: 1rem; line-height: 1.3;">
<div>• 连续的定义</div>
<div>• 间断点分类</div>
<div>• 初等函数连续性</div>
<div>• 连续性判定</div>
<div>• 连续性的应用</div>
<div></div>
</div>
</div>
<div style="background: rgba(255,255,255,0.1); padding: 0.8rem; border-radius: 10px; backdrop-filter: blur(10px);">
<h3 style="color: #e74c3c; font-size: 1.3rem; margin-bottom: 0.5rem; border-bottom: 2px solid #e74c3c; padding-bottom: 0.2rem;">6. 章节总结</h3>
<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; font-size: 1rem; line-height: 1.3;">
<div>• 核心概念回顾</div>
<div>• 重要公式总结</div>
<div>• 解题方法归纳</div>
<div>• 下章预告</div>
<div></div>
<div></div>
</div>
</div>
</div>
</div>
</section>
<section class="step" data-animation="why-limit" id="step-why-limit"><!-- 第1页：引言 - 为什么要学极限 -->
<div class="chalkboard">
<h2>为什么要学极限？</h2>
<h3>古代难题</h3>
<p>古希腊哲学家芝诺提出：<span class="highlight">阿基里斯追龟悖论</span></p>
<p>跑得快的阿基里斯永远追不上前面的乌龟？因为当他跑到乌龟原来的位置时，乌龟又向前爬了一段...</p>
<h3>现实问题</h3>
<ul>
<li><strong>瞬时速度</strong>：汽车速度表显示的是瞬间速度，怎么算？</li>
<li><strong>曲线切线</strong>：GPS导航的转弯提示需要计算道路切线</li>
<li><strong>经济决策</strong>：当产量增加一个单位时，成本增加多少？</li>
<li><strong>图像压缩</strong>：JPEG如何用有限数据逼近原始图像？</li>
</ul>
<div class="warning-box">
<p><strong>核心矛盾：</strong>我们想知道"瞬间"的变化率，但"瞬间"意味着时间为0，而0不能做分母！</p>
<p>极限就是解决这个矛盾的<span class="highlight">数学工具</span>。</p>
</div>
</div>
</section>
<section class="step" data-animation="intuitive-limit" id="step-intuitive-limit"><!-- 第2页：什么是极限 - 直观理解 -->
<div class="chalkboard">
<h2>什么是极限？</h2>
<h3>核心思想</h3>
<p>极限描述的是一个<span class="highlight">变化过程的趋势</span>，而不是最终结果。</p>
<div class="example-box">
<h4>生活例子1：往杯子里倒水</h4>
<p>假设杯子容量是1升，你每次倒入剩余空间的一半：</p>
<ul>
<li>第1次：倒入0.5升（杯中0.5升）</li>
<li>第2次：倒入0.25升（杯中0.75升）</li>
<li>第3次：倒入0.125升（杯中0.875升）</li>
</ul>
<p>永远倒不满，但<span class="highlight">无限接近1升</span>！</p>
</div>
<!-- 新增更贴近生活的例子 -->
<div class="example-box" style="background: rgba(155, 89, 182, 0.1);">
<h4>生活例子2：手机电量</h4>
<p>手机显示"1%电量"，但永远用不完？</p>
<p>实际上是 1.4% → 1.1% → 1.01% → ...</p>
<p><span class="highlight">无限接近0，但还没到0</span></p>
</div>
<div class="example-box" style="background: rgba(230, 126, 34, 0.1);">
<h4>生活例子3：和朋友约见面</h4>
<p>"马上到" → "5分钟" → "2分钟" → "楼下了"</p>
<p>时间间隔越来越小，<span class="highlight">趋向于见面那一刻</span></p>
</div>
<div class="warning-box">
<p><strong>记住：</strong></p>
<p>极限 = "越来越接近" 而不是 "到达"</p>
<p>就像追女朋友，过程比结果重要！😊</p>
</div>
<div class="math-formula">
                总量 = 0.5 + 0.25 + 0.125 + ... → 1
            </div>
<p><strong>关键理解：</strong>极限不是"到达"，而是"趋向"！</p>
</div>
</section>
<section class="step" data-animation="convergent-sequences" id="step-convergent-sequences"><!-- 第3页：数列极限 - 收敛数列 -->
<div class="chalkboard">
<h2>数列极限（收敛）</h2>
<h3>什么是数列？</h3>
<p>按一定规律排列的一串数：$a_1, a_2, a_3, ..., a_n, ...$</p>
<h3>收敛数列</h3>
<p>当项数 $n$ 无限增大时，$a_n$ 无限接近某个确定的数 $A$。</p>
<div class="math-formula">
                $\lim\limits_{n \to \infty} a_n = A$
            </div>
<div class="example-box">
<h4>典型收敛模式</h4>
<ul>
<li>指数衰减：越来越快地接近极限</li>
<li>交替收敛：正负交替但幅度递减</li>
<li>调和收敛：缓慢但稳定地接近</li>
<li>振荡收敛：波动中趋向极限</li>
</ul>
</div>
<p>观察右侧15种不同的收敛模式，体会收敛的多样性。</p>
</div>
</section>
<section class="step" data-animation="divergent-sequences" id="step-divergent-sequences"><!-- 第4页：数列极限 - 发散数列 -->
<div class="chalkboard">
<h2>数列极限（发散）</h2>
<h3>发散数列的特征</h3>
<p>数列的项不趋向于任何固定值。</p>
<div class="example-box">
<h4>发散的类型</h4>
<ul>
<li><strong>趋向无穷：</strong>$a_n = n$ → $+\infty$</li>
<li><strong>振荡发散：</strong>$a_n = (-1)^n \cdot n$</li>
<li><strong>周期振荡：</strong>$a_n = (-1)^n$</li>
<li><strong>混沌发散：</strong>无规律的变化</li>
</ul>
</div>
<div class="warning-box">
<p><strong>判断技巧：</strong></p>
<p>• 如果能找到极限值 → 收敛</p>
<p>• 如果无限增大/减小 → 发散</p>
<p>• 如果持续振荡 → 发散</p>
</div>
</div>
</section>
<section class="step" data-animation="sequence-calculation" id="step-sequence-calculation"><!-- 第5页：数列极限的计算 -->
<div class="chalkboard">
<h2>数列极限的计算方法</h2>
<h3>基本方法</h3>
<div class="example-box">
<h4>方法1：直接代入法</h4>
<p>$\lim\limits_{n \to \infty} \frac{1}{n^2} = \frac{1}{\infty} = 0$</p>
<p>（无穷大的倒数是0）</p>
</div>
<div class="example-box">
<h4>方法2：分子分母同除最高次</h4>
<p>求：$\lim\limits_{n \to \infty} \frac{2n^2 + 3n + 1}{n^2 + 5}$</p>
<div class="step-box">
<p>步骤1：分子分母同除以 $n^2$</p>
<p>$= \lim\limits_{n \to \infty} \frac{2 + \frac{3}{n} + \frac{1}{n^2}}{1 + \frac{5}{n^2}}$</p>
<p>步骤2：当 $n \to \infty$ 时，$\frac{1}{n} \to 0$</p>
<p>$= \frac{2 + 0 + 0}{1 + 0} = 2$</p>
</div>
</div>
<h3>记住规律</h3>
<ul>
<li>分子次数 &gt; 分母次数 → 极限为 ∞</li>
<li>分子次数 = 分母次数 → 极限为系数比</li>
<li>分子次数 &lt; 分母次数 → 极限为 0</li>
</ul>
</div>
</section>
<section class="step" data-animation="function-limits" id="step-function-limits"><!-- 第6页：函数极限 -->
<div class="chalkboard">
<h2>函数的极限</h2>
<h3>两种基本情况</h3>
<div class="example-box">
<h4>情况1：$x$ 趋向于某个数</h4>
<p>$\lim\limits_{x \to a} f(x) = L$</p>
<p>意义：当 $x$ 无限接近 $a$ 时，$f(x)$ 无限接近 $L$</p>
</div>
<div class="example-box">
<h4>情况2：$x$ 趋向于无穷</h4>
<p>$\lim\limits_{x \to \infty} f(x) = L$</p>
<p>意义：当 $x$ 无限增大时，$f(x)$ 无限接近 $L$</p>
</div>
<div class="math-formula">
                $\lim\limits_{x \to a} f(x) = L$ 的含义：<br/>
                对任意小的 $\varepsilon &gt; 0$，存在 $\delta &gt; 0$，<br/>
                当 $0 &lt; |x - a| &lt; \delta$ 时，$|f(x) - L| &lt; \varepsilon$
            </div>
<p><strong>关键：</strong>$x$ 可以从任意方向接近目标值！</p>
</div>
</section>
<section class="step" data-animation="one-sided-limits" id="step-one-sided-limits"><!-- 第7页：左右极限 -->
<div class="chalkboard">
<h2>左极限与右极限</h2>
<h3>为什么要分左右？</h3>
<p>有些函数在某点处从不同方向接近会得到<span class="highlight">不同的值</span>。</p>
<div class="example-box">
<h4>左极限</h4>
<p>$\lim\limits_{x \to a^-} f(x) = L_1$</p>
<p>从左侧（小于$a$的方向）接近</p>
</div>
<div class="example-box">
<h4>右极限</h4>
<p>$\lim\limits_{x \to a^+} f(x) = L_2$</p>
<p>从右侧（大于$a$的方向）接近</p>
</div>
<div class="warning-box">
<p><strong>极限存在的条件：</strong></p>
<p>$\lim\limits_{x \to a} f(x)$ 存在 ⟺ $\lim\limits_{x \to a^-} f(x) = \lim\limits_{x \to a^+} f(x)$</p>
<p>左极限 = 右极限 = 共同值</p>
</div>
<p><strong>记忆口诀：</strong>左右相等极限在，左右不等无极限。</p>
</div>
</section>
<section class="step" data-animation="one-sided-detailed" id="step-one-sided-detailed"><!-- 第7.1页：左右极限详细演示 -->
<div class="chalkboard">
<h2>左右极限详细演示</h2>
<p>单侧极限的各种情况：</p>
<ul>
<li>相等（极限存在）</li>
<li>不相等（跳跃）</li>
<li>一侧不存在</li>
<li>振荡间断</li>
<li>可去间断</li>
</ul>
</div>
</section>
<section class="step" data-animation="limit-operations" id="step-limit-operations"><!-- 第8页：极限的四则运算 -->
<div class="chalkboard">
<h2>极限的四则运算法则</h2>
<h3>基本法则</h3>
<p>若 $\lim f(x) = A$，$\lim g(x) = B$，则：</p>
<div class="math-formula">
<p>加法：$\lim [f(x) + g(x)] = A + B$</p>
<p>减法：$\lim [f(x) - g(x)] = A - B$</p>
<p>乘法：$\lim [f(x) \cdot g(x)] = A \cdot B$</p>
<p>除法：$\lim \frac{f(x)}{g(x)} = \frac{A}{B}$ （$B \neq 0$）</p>
</div>
<div class="example-box">
<h4>推论</h4>
<ul>
<li>常数倍：$\lim [c \cdot f(x)] = c \cdot A$</li>
<li>幂运算：$\lim [f(x)]^n = A^n$</li>
<li>根运算：$\lim \sqrt[n]{f(x)} = \sqrt[n]{A}$（$A &gt; 0$）</li>
</ul>
</div>
<p><strong>注意：</strong>只有当各部分极限都存在时，法则才能用！</p>
</div>
</section>
<section class="step" data-animation="limit-methods-detailed" id="step-limit-methods-detailed"><!-- 第8.1页：极限运算方法 -->
<div class="chalkboard">
<h2>极限运算方法</h2>
<p><strong>直接代入法</strong>：连续点处直接代入</p>
<p><strong>因式分解法</strong>：约去零因子</p>
<p><strong>根式有理化</strong>：分子分母有理化</p>
<p><strong>无穷大比较法</strong>：比较最高次项</p>
<p><strong>等价无穷小替换</strong>：乘除关系中替换</p>
<p>展示12种常用的极限计算技巧</p>
</div>
</section>
<section class="step" data-animation="limit-methods" id="step-limit-methods"><!-- 第9页：极限计算技巧 -->
<div class="chalkboard">
<h2>极限计算技巧</h2>
<h3>0/0型未定式</h3>
<p>直接代入得到0/0时，需要化简！</p>
<div class="example-box">
<h4>方法1：因式分解</h4>
<p>$\lim\limits_{x \to 1} \frac{x^2 - 1}{x - 1} = \lim\limits_{x \to 1} \frac{(x+1)(x-1)}{x-1} = 2$</p>
</div>
<div class="example-box">
<h4>方法2：有理化</h4>
<p>$\lim\limits_{x \to 0} \frac{\sqrt{x+1} - 1}{x}$ </p>
<p>分子分母同乘 $\sqrt{x+1} + 1$ 后得 $\frac{1}{2}$</p>
</div>
<h3>∞/∞型未定式</h3>
<div class="example-box">
<h4>方法：除以最高次</h4>
<p>$\lim\limits_{x \to \infty} \frac{3x^2 + 2x}{x^2 - 5} = \lim\limits_{x \to \infty} \frac{3 + \frac{2}{x}}{1 - \frac{5}{x^2}} = 3$</p>
</div>
<p><strong>记住：</strong>遇到0/0要化简，遇到∞/∞看最高次！</p>
</div>
</section>
<section class="step" data-animation="important-limit-1" id="step-important-limit-1"><!-- 第10页：第一重要极限 -->
<div class="chalkboard">
<h2>第一重要极限</h2>
<div class="math-formula">
                $\lim\limits_{x \to 0} \frac{\sin x}{x} = 1$
            </div>
<h3>几何理解</h3>
<p>在单位圆中，当角度很小时：</p>
<p>弧长 ≈ 弦长 ≈ 正切线长</p>
<p>即：$x ≈ \sin x ≈ \tan x$ （$x$很小时）</p>
<h3>推广形式</h3>
<p>若 $f(x) \to 0$，则：</p>
<div class="math-formula">
                $\lim\limits_{f(x) \to 0} \frac{\sin f(x)}{f(x)} = 1$
            </div>
<div class="example-box">
<h4>应用例子</h4>
<p>$\lim\limits_{x \to 0} \frac{\sin 3x}{x} = \lim\limits_{x \to 0} \frac{\sin 3x}{3x} \cdot 3 = 1 \cdot 3 = 3$</p>
</div>
<p><strong>技巧：</strong>凑出标准形式，然后应用重要极限。</p>
</div>
</section>
<section class="step" data-animation="important-limit-2" id="step-important-limit-2"><!-- 第11页：第二重要极限 -->
<div class="chalkboard">
<h2>第二重要极限</h2>
<div class="math-formula">
                $\lim\limits_{x \to \infty} \left(1 + \frac{1}{x}\right)^x = e \approx 2.718$
            </div>
<h3>自然常数 $e$ 的意义</h3>
<p>这是<span class="highlight">自然常数e</span>的定义，在复利、人口增长、放射性衰变等问题中广泛应用。</p>
<h3>推广形式</h3>
<p>若 $f(x) \to \infty$，则：</p>
<div class="math-formula">
                $\lim\limits_{f(x) \to \infty} \left(1 + \frac{1}{f(x)}\right)^{f(x)} = e$
            </div>
<div class="example-box">
<h4>变形应用</h4>
<p>$\lim\limits_{x \to \infty} \left(1 + \frac{2}{x}\right)^x = \lim\limits_{x \to \infty} \left[\left(1 + \frac{1}{x/2}\right)^{x/2}\right]^2 = e^2$</p>
</div>
<p><strong>意义：</strong>描述了连续复利的极限情况。</p>
</div>
</section>
<section class="step" data-animation="important-limits-detailed" id="step-important-limits-detailed"><!-- 第11.1页：两个重要极限 -->
<div class="chalkboard">
<h2>两个重要极限</h2>
<p><strong>重要极限 I：</strong> $\lim\limits_{x \to 0} \frac{\sin x}{x} = 1$</p>
<p><strong>重要极限 II：</strong> $\lim\limits_{x \to \infty} \left(1+\frac{1}{x}\right)^x = e$</p>
<p>展示各种变形和应用</p>
</div>
</section>
<section class="step" data-animation="infinitesimal-infinity" id="step-infinitesimal-infinity"><!-- 第12页：无穷小与无穷大 -->
<div class="chalkboard">
<h2>无穷小与无穷大</h2>
<h3>无穷小量</h3>
<p>极限为0的变量叫<span class="highlight">无穷小</span>。</p>
<div class="example-box">
<h4>性质</h4>
<ul>
<li>有限个无穷小的和仍是无穷小</li>
<li>有限个无穷小的积仍是无穷小</li>
<li>有界函数与无穷小的积是无穷小</li>
</ul>
</div>
<h3>无穷大量</h3>
<p>极限为无穷的变量叫<span class="highlight">无穷大</span>。</p>
<div class="warning-box">
<p><strong>重要关系：</strong></p>
<p>在同一过程中，无穷大与无穷小（≠0）互为倒数：</p>
<p>若 $\lim f(x) = 0$（$f(x) \neq 0$），则 $\lim \frac{1}{f(x)} = \infty$</p>
</div>
<p><strong>注意：</strong>无穷小是变量，不是很小的数！</p>
</div>
</section>
<section class="step" data-animation="infinitesimal-comparison" id="step-infinitesimal-comparison"><!-- 第13页：无穷小的比较 -->
<div class="chalkboard">
<h2>无穷小的比较</h2>
<!-- 新增：速度对比表 -->
<div class="example-box">
<h4>趋向0的速度比赛（x→0时）</h4>
<table style="width: 100%; text-align: center;">
<tr style="background: rgba(255,255,255,0.1);">
<th>函数</th>
<th>x=0.1</th>
<th>x=0.01</th>
<th>x=0.001</th>
<th>速度</th>
</tr>
<tr>
<td>x</td>
<td>0.1</td>
<td>0.01</td>
<td>0.001</td>
<td>🐢 慢</td>
</tr>
<tr>
<td>x²</td>
<td>0.01</td>
<td>0.0001</td>
<td>0.000001</td>
<td>🐰 快</td>
</tr>
<tr>
<td>x³</td>
<td>0.001</td>
<td>0.000001</td>
<td>0.000000001</td>
<td>🚀 超快</td>
</tr>
</table>
<p style="margin-top: 10px;">
<span class="highlight">结论：次数越高，趋向0越快！</span>
</p>
</div>
<h3>阶的概念</h3>
<p>设 $\alpha$、$\beta$ 都是无穷小，且 $\alpha \neq 0$：</p>
<div class="math-formula">
<p>若 $\lim \frac{\beta}{\alpha} = 0$ → $\beta$ 是 $\alpha$ 的高阶无穷小</p>
<p>若 $\lim \frac{\beta}{\alpha} = \infty$ → $\beta$ 是 $\alpha$ 的低阶无穷小</p>
<p>若 $\lim \frac{\beta}{\alpha} = k \neq 0$ → $\beta$ 与 $\alpha$ 同阶</p>
<p>若 $\lim \frac{\beta}{\alpha} = 1$ → $\beta$ 与 $\alpha$ 等价，记作 $\alpha \sim \beta$</p>
</div>
<h3>意义</h3>
<p>比较不同无穷小趋于0的"速度"：</p>
<ul>
<li>$x^2$ 比 $x$ 更快趋于0（高阶）</li>
<li>$\sin x$ 与 $x$ 以相同速度趋于0（等价）</li>
</ul>
</div>
</section>
<section class="step" data-animation="equivalent-infinitesimal" id="step-equivalent-infinitesimal"><!-- 第14页：等价无穷小 -->
<div class="chalkboard">
<h2>常用等价无穷小</h2>
<p>当 $x \to 0$ 时：</p>
<div class="math-formula">
<p>$\sin x \sim x$，$\tan x \sim x$</p>
<p>$\arcsin x \sim x$，$\arctan x \sim x$</p>
<p>$1 - \cos x \sim \frac{x^2}{2}$</p>
<p>$e^x - 1 \sim x$，$\ln(1+x) \sim x$</p>
<p>$(1+x)^a - 1 \sim ax$</p>
</div>
<div class="warning-box">
<p><strong>替换规则：</strong></p>
<p>✓ 乘除关系中可以替换</p>
<p>✗ 加减关系中不能直接替换</p>
</div>
<div class="example-box">
<h4>应用例子</h4>
<p>$\lim\limits_{x \to 0} \frac{\sin x \cdot \tan x}{x^2} = \lim\limits_{x \to 0} \frac{x \cdot x}{x^2} = 1$</p>
</div>
</div>
</section>
<section class="step" data-animation="equivalent-infinitesimal-app" id="step-equivalent-infinitesimal-app"><!-- 第15页：等价无穷小应用 -->
<div class="chalkboard">
<h2>等价无穷小应用技巧</h2>
<h3>正确使用方法</h3>
<div class="example-box">
<h4>✓ 正确：乘除中替换</h4>
<p>$\lim\limits_{x \to 0} \frac{\sin 3x \cdot \tan 2x}{x^2} = \lim\limits_{x \to 0} \frac{3x \cdot 2x}{x^2} = 6$</p>
</div>
<div class="warning-box">
<h4>✗ 错误：加减中直接替换</h4>
<p>$\lim\limits_{x \to 0} \frac{\sin x - \tan x}{x^3}$ 不能替换为 $\frac{x - x}{x^3} = 0$</p>
<p>正确做法：先化简再替换</p>
</div>
<h3>处理加减的技巧</h3>
<ul>
<li>先通分或因式分解</li>
<li>转化为乘除形式</li>
<li>使用泰勒展开（高级方法）</li>
</ul>
<p><strong>记住：</strong>等价无穷小替换能大大简化计算！</p>
</div>
</section>
<section class="step" data-animation="continuous-functions" id="step-continuous-functions"><!-- 第16页：函数的连续性 -->
<div class="chalkboard">
<h2>函数的连续性</h2>
<h3>连续的直观理解</h3>
<p>函数图像<span class="highlight">不断开</span>，可以一笔画出来。</p>
<h3>连续的三个条件</h3>
<div class="step-box">
<p><strong>条件1：</strong>$f(x_0)$ 有定义（点存在）</p>
<p><strong>条件2：</strong>$\lim\limits_{x \to x_0} f(x)$ 存在（极限存在）</p>
<p><strong>条件3：</strong>$\lim\limits_{x \to x_0} f(x) = f(x_0)$（极限等于函数值）</p>
</div>
<div class="math-formula">
                函数在 $x_0$ 处连续 ⟺ $\lim\limits_{x \to x_0} f(x) = f(x_0)$
            </div>
<h3>单侧连续</h3>
<ul>
<li>左连续：$\lim\limits_{x \to x_0^-} f(x) = f(x_0)$</li>
<li>右连续：$\lim\limits_{x \to x_0^+} f(x) = f(x_0)$</li>
</ul>
<p><strong>意义：</strong>连续函数便于研究，许多定理只对连续函数成立。</p>
</div>
</section>
<section class="step" data-animation="discontinuities" id="step-discontinuities"><!-- 第17页：间断点分类 -->
<div class="chalkboard">
<h2>间断点的分类</h2>
<h3>第一类间断点（左右极限都存在）</h3>
<div class="example-box">
<h4>1. 可去间断点</h4>
<p>左极限 = 右极限 ≠ 函数值（或无定义）</p>
<p>例：$f(x) = \frac{\sin x}{x}$ 在 $x=0$ 处</p>
<p><span class="highlight">可以通过补充定义"去掉"间断</span></p>
</div>
<div class="example-box">
<h4>2. 跳跃间断点</h4>
<p>左极限 ≠ 右极限</p>
<p>例：符号函数 $\text{sgn}(x)$ 在 $x=0$ 处</p>
<p><span class="highlight">无法通过补充定义消除</span></p>
</div>
<h3>第二类间断点（至少一侧极限不存在）</h3>
<div class="example-box">
<h4>无穷间断点</h4>
<p>例：$f(x) = \frac{1}{x}$ 在 $x=0$ 处</p>
</div>
<div class="example-box">
<h4>振荡间断点</h4>
<p>例：$f(x) = \sin\frac{1}{x}$ 在 $x=0$ 处</p>
</div>
</div>
</section>
<section class="step" data-animation="elementary-functions" id="step-elementary-functions"><!-- 第18页：初等函数的连续性 -->
<div class="chalkboard">
<h2>初等函数的连续性</h2>
<h3>基本初等函数</h3>
<p>在其定义域内都是连续的：</p>
<div class="math-formula">
<p>• 常数函数：$f(x) = c$</p>
<p>• 幂函数：$f(x) = x^n$</p>
<p>• 指数函数：$f(x) = a^x$ ($a &gt; 0, a \neq 1$)</p>
<p>• 对数函数：$f(x) = \log_a x$ ($a &gt; 0, a \neq 1$)</p>
<p>• 三角函数：$\sin x, \cos x, \tan x$ 等</p>
<p>• 反三角函数：$\arcsin x, \arccos x$ 等</p>
</div>
<h3>复合运算的连续性</h3>
<p>连续函数经过以下运算仍连续：</p>
<ul>
<li>四则运算（除法要求分母不为0）</li>
<li>复合运算</li>
<li>反函数（单调连续函数）</li>
</ul>
<p><strong>结论：</strong>初等函数在其定义域内处处连续！</p>
</div>
</section>
<section class="step" data-animation="continuity-determination" id="step-continuity-determination"><!-- 第19页：连续性判定与应用 -->
<div class="chalkboard">
<h2>连续性的判定与应用</h2>
<h3>判定步骤</h3>
<div class="step-box">
<p>1. 检查函数是否有定义</p>
<p>2. 计算左极限 $\lim\limits_{x \to x_0^-} f(x)$</p>
<p>3. 计算右极限 $\lim\limits_{x \to x_0^+} f(x)$</p>
<p>4. 比较：左极限 = 右极限 = 函数值？</p>
</div>
<h3>连续函数的性质</h3>
<div class="example-box">
<h4>零点定理</h4>
<p>若 $f(x)$ 在 $[a,b]$ 连续，$f(a) \cdot f(b) &lt; 0$</p>
<p>则存在 $c \in (a,b)$ 使 $f(c) = 0$</p>
</div>
<div class="example-box">
<h4>最值定理</h4>
<p>连续函数在闭区间上必有最大值和最小值</p>
</div>
<div class="example-box">
<h4>介值定理</h4>
<p>连续函数取遍最值之间的所有值</p>
</div>
</div>
</section>
<section class="step" data-animation="applications" id="step-applications"><!-- 第20页：极限在实际中的应用 -->
<div class="chalkboard">
<h2>极限的实际应用</h2>
<h3>1. 瞬时速度</h3>
<div class="example-box">
<h4>问题：汽车t秒时的瞬时速度</h4>
<p>位置函数：$s(t) = 5t^2$（米）</p>
<p>瞬时速度 = $\lim\limits_{h \to 0} \frac{s(t+h) - s(t)}{h} = 10t$ m/s</p>
</div>
<h3>2. 边际成本</h3>
<div class="example-box">
<h4>成本函数：$C(x) = 100 + 2x + 0.01x^2$</h4>
<p>边际成本 = $\lim\limits_{h \to 0} \frac{C(x+h) - C(x)}{h} = 2 + 0.02x$</p>
</div>
<h3>3. 图像压缩（JPEG）</h3>
<div class="example-box">
<h4>渐进式压缩</h4>
<p>图像序列 $\{P_n\}$ 逐步逼近原图 $P_{原始}$</p>
<p>误差序列：$\{d_n\} \to 0$ (当 $n \to \infty$)</p>
</div>
<p><strong>本质：</strong>极限让我们能计算<span class="highlight">瞬间的变化率</span>！</p>
</div>
</section>
<section class="step" data-animation="summary" id="step-summary"><!-- 第21页：章节总结 -->
<div class="chalkboard">
<h2>章节总结</h2>
<h3>核心概念网络</h3>
<div class="step-box">
<p><strong>极限</strong> → 描述变化趋势</p>
<p>├─ <strong>数列极限</strong> → $n \to \infty$</p>
<p>├─ <strong>函数极限</strong> → $x \to a$ 或 $x \to \infty$</p>
<p>│   ├─ 左极限、右极限</p>
<p>│   └─ 极限存在条件</p>
<p>├─ <strong>重要极限</strong> → $\frac{\sin x}{x}$、$(1+\frac{1}{x})^x$</p>
<p>├─ <strong>无穷小</strong> → 极限为0</p>
<p>│   └─ 等价无穷小替换</p>
<p>└─ <strong>连续性</strong> → 极限=函数值</p>
<p>    └─ 间断点分类</p>
</div>
<h3>学习要点</h3>
<ul>
<li>极限是<span class="highlight">趋势</span>，不是结果</li>
<li>计算极限要先判断<span class="highlight">类型</span></li>
<li>0/0型要<span class="highlight">化简</span></li>
<li>∞/∞型看<span class="highlight">最高次</span></li>
<li>等价无穷小可<span class="highlight">替换</span></li>
</ul>
<div class="warning-box">
<p><strong>下一步：</strong>极限是导数的基础，导数是微分的核心！</p>
</div>
</div>
</section>
</div>
<div class="visualization-panel">
<div class="visualization-flex" id="sticky-vis-container"></div>
</div>
</div>
<script>
    // ============ 全局变量和初始化 ============
    let currentAnimations = [];
    let globalAnimationSpeed = 1.0;

    // MathJax重新渲染
    const renderMathJax = async (container) => {
        if (window.MathJax && window.MathJax.typesetPromise) {
            try {
                await window.MathJax.typesetPromise([container]);
            } catch (error) {
                console.warn('MathJax rendering failed:', error);
            }
        }
    };

    // 幻灯片控制
    function cleanupAnimations() {
        currentAnimations.forEach(cleanup => {
            if (typeof cleanup === 'function') {
                cleanup();
            }
        });
        currentAnimations = [];
    }

    function getContainer(containerId, mode = 'flex') {
        const element = document.getElementById(containerId);
        if (!element) {
            console.error(`Container ${containerId} not found`);
            return null;
        }

        element.innerHTML = '';
        element.classList.remove('visualization-grid', 'visualization-flex');
        if (mode === 'grid') {
            element.classList.add('visualization-grid');
        } else {
            element.classList.add('visualization-flex');
        }
        return element;
    }

    // ============ D3.js 辅助函数 ============
    function setupD3(containerId, margins = {top: 40, right: 40, bottom: 60, left: 60}) {
        const containerElement = document.getElementById(containerId);
        if (!containerElement) {
            console.error(`Container ${containerId} not found`);
            return null;
        }

        containerElement.innerHTML = '';
        containerElement.classList.remove('visualization-grid');
        containerElement.classList.add('visualization-flex');

        const container = d3.select(containerElement);
        const bounds = containerElement.getBoundingClientRect();
        
        const svg = container.append('svg')
            .attr('width', bounds.width)
            .attr('height', bounds.height);
            
        const width = bounds.width - margins.left - margins.right;
        const height = bounds.height - margins.top - margins.bottom;
        
        const g = svg.append('g')
            .attr('transform', `translate(${margins.left}, ${margins.top})`);
        
        // 添加箭头标记
        svg.append('defs').append('marker')
            .attr('id', 'arrowhead')
            .attr('viewBox', '0 -5 10 10')
            .attr('refX', 8)
            .attr('refY', 0)
            .attr('markerWidth', 8)
            .attr('markerHeight', 8)
            .attr('orient', 'auto')
            .append('path')
            .attr('d', 'M0,-5L10,0L0,5')
            .attr('fill', 'var(--danger-color)');
            
        return { container, svg, g, width, height };
    }

    // 通用可视化设置函数
    const setup = (container, index, title, approachDirection = 'both', approachValue = 'a') => {
        if (container && container.classList) {
            container.classList.remove('visualization-flex');
            container.classList.add('visualization-grid');
        }

        function parseVisTitle(title) {
            let formula = '', chinese = '';
            let t = title.trim();
            let brMatch = t.match(/^(.*?)(?:<br\s*\/?>)(.*)$/i);
            if (brMatch) {
                let part1 = brMatch[1].trim();
                let part2 = brMatch[2].trim();
                if (/^\$|\\|[a-zA-Z0-9_{}^]/.test(part2)) {
                    if (/[\u4e00-\u9fa5]/.test(part1)) {
                        chinese = part1;
                        formula = part2;
                    } else {
                        formula = part1;
                        chinese = part2;
                    }
                } else {
                    formula = part1;
                    chinese = part2;
                }
            } else {
                let colonMatch = t.match(/^(.+?)[:：]\s*(.+)$/);
                if (colonMatch) {
                    formula = colonMatch[2].trim();
                    chinese = colonMatch[1].trim();
                } else {
                    if (/[\u4e00-\u9fa5]/.test(t)) {
                        chinese = t;
                        formula = '';
                    } else {
                        formula = t;
                        chinese = '';
                    }
                }
            }
            formula = formula.trim();
            chinese = chinese.trim();
            if (formula && !/^\$.*\$$/.test(formula)) {
                formula = '$' + formula + '$';
            }
            return { formula, chinese };
        }

        function fracReplace(str) {
            return str
                .replace(/\\frac\s*{([^}]*)}\s*{([^}]*)}/g, '\\dfrac{$1}{$2}')
                .replace(/([^a-zA-Z0-9_\\])([0-9]+)\/([a-zA-Z0-9]+)/g, '$1\\dfrac{$2}{$3}')
                .replace(/([^a-zA-Z0-9_\\])([a-zA-Z0-9^{}\\]+)\/([a-zA-Z0-9^{}\\]+)/g, function(m, pre, num, den) {
                    if (num.startsWith('\\dfrac') || den.startsWith('\\dfrac')) return m;
                    return pre + '\\dfrac{' + num + '}{' + den + '}';
                });
        }

        const div = document.createElement('div');
        div.className = 'vis-item';

        // 处理趋向值显示
        const indicator = document.createElement('div');
        indicator.className = `approach-indicator approach-${approachDirection}`;
        let displayValue = approachValue;
        if (approachValue === 'a') {
            displayValue = '0'; // 默认显示0而不是a
        } else if (approachValue === Infinity || approachValue === '∞') {
            displayValue = '∞';
        } else if (typeof approachValue === 'number') {
            if (approachValue === Math.PI/2) {
                displayValue = 'π/2';
            } else {
                displayValue = Number.isInteger(approachValue) ? approachValue : approachValue.toFixed(1);
            }
        }
        
        const indicatorText = {
            'left': `x→${displayValue}⁻`,
            'right': `x→${displayValue}⁺`,
            'both': `x→${displayValue}`,
            'infinity': 'n→∞'
        };
        indicator.textContent = indicatorText[approachDirection] || `x→${displayValue}`;
        div.appendChild(indicator);

        const titleDiv = document.createElement('div');
        titleDiv.className = 'vis-title';

        const { formula, chinese } = parseVisTitle(title);

        let formulaHtml = formula ? fracReplace(formula) : '';
        if (formulaHtml) {
            const formulaSpan = document.createElement('span');
            formulaSpan.className = 'vis-formula';
            formulaSpan.innerHTML = formulaHtml;
            titleDiv.appendChild(formulaSpan);
        }
        if (chinese) {
            const chineseSpan = document.createElement('span');
            chineseSpan.className = 'vis-chinese';
            chineseSpan.textContent = chinese;
            titleDiv.appendChild(chineseSpan);
        }

        div.appendChild(titleDiv);

        const svg = d3.select(div).append('svg')
            .attr('width', 260)
            .attr('height', 200)
            .attr('viewBox', '0 0 260 200')
            .attr('preserveAspectRatio', 'xMidYMid meet');
        
        container.appendChild(div);

        // 添加点击展开功能
        div.addEventListener('click', () => expandVisualization(div, title, approachDirection, displayValue));

        const width = 240;
        const height = 180;
        const margin = {top: 20, right: 20, bottom: 30, left: 30};
        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;

        const g = svg.append('g')
            .attr('transform', `translate(${margin.left},${margin.top})`);

        return { svg, g, width: innerWidth, height: innerHeight, div };
    };

    // 格式化数值为分数或小数
    function formatLimitValue(value) {
        if (typeof value !== 'number') {
            return value;
        }

        if (Math.abs(value - Math.sqrt(2)) < 0.001) {
            return '√2 ≈ 1.414';
        } else if (Math.abs(value - 1.618) < 0.001) {
            return '(1+√5)/2 ≈ 1.618';  // 黄金比例
        } else if (Math.abs(value - 2/3) < 0.001) {
            return '2/3';  // 2/3 ≈ 0.6666666666666666
        } else if (Math.abs(value - 1/3) < 0.001) {
            return '1/3';  // 1/3 ≈ 0.3333333333333333
        } else if (Math.abs(value - 1/2) < 0.001) {
            return '1/2';  // 1/2 = 0.5
        } else if (Math.abs(value - 3/4) < 0.001) {
            return '3/4';  // 3/4 = 0.75
        } else if (Math.abs(value - 1/4) < 0.001) {
            return '1/4';  // 1/4 = 0.25
        } else if (Math.abs(value - 5/6) < 0.001) {
            return '5/6';  // 5/6 ≈ 0.8333333333333334
        } else if (Math.abs(value - 1/6) < 0.001) {
            return '1/6';  // 1/6 ≈ 0.16666666666666666
        } else if (Number.isInteger(value)) {
            return value.toString();
        } else if (value === 0) {
            return '0';
        } else {
            return value.toFixed(3);
        }
    }

    // 展开可视化功能
    function expandVisualization(originalDiv, title, approachDirection = 'both', approachValue = 'a') {
        const overlay = document.createElement('div');
        overlay.className = 'expanded-overlay';

        const content = document.createElement('div');
        content.className = 'expanded-content';
        
        // 获取当前页面中所有的可视化项目
        const currentSlide = document.querySelector('.step.is-active');
        const allVisItems = currentSlide ? currentSlide.querySelectorAll('.vis-item') : [];
        const currentIndex = Array.from(allVisItems).indexOf(originalDiv);

        const titleElement = document.createElement('div');
        titleElement.className = 'expanded-title';
        
        // 处理标题，保持数学公式的正确格式
        function parseExpandedTitle(title) {
            let formula = '', chinese = '';
            let t = title.trim();
            let brMatch = t.match(/^(.*?)(?:<br\s*\/?>)(.*)$/i);
            if (brMatch) {
                let part1 = brMatch[1].trim();
                let part2 = brMatch[2].trim();
                if (/^\$|\\|[a-zA-Z0-9_{}^]/.test(part2)) {
                    if (/[\u4e00-\u9fa5]/.test(part1)) {
                        chinese = part1;
                        formula = part2;
                    } else {
                        formula = part1;
                        chinese = part2;
                    }
                } else {
                    formula = part1;
                    chinese = part2;
                }
            } else {
                let colonMatch = t.match(/^(.+?)[:：]\s*(.+)$/);
                if (colonMatch) {
                    formula = colonMatch[2].trim();
                    chinese = colonMatch[1].trim();
                } else {
                    if (/[\u4e00-\u9fa5]/.test(t)) {
                        chinese = t;
                        formula = '';
                    } else {
                        formula = t;
                        chinese = '';
                    }
                }
            }
            formula = formula.trim();
            chinese = chinese.trim();
            if (formula && !/^\$.*\$$/.test(formula)) {
                formula = '$' + formula + '$';
            }
            return { formula, chinese };
        }

        function fracReplace(str) {
            return str
                .replace(/\\frac\s*{([^}]*)}\s*{([^}]*)}/g, '\\dfrac{$1}{$2}')
                .replace(/([^a-zA-Z0-9_\\])([0-9]+)\/([a-zA-Z0-9]+)/g, '$1\\dfrac{$2}{$3}')
                .replace(/([^a-zA-Z0-9_\\])([a-zA-Z0-9^{}\\]+)\/([a-zA-Z0-9^{}\\]+)/g, function(m, pre, num, den) {
                    if (num.startsWith('\\dfrac') || den.startsWith('\\dfrac')) return m;
                    return pre + '\\dfrac{' + num + '}{' + den + '}';
                });
        }

        const { formula, chinese } = parseExpandedTitle(title);
        let processedFormula = formula;
        if (formula) {
            processedFormula = fracReplace(formula);
        }
        
        if (chinese && processedFormula) {
            titleElement.innerHTML = `${chinese} - ${processedFormula}`;
        } else if (processedFormula) {
            titleElement.innerHTML = processedFormula;
        } else {
            titleElement.innerHTML = chinese;
        }
        
        content.appendChild(titleElement);

        // 为展开的标题重新渲染MathJax
        setTimeout(async () => {
            await renderMathJax(titleElement);
        }, 100);

        const svgContainer = document.createElement('div');
        svgContainer.className = 'expanded-svg-container';

        const closeBtn = document.createElement('button');
        closeBtn.className = 'close-btn';
        closeBtn.innerHTML = '×';
        closeBtn.onclick = () => {
            overlay.classList.remove('active');
            setTimeout(() => document.body.removeChild(overlay), 300);
        };

        // 创建简洁注释内容并添加到标题中
        const annotation = generateSimpleAnnotation(title, approachDirection, approachValue);
        
        // 将注释添加到标题的同一行
        if (chinese && processedFormula) {
            titleElement.innerHTML = `${chinese} - ${processedFormula} <span style="margin-left: 20px; color: #666; font-size: 0.9em;">${annotation}</span>`;
        } else if (processedFormula) {
            titleElement.innerHTML = `${processedFormula} <span style="margin-left: 20px; color: #666; font-size: 0.9em;">${annotation}</span>`;
        } else {
            titleElement.innerHTML = `${chinese} <span style="margin-left: 20px; color: #666; font-size: 0.9em;">${annotation}</span>`;
        }

        // 获取原始数据并重新绘制大图
        console.log('Original div:', originalDiv);
        console.log('Original div properties:', Object.keys(originalDiv));
        const originalData = originalDiv.__chartData;
        console.log('Original data:', originalData);
        
        // 尝试从div的父元素或其他方式获取数据
        if (!originalData) {
            console.log('Trying to find data in parent elements...');
            let parent = originalDiv.parentElement;
            while (parent && !originalData) {
                console.log('Checking parent:', parent);
                if (parent.__chartData) {
                    console.log('Found data in parent:', parent.__chartData);
                    break;
                }
                parent = parent.parentElement;
            }
        }
        
        if (originalData && originalData.drawFunction) {
            console.log('Drawing expanded chart...');
            const expandedSvg = d3.select(svgContainer).append('svg')
                .attr('width', '100%')
                .attr('height', '100%')
                .attr('viewBox', '0 0 800 500')
                .attr('preserveAspectRatio', 'xMidYMid meet');
            
            const g = expandedSvg.append('g')
                .attr('transform', 'translate(60, 50)');
            
            originalData.drawFunction(g, 680, 400);
        } else {
            console.log('No original data or drawFunction found');
            // 创建一个占位符
            const expandedSvg = d3.select(svgContainer).append('svg')
                .attr('width', '100%')
                .attr('height', '100%')
                .attr('viewBox', '0 0 800 500')
                .attr('preserveAspectRatio', 'xMidYMid meet');
            
            expandedSvg.append('text')
                .attr('x', 400)
                .attr('y', 250)
                .attr('text-anchor', 'middle')
                .style('font-size', '18px')
                .style('fill', '#666')
                .text('图表数据未找到');
        }

        content.appendChild(svgContainer);
        
        // 添加底部标注
        if (originalData && originalData.annotationData) {
            const annotationDiv = document.createElement('div');
            annotationDiv.className = 'chart-annotation';
            annotationDiv.innerHTML = generateChartAnnotation(title, originalData.annotationData);
            content.appendChild(annotationDiv);
        }
        content.appendChild(closeBtn);
        overlay.appendChild(content);
        document.body.appendChild(overlay);

        setTimeout(async () => {
            overlay.classList.add('active');
            // 为整个展开的内容重新渲染MathJax，延迟确保DOM完全加载
            setTimeout(async () => {
                await renderMathJax(titleElement);
                await renderMathJax(content);
            }, 300);
        }, 10);
        
        overlay.addEventListener('click', (e) => {
            if (e.target === overlay) {
                closeBtn.click();
            }
        });
    }

    // 生成底部标注函数
    function generateChartAnnotation(title, data) {
        const { type, approachPoint, limitValue, leftLimit, rightLimit, functionValue, isSequence, isDivergent, discontinuityType } = data;
        
        if (isSequence) {
            // 数列极限标注
            if (isDivergent) {
                return `<span class="conclusion">结论: 发散</span>。当 n→∞ 时, 数列的点${getSequenceBehavior(title)}。`;
            } else {
                // 格式化极限值
                const formattedLimit = formatLimitValue(limitValue);
                return `<span class="conclusion">结论: 收敛于${formattedLimit}</span>。当 n→∞ 时, 数列的点在 y=${formattedLimit} 上下振荡且幅度衰减为0。`;
            }
        } else {
            // 函数极限标注
            if (type === 'limit') {
                if (limitValue === null) {
                    const discType = getDiscontinuityType(title, leftLimit, rightLimit);
                    return `<span class="conclusion">结论: 极限不存在(${discType})</span>。<br>左极限(x→${approachPoint}⁻): ${leftLimit}。右极限(x→${approachPoint}⁺): ${rightLimit}。<br><div class="analysis">分析: ${getAnalysis(leftLimit, rightLimit, discType)}。</div>`;
                } else {
                    const formattedLimit = formatLimitValue(limitValue);
                    return `<span class="conclusion">结论: 极限存在，值为${formattedLimit}</span>。<br>左极限(x→${approachPoint}⁻): ${formattedLimit}。右极限(x→${approachPoint}⁺): ${formattedLimit}。<br><div class="analysis">分析: 左右极限存在且相等。</div>`;
                }
            } else if (type === 'continuity') {
                if (limitValue !== null && leftLimit === rightLimit && leftLimit === functionValue) {
                    const formattedLeft = formatLimitValue(leftLimit);
                    const formattedRight = formatLimitValue(rightLimit);
                    const formattedFunction = formatLimitValue(functionValue);
                    return `<span class="conclusion">结论: 在x=${approachPoint}处连续</span>。<br><div class="analysis">分析: 左极限=${formattedLeft}, 右极限=${formattedRight}, 函数值f(${approachPoint})=${formattedFunction}。三者相等。</div>`;
                } else {
                    const formattedLeft = leftLimit ? formatLimitValue(leftLimit) : '不存在';
                    const formattedRight = rightLimit ? formatLimitValue(rightLimit) : '不存在';
                    const formattedFunction = functionValue ? formatLimitValue(functionValue) : '不存在';
                    return `<span class="conclusion">结论: 在x=${approachPoint}处间断</span>。<br><div class="analysis">分析: 左极限=${formattedLeft}, 右极限=${formattedRight}, 函数值f(${approachPoint})=${formattedFunction}。三者不完全相等。</div>`;
                }
            }
        }
        
        return '';
    }
    
    function getSequenceBehavior(title) {
        if (title.includes('线性增长') || title.includes('平方增长')) return '无限增高，趋于+∞';
        if (title.includes('指数增长')) return '指数式无限增高';
        if (title.includes('震荡')) return '上下震荡且幅度增大';
        if (title.includes('交替')) return '正负交替且绝对值增大';
        if (title.includes('混沌')) return '无规律震荡';
        return '发散到无穷';
    }
    
    function getDiscontinuityType(title, leftLimit, rightLimit) {
        if (leftLimit === '∞' || leftLimit === '-∞' || rightLimit === '∞' || rightLimit === '-∞') {
            return '无穷间断点';
        }
        if (leftLimit !== rightLimit && leftLimit !== '振荡' && rightLimit !== '振荡') {
            return '跳跃间断点';
        }
        if (leftLimit === '振荡' || rightLimit === '振荡') {
            return '振荡间断点';
        }
        return '间断点';
    }
    
    function getAnalysis(leftLimit, rightLimit, discType) {
        if (discType === '跳跃间断点') return '左右极限存在但不相等';
        if (discType === '无穷间断点') return '至少一侧极限为无穷';
        if (discType === '振荡间断点') return '至少一侧极限不存在';
        return '极限性质复杂';
    }
    
    function calculateLeftLimit(caseItem, a) {
        try {
            if (caseItem.name.includes('振荡')) return '振荡';
            if (caseItem.name.includes('不存在') && caseItem.name.includes('左极限')) return '不存在';
            const testVal = a - 0.01;
            const result = caseItem.fnLeft(testVal);
            if (!isFinite(result)) return result > 0 ? '+∞' : '-∞';
            return result.toFixed(1);
        } catch(e) {
            return '不存在';
        }
    }
    
    function calculateRightLimit(caseItem, a) {
        try {
            if (caseItem.name.includes('振荡')) return '振荡';
            if (caseItem.name.includes('不存在') && caseItem.name.includes('右极限')) return '不存在';
            const testVal = a + 0.01;
            const result = caseItem.fnRight(testVal);
            if (!isFinite(result)) return result > 0 ? '+∞' : '-∞';
            return result.toFixed(1);
        } catch(e) {
            return '不存在';
        }
    }

    // 生成简洁注释
    function generateSimpleAnnotation(title, approachDirection, approachValue) {
        const annotations = {
            '左极限': '从左侧接近',
            '右极限': '从右侧接近',
            '双侧极限': '从两侧接近',
            '无穷大': '趋向无穷',
            '无穷小': '趋向零',
            '连续函数': '无间断点',
            '间断点': '存在间断',
            '初等函数': '基本函数类型',
            '等价无穷小': '极限值相等'
        };
        
        for (const [key, value] of Object.entries(annotations)) {
            if (title.includes(key)) {
                return `<div class="annotation-text">${value}</div>`;
            }
        }
        
        if (approachDirection === 'left') {
            return '<div class="annotation-text">从左侧接近</div>';
        } else if (approachDirection === 'right') {
            return '<div class="annotation-text">从右侧接近</div>';
        } else if (approachDirection === 'both') {
            return '<div class="annotation-text">从两侧接近</div>';
        }
        
        return null;
    }

    // 坐标轴绘制函数
    function drawAxes(g, xScale, yScale, width, height) {
        const xDomain = xScale.domain();
        const yDomain = yScale.domain();
        
        // X轴
        const xAxisY = (yDomain[0] <= 0 && yDomain[1] >= 0) ? yScale(0) : height;
        g.append('g')
            .attr('class', 'x-axis')
            .attr('transform', `translate(0,${xAxisY})`)
            .call(d3.axisBottom(xScale).ticks(5).tickSizeOuter(0));
        
        // Y轴
        const yAxisX = (xDomain[0] <= 0 && xDomain[1] >= 0) ? xScale(0) : 0;
        g.append('g')
            .attr('class', 'y-axis')
            .attr('transform', `translate(${yAxisX},0)`)
            .call(d3.axisLeft(yScale).ticks(5).tickSizeOuter(0));
            
        // 网格线
        g.append('g')
            .attr('class', 'grid')
            .attr('opacity', 0.1)
            .call(d3.axisBottom(xScale).ticks(5)
                .tickSize(height)
                .tickFormat(''))
            .attr('transform', `translate(0,0)`);
            
        g.append('g')
            .attr('class', 'grid')
            .attr('opacity', 0.1)
            .call(d3.axisLeft(yScale).ticks(5)
                .tickSize(-width)
                .tickFormat(''));
    }

    // 动画函数
    const animatePath = (path, duration = 2000, loop = true) => {
        if (!path || !path.node()) return;
        const totalLength = path.node().getTotalLength();
        if (totalLength === 0) return;

        function restart() {
            path
                .attr('stroke-dasharray', totalLength + ' ' + totalLength)
                .attr('stroke-dashoffset', totalLength)
                .transition()
                .duration(duration)
                .ease(d3.easeLinear)
                .attr('stroke-dashoffset', 0)
                .on('end', () => {
                    if (loop) {
                        setTimeout(restart, 500);
                    }
                });
        }
        restart();
    };

    const animatePoints = (selection, loop = true) => {
        const duration = 300;
        const delay = 50;

        function restart() {
            selection
                .style('opacity', 0)
                .transition()
                .delay((d, i) => i * delay)
                .duration(duration)
                .style('opacity', 1)
                .on('end', (d, i, nodes) => {
                    if (i === nodes.length - 1 && loop) {
                        setTimeout(() => {
                            selection.transition()
                                .duration(500)
                                .style('opacity', 0.3)
                                .on('end', () => restart());
                        }, 1500);
                    }
                });
        }
        restart();
    };

    // 极限趋近动画函数
    const animateLimitApproach = (g, xScale, yScale, func, approachPoint, limitValue, width, height) => {
        const duration = 3000;
        
        // 降低函数曲线透明度，让动画更突出
        g.selectAll('path').attr('opacity', 0.6);
        
        if (approachPoint === Infinity || approachPoint === -Infinity) {
            // 对于无穷大极限，单点向右移动
            const animateInfinity = () => {
                const movingPoint = g.append('circle')
                    .attr('class', 'moving-point')
                    .attr('r', 4)
                    .attr('fill', '#3498db')
                    .attr('opacity', 0);
                
                const xStart = xScale.domain()[0];
                const xEnd = xScale.domain()[1];
                
                movingPoint
                    .attr('cx', xScale(xStart))
                    .attr('cy', yScale(func(xStart)))
                    .transition()
                    .duration(200)
                    .attr('opacity', 1)
                    .transition()
                    .duration(duration)
                    .ease(d3.easeLinear)
                    .attr('cx', xScale(xEnd))
                    .attr('cy', yScale(func(xEnd)))
                    .on('end', () => {
                        movingPoint.transition()
                            .duration(200)
                            .attr('opacity', 0)
                            .on('end', () => {
                                movingPoint.remove();
                                setTimeout(animateInfinity, 500);
                            });
                    });
            };
            animateInfinity();
            
        } else {
            // 双边趋近动画
            const animateApproach = () => {
                const xDomain = xScale.domain();
                const range = Math.abs(xDomain[1] - xDomain[0]) * 0.4;
                const leftStart = Math.max(approachPoint - range, xDomain[0]);
                const rightStart = Math.min(approachPoint + range, xDomain[1]);
                
                // 左侧趋近点（红色）- 更大
                const leftPoint = g.append('circle')
                    .attr('class', 'left-approach-point')
                    .attr('r', 6)
                    .attr('fill', '#e74c3c')
                    .attr('opacity', 0);
                
                // 右侧趋近点（蓝色）- 更大
                const rightPoint = g.append('circle')
                    .attr('class', 'right-approach-point')
                    .attr('r', 6)
                    .attr('fill', '#3498db')
                    .attr('opacity', 0);
                
                // x轴上的三角形指示器 - 更大
                const leftTriangle = g.append('polygon')
                    .attr('class', 'left-triangle')
                    .attr('points', '0,-5 10,0 0,5')
                    .attr('fill', '#e74c3c')
                    .attr('opacity', 0);
                
                const rightTriangle = g.append('polygon')
                    .attr('class', 'right-triangle')
                    .attr('points', '0,-5 -10,0 0,5')
                    .attr('fill', '#3498db')
                    .attr('opacity', 0);
                
                // 垂直轨迹线
                const leftTrail = g.append('line')
                    .attr('class', 'left-trail')
                    .attr('stroke', '#e74c3c')
                    .attr('stroke-width', 1)
                    .attr('stroke-dasharray', '2,2')
                    .attr('opacity', 0);
                
                const rightTrail = g.append('line')
                    .attr('class', 'right-trail')
                    .attr('stroke', '#3498db')
                    .attr('stroke-width', 1)
                    .attr('stroke-dasharray', '2,2')
                    .attr('opacity', 0);
                
                // 不再显示极限点标记
                let limitPoint = null;
                
                // 初始位置
                leftPoint
                    .attr('cx', xScale(leftStart))
                    .attr('cy', yScale(func(leftStart)));
                
                rightPoint
                    .attr('cx', xScale(rightStart))
                    .attr('cy', yScale(func(rightStart)));
                
                leftTriangle
                    .attr('transform', `translate(${xScale(leftStart)}, ${height + 15})`);
                
                rightTriangle
                    .attr('transform', `translate(${xScale(rightStart)}, ${height + 15})`);
                
                // 开始动画
                const animationPromises = [];
                
                // 显示所有元素
                animationPromises.push(
                    leftPoint.transition().duration(300).attr('opacity', 1).end(),
                    rightPoint.transition().duration(300).attr('opacity', 1).end(),
                    leftTriangle.transition().duration(300).attr('opacity', 0.8).end(),
                    rightTriangle.transition().duration(300).attr('opacity', 0.8).end()
                );
                
                Promise.all(animationPromises).then(() => {
                    // 主要的趋近动画 - 确保x和y都在动
                    const leftEndX = approachPoint - 0.02;
                    const rightEndX = approachPoint + 0.02;
                    
                    // 创建连续的动画序列，让点沿着函数曲线移动
                    const animatePoint = (point, startX, endX, color, trail, triangle) => {
                        const steps = 50; // 增加步数让动画更流畅
                        const stepDuration = duration / steps;
                        let currentStep = 0;
                        
                        const animate = () => {
                            if (currentStep >= steps) {
                                // 动画完成，重新开始
                                setTimeout(() => {
                                    g.selectAll('.left-approach-point, .right-approach-point, .left-triangle, .right-triangle, .left-trail, .right-trail').remove();
                                    animateApproach();
                                }, 1000);
                                return;
                            }
                            
                            const progress = currentStep / steps;
                            const currentX = startX + (endX - startX) * progress;
                            const currentY = func(currentX);
                            
                            // 确保函数值有效
                            if (isFinite(currentY)) {
                                point
                                    .transition()
                                    .duration(stepDuration)
                                    .ease(d3.easeLinear)
                                    .attr('cx', xScale(currentX))
                                    .attr('cy', yScale(currentY));
                                
                                // 更新轨迹线
                                if (currentStep === 0) {
                                    trail
                                        .attr('x1', xScale(startX))
                                        .attr('y1', yScale(func(startX)))
                                        .attr('x2', xScale(startX))
                                        .attr('y2', yScale(func(startX)))
                                        .attr('opacity', 0.5);
                                }
                                
                                trail
                                    .transition()
                                    .duration(stepDuration)
                                    .attr('x2', xScale(currentX))
                                    .attr('y2', yScale(currentY));
                                
                                // 更新三角形指示器
                                triangle
                                    .transition()
                                    .duration(stepDuration)
                                    .attr('transform', `translate(${xScale(currentX)}, ${height + 15})`);
                            }
                            
                            currentStep++;
                            setTimeout(animate, stepDuration);
                        };
                        
                        animate();
                    };
                    
                    // 同时启动左右两个点的动画
                    animatePoint(leftPoint, leftStart, leftEndX, '#e74c3c', leftTrail, leftTriangle);
                    animatePoint(rightPoint, rightStart, rightEndX, '#3498db', rightTrail, rightTriangle);
                });
            };
            
            animateApproach();
        }
    };

    // ============ 可视化函数 ============
    const animationMap = {
        'intro': () => {},
        'toc': () => {},
        'why-limit': visualizeWhyLimit,
        'intuitive-limit': visualizeIntuitiveLimit,
        'convergent-sequences': visualizeConvergentSequences,
        'divergent-sequences': visualizeDivergentSequences,
        'sequence-calculation': visualizeSequenceCalculation,
        'function-limits': visualizeFunctionLimits,
        'one-sided-limits': visualizeOneSidedLimits,
        'one-sided-detailed': visualizeOneSidedLimitsDetailed,
        'limit-operations': visualizeLimitOperations,
        'limit-methods-detailed': visualizeLimitMethodsDetailed,
        'limit-methods': visualizeLimitMethods,
        'important-limit-1': visualizeImportantLimit1,
        'important-limit-2': visualizeImportantLimit2,
        'important-limits-detailed': visualizeImportantLimitsDetailed,
        'infinitesimal-infinity': visualizeInfinitesimalInfinity,
        'infinitesimal-comparison': visualizeInfinitesimalComparison,
        'equivalent-infinitesimal': visualizeEquivalentInfinitesimal,
        'equivalent-infinitesimal-app': visualizeEquivalentInfinitesimalApp,
        'continuous-functions': visualizeContinuousFunctions,
        'discontinuities': visualizeDiscontinuities,
        'elementary-functions': visualizeElementaryFunctions,
        'continuity-determination': visualizeContinuityDetermination,
        'applications': visualizeApplications,
        'summary': visualizeSummary
    };

    function scrollToStep(stepKey) {
        const target = document.getElementById(`step-${stepKey}`);
        if (target) {
            target.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
    }

    window.scrollToStep = scrollToStep;

    document.addEventListener('DOMContentLoaded', () => {
        const steps = Array.from(document.querySelectorAll('.step'));
        const visContainer = d3.select('#sticky-vis-container');
        let activeStep = null;

        function handleStepEnter(step) {
            if (activeStep === step) {
                return;
            }

            activeStep = step;
            cleanupAnimations();

            steps.forEach(s => s.classList.remove('is-active'));
            step.classList.add('is-active');

            const animationKey = step.dataset.animation;
            const isFullscreen = step.classList.contains('fullscreen');
            const targetContainerId = isFullscreen ? `vis-${animationKey}` : 'sticky-vis-container';

            visContainer.style('opacity', isFullscreen ? 0 : 1);

            if (!isFullscreen) {
                visContainer.classed('visualization-flex', true);
                visContainer.classed('visualization-grid', false);
                visContainer.html('');
            }

            const animator = animationMap[animationKey];
            if (typeof animator === 'function') {
                animator(targetContainerId);
            }

            if (window.MathJax && window.MathJax.typesetPromise) {
                window.MathJax.typesetPromise([step]);
            }
        }

        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    handleStepEnter(entry.target);
                }
            });
        }, {
            rootMargin: '-50% 0px -50% 0px',
            threshold: 0
        });

        steps.forEach(step => observer.observe(step));

        if (steps.length > 0) {
            handleStepEnter(steps[0]);
        }

        if (window.MathJax && window.MathJax.typesetPromise) {
            window.MathJax.typesetPromise();
        }
    });

    // 辅助函数
    function factorial(n) {
        if (n <= 1) return 1;
        return n * factorial(n - 1);
    }

    function fibonacciRatio(n) {
        let a = 1, b = 1;
        for(let i = 2; i < n; i++) {
            [a, b] = [b, a + b];
        }
        return b / a;
    }

    // 第1页：为什么要学极限
    function visualizeWhyLimit(containerId) {
        const setup = setupD3(containerId);
        if (!setup) return;
        const { g, width, height } = setup;
        
        // 阿基里斯追龟动画
        const trackY = height / 2;
        g.append('line')
            .attr('x1', 0)
            .attr('x2', width)
            .attr('y1', trackY)
            .attr('y2', trackY)
            .attr('stroke', '#34495e')
            .attr('stroke-width', 3);
        
        // 阿基里斯
        const achilles = g.append('g');
        achilles.append('circle')
            .attr('r', 15)
            .attr('fill', '#3498db')
            .attr('cy', trackY - 30);
        achilles.append('text')
            .attr('y', trackY - 50)
            .attr('text-anchor', 'middle')
            .attr('fill', '#34495e')
            .text('阿基里斯');
        
        // 乌龟
        const tortoise = g.append('g');
        tortoise.append('circle')
            .attr('r', 10)
            .attr('fill', '#2ecc71')
            .attr('cy', trackY + 30);
        tortoise.append('text')
            .attr('y', trackY + 50)
            .attr('text-anchor', 'middle')
            .attr('fill', '#34495e')
            .text('乌龟');
        
        // 距离标记
        const distanceText = g.append('text')
            .attr('x', width / 2)
            .attr('y', 30)
            .attr('text-anchor', 'middle')
            .attr('fill', '#34495e')
            .style('font-size', '18px');
        
        let step = 0;
        const steps = [
            { achilles: 0, tortoise: 200, text: "初始：乌龟领先200米" },
            { achilles: 200, tortoise: 220, text: "第1步：阿基里斯跑到200米，乌龟到220米" },
            { achilles: 220, tortoise: 222, text: "第2步：阿基里斯跑到220米，乌龟到222米" },
            { achilles: 222, tortoise: 222.2, text: "第3步：距离越来越小..." },
            { achilles: 222.2, tortoise: 222.22, text: "第4步：差距仅0.02米" },
            { achilles: 222.22, tortoise: 222.222, text: "无限接近！极限思想的体现" }
        ];
        
        function animate() {
            if (step >= steps.length) {
                step = 0;
            }
            
            const currentStep = steps[step];
            const scale = width / 300;
            
            achilles.transition()
                .duration(2000 / globalAnimationSpeed)
                .attr('transform', `translate(${currentStep.achilles * scale}, 0)`);
            
            tortoise.transition()
                .duration(2000 / globalAnimationSpeed)
                .attr('transform', `translate(${currentStep.tortoise * scale}, 0)`);
            
            distanceText.text(currentStep.text);
            
            step++;
            const timeoutId = setTimeout(animate, 3000 / globalAnimationSpeed);
            currentAnimations.push(() => clearTimeout(timeoutId));
        }
        
        animate();
    }

    // 第2页：极限的直观理解
    function visualizeIntuitiveLimit(containerId) {
        const setup = setupD3(containerId);
        if (!setup) return;
        const { g, width, height } = setup;
        
        // 杯子倒水动画
        const cupWidth = 100;
        const cupHeight = 200;
        const cupX = width / 2 - cupWidth / 2;
        const cupY = height / 2 - cupHeight / 2;
        
        // 杯子轮廓
        g.append('rect')
            .attr('x', cupX)
            .attr('y', cupY)
            .attr('width', cupWidth)
            .attr('height', cupHeight)
            .attr('fill', 'none')
            .attr('stroke', '#34495e')
            .attr('stroke-width', 3);
        
        // 刻度线
        for (let i = 1; i <= 10; i++) {
            const y = cupY + cupHeight - (cupHeight * i / 10);
            g.append('line')
                .attr('x1', cupX - 10)
                .attr('x2', cupX)
                .attr('y1', y)
                .attr('y2', y)
                .attr('stroke', '#34495e')
                .attr('stroke-width', 1);
            
            if (i % 2 === 0) {
                g.append('text')
                    .attr('x', cupX - 15)
                    .attr('y', y + 3)
                    .attr('text-anchor', 'end')
                    .attr('fill', '#34495e')
                    .style('font-size', '12px')
                    .text(`${i / 10}L`);
            }
        }
        
        // 水位
        const water = g.append('rect')
            .attr('x', cupX + 2)
            .attr('y', cupY + cupHeight - 2)
            .attr('width', cupWidth - 4)
            .attr('height', 0)
            .attr('fill', 'rgba(52, 152, 219, 0.7)');
        
        // 显示当前水量
        const volumeText = g.append('text')
            .attr('x', width / 2)
            .attr('y', cupY - 20)
            .attr('text-anchor', 'middle')
            .attr('fill', '#34495e')
            .style('font-size', '18px');
        
        let totalVolume = 0;
        let pourCount = 0;
        
        function pour() {
            if (pourCount > 8) {
                totalVolume = 0;
                pourCount = 0;
                water.attr('height', 0);
            }
            
            const pourAmount = 0.5 * Math.pow(0.5, pourCount);
            totalVolume += pourAmount;
            
            water.transition()
                .duration(1000 / globalAnimationSpeed)
                .attr('height', cupHeight * totalVolume)
                .attr('y', cupY + cupHeight - cupHeight * totalVolume);
            
            volumeText.text(`当前：${totalVolume.toFixed(4)}L，本次倒入：${pourAmount.toFixed(4)}L`);
            
            pourCount++;
            const timeoutId = setTimeout(pour, 2000 / globalAnimationSpeed);
            currentAnimations.push(() => clearTimeout(timeoutId));
        }
        
        pour();
    }

    // 第3页：收敛数列
    function visualizeConvergentSequences(containerId) {
        const container = getContainer(containerId, 'grid');
        if (!container) return;

        const sequences = [
            { name: '指数衰减: $a_n = \\frac{2}{3} + \\frac{1}{3}e^{-0.3n}$', fn: n => 2/3 + (1/3) * Math.exp(-0.3 * n), limit: 2/3 },
            { name: '交替收敛: $a_n = 2 + (-0.9)^n$', fn: n => 2 + Math.pow(-0.9, n), limit: 2 },
            { name: '调和收敛: $a_n = 1 + \\frac{1}{n}$', fn: n => 1 + 1/n, limit: 1 },
            { name: '平方根收敛: $a_n = \\sqrt{n+1} - \\sqrt{n}$', fn: n => Math.sqrt(n + 1) - Math.sqrt(n), limit: 0 },
            { name: '对数收敛: $a_n = \\frac{\\ln(n+1)}{\\ln n}$', fn: n => Math.log(n + 1) / Math.log(n), limit: 1 },
            { name: '阶乘比: $a_n = \\frac{2^n}{n!}$', fn: n => Math.pow(2, n) / (n > 10 ? 1000000 : factorial(n)), limit: 0 },
            { name: '正弦衰减: $a_n = \\frac{\\sin n}{n}$', fn: n => Math.sin(n) / n, limit: 0 },
            { name: '余弦衰减: $a_n = \\frac{1+\\cos n}{n}$', fn: n => (1 + Math.cos(n)) / n, limit: 0 },
            { name: '幂函数比: $a_n = \\frac{n^2}{n^{2.1}}$', fn: n => Math.pow(n, 2) / Math.pow(n, 2.1), limit: 0 },
            { name: '嵌套根式: $a_n = \\sqrt{2 + \\frac{1}{n}}$', fn: n => Math.sqrt(2 + 1/n), limit: Math.sqrt(2) },
            { name: '连分数: $a_n = \\frac{1}{1 + 1/n}$', fn: n => 1 / (1 + 1/n), limit: 1 },
            { name: '几何级数和: $S_n = \\sum_{k=0}^{n-1} (\\frac{1}{2})^k$', fn: n => (1 - Math.pow(0.5, n)) / 0.5, limit: 2 },
            { name: '复合函数: $a_n = n \\sin(\\frac{1}{n})$', fn: n => n * Math.sin(1/n), limit: 1 },
            { name: '双曲函数: $a_n = \\tanh(\\frac{n}{5})$', fn: n => Math.tanh(n/5), limit: 1 },
            { name: 'Fibonacci比: $a_n = \\frac{F_{n+1}}{F_n}$', fn: n => fibonacciRatio(n), limit: 1.618 }
        ];

        sequences.forEach((seq, i) => {
            const drawFunction = (g, width, height) => {
                const xScale = d3.scaleLinear().domain([1, 20]).range([0, width]);
                const yScale = d3.scaleLinear()
                    .domain([Math.min(seq.limit - 1, -1), Math.max(seq.limit + 1, 4)])
                    .range([height, 0]);

                drawAxes(g, xScale, yScale, width, height);

                // 极限线
                g.append('line')
                    .attr('x1', 0)
                    .attr('y1', yScale(seq.limit))
                    .attr('x2', width)
                    .attr('y2', yScale(seq.limit))
                    .attr('stroke', 'var(--success-color)')
                    .attr('stroke-dasharray', '3,3')
                    .attr('opacity', 0.7);

                const data = d3.range(1, 21).map(n => ({x: n, y: seq.fn(n)}));

                const points = g.selectAll('.point')
                    .data(data)
                    .enter().append('circle')
                    .attr('cx', d => xScale(d.x))
                    .attr('cy', d => yScale(d.y))
                    .attr('r', 3)
                    .attr('fill', 'var(--primary-color)');

                animatePoints(points);
            };

            const { g, width, height, div } = setup(container, i, seq.name, 'infinity');
            div.__chartData = { drawFunction, annotationData: { type: 'sequence', isSequence: true, limitValue: seq.limit } };
            drawFunction(g, width, height);
        });

        // 渲染MathJax
        setTimeout(() => renderMathJax(container), 100);
    }

    // 第4页：发散数列
function visualizeDivergentSequences(containerId) {
    const container = getContainer(containerId, 'grid');
    if (!container) return;

        const sequences = [
            { name: '线性增长: $a_n = n$', fn: n => n },
            { name: '平方增长: $a_n = \\frac{n^2}{10}$', fn: n => n * n / 10 },
            { name: '指数增长: $a_n = (1.2)^n$', fn: n => Math.pow(1.2, n) },
            { name: '对数增长: $a_n = 2\\ln n$', fn: n => Math.log(n) * 2 },
            { name: '震荡发散: $a_n = \\frac{n(-1)^n}{5}$', fn: n => n * Math.pow(-1, n) / 5 },
            { name: '正弦震荡: $a_n = \\frac{n\\sin n}{10}$', fn: n => n * Math.sin(n) / 10 },
            { name: '交替无界: $a_n = (-1.1)^n$', fn: n => Math.pow(-1.1, n) },
            { name: '阶乘增长: $a_n = \\frac{n!}{10}$', fn: n => n > 6 ? 20 : factorial(n) / 10 },
            { name: '混沌: $a_n = 3\\sin(\\frac{n^2}{10})$', fn: n => 3 * Math.sin(n * n / 10) },
            { name: '分段发散: $a_n = f(n)$', fn: n => n % 3 === 0 ? n/2 : -n/3 },
            { name: '周期爆炸: $a_n = e^{n/10}\\sin n$', fn: n => Math.sin(n) * Math.exp(n/10) },
            { name: '螺旋发散: $a_n = \\frac{n}{5}\\cos(\\frac{n}{2})$', fn: n => n * Math.cos(n/2) / 5 }
        ];

        sequences.forEach((seq, i) => {
            const drawFunction = (g, width, height) => {
                const data = d3.range(1, 21).map(n => ({x: n, y: seq.fn(n)}));
                const yExtent = d3.extent(data, d => d.y);

                const xScale = d3.scaleLinear().domain([1, 20]).range([0, width]);
                const yScale = d3.scaleLinear()
                    .domain([Math.min(yExtent[0], -5), Math.max(yExtent[1], 5)])
                    .range([height, 0]);

                drawAxes(g, xScale, yScale, width, height);

                const points = g.selectAll('.point')
                    .data(data)
                    .enter().append('circle')
                    .attr('cx', d => xScale(d.x))
                    .attr('cy', d => yScale(d.y))
                    .attr('r', 3)
                    .attr('fill', 'var(--accent-color)');

                animatePoints(points);
            };

            const { g, width, height, div } = setup(container, i, seq.name, 'infinity');
            div.__chartData = { drawFunction, annotationData: { type: 'sequence', isSequence: true, limitValue: null } };
            drawFunction(g, width, height);
        });

        // 渲染MathJax
        setTimeout(() => renderMathJax(container), 100);
    }

    // 第5页：数列极限计算
    function visualizeSequenceCalculation(containerId) {
        const setup = setupD3(containerId);
        if (!setup) return;
        const { g, width, height } = setup;
        
        // 创建交互式面板
        const panel = d3.select('#vis-sequence-calculation')
            .append('div')
            .attr('class', 'interactive-panel')
            .style('bottom', '20px');
        
        panel.append('h3')
            .style('text-align', 'center')
            .text('分子分母同除最高次演示');
        
        // 创建步骤显示区
        const stepsDiv = panel.append('div')
            .style('background', 'rgba(0, 0, 0, 0)')
            .style('padding', '20px')
            .style('border-radius', '8px')
            .style('margin-top', '20px');
        
        // 增加更详细的步骤，适合高职学生
        const steps = [
            { delay: 0, html: `<span style="color: #e74c3c;">第1步：观察最高次</span><br>
                              <span>分子最高次：n² (系数是2)</span><br>
                              <span>分母最高次：n² (系数是1)</span>` },
            { delay: 2000, html: `<span style="color: #e74c3c;">第2步：原式</span><br>
                                 <span style="font-size: 1.5rem;">$$\\lim\\limits_{n \\to \\infty} \\frac{2n^2 + 3n + 1}{n^2 + 5}$$</span>` },
            { delay: 4000, html: `<span style="color: #e74c3c;">第3步：分子分母同时除以n²</span><br>
                                 <span>分子每项都除以n²：</span><br>
                                 <span>$$\\frac{2n^2}{n^2} + \\frac{3n}{n^2} + \\frac{1}{n^2}$$</span>` },
            { delay: 6000, html: `<span style="color: #e74c3c;">第4步：化简每一项</span><br>
                                 <span>$$2 + \\frac{3}{n} + \\frac{1}{n^2}$$</span><br>
                                 <span>分母同样处理：$$1 + \\frac{5}{n^2}$$</span>` },
            { delay: 8000, html: `<span style="color: #e74c3c;">第5步：极限规律</span><br>
                                 <span style="color: #27ae60;">当n→∞时：</span><br>
                                 <span>$$\\frac{1}{n} → 0, \\quad \\frac{1}{n^2} → 0$$</span>` },
            { delay: 10000, html: `<span style="color: #e74c3c;">第6步：代入极限值</span><br>
                                  <span style="font-size: 1.8rem; color: #27ae60;">
                                  $$= \\frac{2 + 0 + 0}{1 + 0} = 2$$</span>` },
            { delay: 12000, html: `<div style="background: rgba(46, 204, 113, 0.1); padding: 15px; border-radius: 8px;">
                                  <strong>记忆口诀：</strong><br>
                                  分子分母同除以最高次<br>
                                  看系数比就是极限值！<br>
                                  <span style="color: #e74c3c;">最高次系数比 = 2/1 = 2</span>
                                  </div>` }
        ];

        // 计算步骤动画只播放一次，不循环
        let stepIndex = 0;
        function showNextStep() {
            if (stepIndex < steps.length) {
                const step = steps[stepIndex];
                stepsDiv.append('div')
                    .attr('class', 'formula-step fade-in')
                    .style('margin-top', stepIndex === 0 ? '0' : '20px')
                    .html(step.html);
                
                if (window.MathJax) {
                    MathJax.typesetPromise();
                }
                
                stepIndex++;
                if (stepIndex < steps.length) {
                    // 使用下一个步骤的延迟时间减去当前步骤的延迟时间
                    const nextStep = steps[stepIndex];
                    const delay = nextStep.delay - step.delay;
                    setTimeout(showNextStep, delay / globalAnimationSpeed);
                }
            }
        }
        
        showNextStep();
    }



    function visualizeFunctionLimits(containerId) {
        const container = getContainer(containerId, 'grid');
        if (!container) {
            console.error('Container vis-function-limits not found');
            return;
        }

        const functions = [
            { name: '多项式极限<br>$x^2-2x+1$', fn: x => x*x - 2*x + 1, a: 2, L: 1 },
            { name: '有理函数<br>$\\dfrac{x^2-4}{x-2}$', fn: x => Math.abs(x-2) > 0.01 ? (x*x - 4)/(x - 2) : 4, a: 2, L: 4 },
            { name: '根式函数<br>$\\sqrt{x+1}$', fn: x => Math.sqrt(x + 1), a: 3, L: 2 },
            { name: '三角极限<br>$\\dfrac{\\sin x}{x}$', fn: x => Math.abs(x) > 0.001 ? Math.sin(x)/x : 1, a: 0, L: 1 },
            { name: '指数极限<br>$e^{-|x|}$', fn: x => Math.exp(-Math.abs(x)), a: 0, L: 1 },
            { name: '对数极限<br>$\\ln(x+1)$', fn: x => Math.log(x + 1), a: Math.E - 1, L: 1 },
            { name: '反三角<br>$\\arctan x$', fn: x => Math.atan(x), a: 0, L: 0 },
            { name: '双曲函数<br>$\\dfrac{\\sinh x}{x}$', fn: x => Math.abs(x) > 0.001 ? Math.sinh(x)/x : 1, a: 0, L: 1 },
            { name: '分段函数<br>$\\begin{cases} x+2, & x<0 \\\\ x^2, & x\\ge0 \\end{cases}$', fn: x => x < 0 ? x + 2 : x*x, a: 0, L: null },
            { name: '绝对值<br>$|x-1|$', fn: x => Math.abs(x - 1), a: 1, L: 0 },
            { name: '取整函数<br>$\\lfloor x \\rfloor$', fn: x => Math.floor(x), a: 2, L: null },
            { name: '符号函数<br>$\\text{sgn}(x)$', fn: x => Math.sign(x), a: 0, L: null },
            { name: '振荡衰减<br>$x\\sin\\left(\\dfrac{1}{x}\\right)$', fn: x => Math.abs(x) > 0.01 ? x * Math.sin(1/x) : 0, a: 0, L: 0 },
            { name: '复合函数<br>$\\sin(\\cos x)$', fn: x => Math.sin(Math.cos(x)), a: 1, L: Math.sin(Math.cos(1)) },
            { name: '幂指函数<br>$x^x$', fn: x => x > 0 ? Math.pow(x, x) : undefined, a: 1, L: 1 }
        ];

        functions.forEach((func, i) => {
            const drawFunction = (g, width, height) => {
                const range = 2;
                const xMin = func.a - range;
                const xMax = func.a + range;

                const xScale = d3.scaleLinear().domain([xMin, xMax]).range([0, width]);
                
                const testPoints = d3.range(xMin, xMax, 0.1).map(x => func.fn(x)).filter(y => isFinite(y));
                const yExtent = d3.extent(testPoints);
                const yPadding = Math.abs(yExtent[1] - yExtent[0]) * 0.2 || 1;
                const yScale = d3.scaleLinear()
                    .domain([yExtent[0] - yPadding, yExtent[1] + yPadding])
                    .range([height, 0]);

                drawAxes(g, xScale, yScale, width, height);

                const line = d3.line()
                    .x(d => xScale(d.x))
                    .y(d => yScale(d.y))
                    .defined(d => !isNaN(d.y) && isFinite(d.y));

                const data = d3.range(xMin, xMax, 0.05).map(x => ({
                    x: x,
                    y: func.fn(x)
                }));

                const path = g.append('path')
                    .datum(data)
                    .attr('fill', 'none')
                    .attr('stroke', 'var(--primary-color)')
                    .attr('stroke-width', 2)
                    .attr('d', line);

                animatePath(path, 2000, false);

                // 添加极限趋近动画
                setTimeout(() => {
                    animateLimitApproach(g, xScale, yScale, func.fn, func.a, func.L, width, height);
                }, 100);

                if (func.L !== undefined && func.L !== null && !isNaN(func.L) && isFinite(func.L)) {
                    g.append('circle')
                        .attr('cx', xScale(func.a))
                        .attr('cy', yScale(func.L))
                        .attr('r', 4)
                        .attr('fill', 'var(--success-color)');
                }
            };

            const { g, width, height, div } = setup(container, i, func.name, 'both', func.a);
            div.__chartData = { drawFunction, annotationData: { type: 'limit', isSequence: false, approachPoint: func.a, limitValue: func.L, leftLimit: func.L, rightLimit: func.L } };
            drawFunction(g, width, height);
        });
    }


// 第7页：左右极限
function visualizeOneSidedLimits(containerId) {
    const container = getContainer(containerId, 'grid');
    if (!container) {
        console.error('Container vis-one-sided not found');
        return;
    }
    
    // 创建控制面板
    const controlPanel = document.createElement('div');
    controlPanel.className = 'interactive-panel';
    controlPanel.style.cssText = 'margin-bottom: 20px; text-align: center;';
    
    const title = document.createElement('h3');
    title.textContent = '左右极限演示';
    title.style.cssText = 'margin: 0 0 15px 0; color: var(--primary-color);';
    controlPanel.appendChild(title);
    
    const buttonContainer = document.createElement('div');
    buttonContainer.className = 'button-container';
    buttonContainer.style.cssText = 'display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;';
    controlPanel.appendChild(buttonContainer);
    
    container.appendChild(controlPanel);
    
    // 创建SVG容器
    const svgContainer = document.createElement('div');
    svgContainer.style.cssText = 'width: 100%; height: calc(100% - 80px); position: relative;';
    container.appendChild(svgContainer);
    
    const svg = d3.select(svgContainer)
        .append('svg')
        .attr('width', '100%')
        .attr('height', '100%');
    
    const margins = {top: 40, right: 40, bottom: 60, left: 60};
    const bounds = svgContainer.getBoundingClientRect();
    const width = bounds.width - margins.left - margins.right;
    const height = bounds.height - margins.top - margins.bottom;
    
    const g = svg.append('g')
        .attr('transform', `translate(${margins.left}, ${margins.top})`);
    
    // 添加箭头标记
    svg.append('defs').append('marker')
        .attr('id', 'arrowhead-one-sided')
        .attr('viewBox', '0 -5 10 10')
        .attr('refX', 8)
        .attr('refY', 0)
        .attr('markerWidth', 8)
        .attr('markerHeight', 8)
        .attr('orient', 'auto')
        .append('path')
        .attr('d', 'M0,-5L10,0L0,5')
        .attr('fill', 'var(--danger-color)');
    
    // 创建分段函数示例
    const cases = [
        {
            name: '跳跃间断',
            fnLeft: x => x,
            fnRight: x => x + 2,
            a: 0,
            leftLimit: 0,
            rightLimit: 2
        },
        {
            name: '可去间断',
            fnLeft: x => (x*x - 1)/(x - 1),
            fnRight: x => (x*x - 1)/(x - 1),
            a: 1,
            leftLimit: 2,
            rightLimit: 2
        },
        {
            name: '无穷间断',
            fnLeft: x => -1/x,
            fnRight: x => 1/x,
            a: 0,
            leftLimit: -Infinity,
            rightLimit: Infinity
        }
    ];
    
    // 创建按钮
    cases.forEach((c, i) => {
        const button = document.createElement('button');
        button.className = 'nav-btn';
        button.textContent = c.name;
        button.style.cssText = 'margin: 5px; padding: 8px 16px; border: 1px solid var(--primary-color); background: white; color: var(--primary-color); border-radius: 4px; cursor: pointer; transition: all 0.3s;';
        button.onmouseover = function() {
            this.style.background = 'var(--primary-color)';
            this.style.color = 'white';
        };
        button.onmouseout = function() {
            this.style.background = 'white';
            this.style.color = 'var(--primary-color)';
        };
        button.onclick = () => drawCase(i);
        buttonContainer.appendChild(button);
    });
    
    const xScale = d3.scaleLinear().domain([-3, 3]).range([0, width]);
    const yScale = d3.scaleLinear().domain([-5, 5]).range([height, 0]);
    
    // 坐标轴
    g.append('g')
        .attr('transform', `translate(0, ${yScale(0)})`)
        .call(d3.axisBottom(xScale));
    
    g.append('g')
        .attr('transform', `translate(${xScale(0)}, 0)`)
        .call(d3.axisLeft(yScale));
    
    function drawCase(index) {
        g.selectAll('.function-path').remove();
        g.selectAll('.limit-marker').remove();
        
        const caseItem = cases[index];
        
        // 左侧函数
        const leftData = d3.range(-3, caseItem.a - 0.01, 0.01)
            .map(x => ({x: x, y: caseItem.fnLeft(x)}))
            .filter(d => !isNaN(d.y) && isFinite(d.y) && Math.abs(d.y) < 10);
        
        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y));
        
        g.append('path')
            .attr('class', 'function-path')
            .datum(leftData)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#e74c3c')
            .attr('stroke-width', 2);
        
        // 右侧函数
        const rightData = d3.range(caseItem.a + 0.01, 3, 0.01)
            .map(x => ({x: x, y: caseItem.fnRight(x)}))
            .filter(d => !isNaN(d.y) && isFinite(d.y) && Math.abs(d.y) < 10);
        
        g.append('path')
            .attr('class', 'function-path')
            .datum(rightData)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#3498db')
            .attr('stroke-width', 2);
        
        // 标记间断点位置
        g.append('line')
            .attr('class', 'limit-marker')
            .attr('x1', xScale(caseItem.a))
            .attr('y1', 0)
            .attr('x2', xScale(caseItem.a))
            .attr('y2', height)
            .attr('stroke', 'gray')
            .attr('stroke-dasharray', '2,2')
            .attr('opacity', 0.5);
        
        // 显示左右极限值
        if (isFinite(caseItem.leftLimit)) {
            g.append('circle')
                .attr('class', 'limit-marker')
                .attr('cx', xScale(caseItem.a))
                .attr('cy', yScale(caseItem.leftLimit))
                .attr('r', 5)
                .attr('fill', 'white')
                .attr('stroke', '#e74c3c')
                .attr('stroke-width', 2);
            
            g.append('text')
                .attr('class', 'limit-marker')
                .attr('x', xScale(caseItem.a) - 60)
                .attr('y', yScale(caseItem.leftLimit))
                .attr('fill', '#e74c3c')
                .text(`左极限: ${caseItem.leftLimit}`);
        }
        
        if (isFinite(caseItem.rightLimit)) {
            g.append('circle')
                .attr('class', 'limit-marker')
                .attr('cx', xScale(caseItem.a))
                .attr('cy', yScale(caseItem.rightLimit))
                .attr('r', 5)
                .attr('fill', 'white')
                .attr('stroke', '#3498db')
                .attr('stroke-width', 2);
            
            g.append('text')
                .attr('class', 'limit-marker')
                .attr('x', xScale(caseItem.a) + 10)
                .attr('y', yScale(caseItem.rightLimit))
                .attr('fill', '#3498db')
                .text(`右极限: ${caseItem.rightLimit}`);
        }
        
        // 添加说明文字
        g.append('text')
            .attr('class', 'limit-marker')
            .attr('x', width / 2)
            .attr('y', height + 30)
            .attr('text-anchor', 'middle')
            .attr('fill', '#34495e')
            .style('font-size', '14px')
            .text(`函数类型: ${caseItem.name} - 观察 x = ${caseItem.a} 处的左右极限`);
    }
    
    drawCase(0);
}

// 第7.1页：左右极限详细演示
function visualizeOneSidedLimitsDetailed(containerId) {
    const container = getContainer(containerId, 'grid');
    if (!container) {
        console.error('Container vis-one-sided-detailed not found');
        return;
    }

    const cases = [
        {
            name: '左右极限相等<br>$x+1$',
            fnLeft: x => x + 1,
            fnRight: x => x + 1,
            a: 0, L: 1
        },
        {
            name: '跳跃间断<br>$\\begin{cases} x,\\ x<0 \\\\ x+2,\\ x \\ge 0 \\end{cases}$',
            fnLeft: x => x,
            fnRight: x => x + 2,
            a: 0, L: null
        },
        {
            name: '左极限不存在<br>$\\begin{cases} \\dfrac{1}{x},\\ x<0 \\\\ x+1,\\ x \\ge 0 \\end{cases}$',
            fnLeft: x => 1/x,
            fnRight: x => x + 1,
            a: 0, L: null
        },
        {
            name: '右极限不存在<br>$\\begin{cases} x-1,\\ x<1 \\\\ \\dfrac{1}{x-1},\\ x \\ge 1 \\end{cases}$',
            fnLeft: x => x - 1,
            fnRight: x => 1/(x-1),
            a: 1, L: null
        },
        {
            name: '振荡间断<br>$\\sin\\left(\\dfrac{1}{x}\\right)$',
            fnLeft: x => Math.sin(1/x),
            fnRight: x => Math.sin(1/x),
            a: 0, L: null
        },
        {
            name: '可去间断<br>$\\dfrac{x^2-1}{x-1}$',
            fnLeft: x => (x*x - 1)/(x - 1),
            fnRight: x => (x*x - 1)/(x - 1),
            a: 1, L: 2
        },
        {
            name: '无穷间断<br>$\\begin{cases} -\\dfrac{1}{x^2},\\ x<0 \\\\ \\dfrac{1}{x^2},\\ x>0 \\end{cases}$',
            fnLeft: x => -1/(x*x),
            fnRight: x => 1/(x*x),
            a: 0, L: null
        },
        {
            name: '分段连续<br>$\\begin{cases} \\sin x,\\ x<0 \\\\ x,\\ x \\ge 0 \\end{cases}$',
            fnLeft: x => Math.sin(x),
            fnRight: x => x,
            a: 0, L: 0
        },
        {
            name: '指数跳跃<br>$\\begin{cases} e^x,\\ x<0 \\\\ e^x+1,\\ x \\ge 0 \\end{cases}$',
            fnLeft: x => Math.exp(x),
            fnRight: x => Math.exp(x) + 1,
            a: 0, L: null
        },
        {
            name: '对数间断<br>$\\ln|x|$',
            fnLeft: x => Math.log(-x),
            fnRight: x => Math.log(x),
            a: 0, L: null
        },
        {
            name: '三角跳跃<br>$\\begin{cases} \\cos x,\\ x<\\pi/2 \\\\ \\sin x,\\ x \\ge \\pi/2 \\end{cases}$',
            fnLeft: x => Math.cos(x),
            fnRight: x => Math.sin(x),
            a: Math.PI/2, L: null
        },
        {
            name: '幂函数跳跃<br>$\\begin{cases} x^2,\\ x<1 \\\\ x^3+1,\\ x \\ge 1 \\end{cases}$',
            fnLeft: x => Math.pow(x, 2),
            fnRight: x => Math.pow(x, 3) + 1,
            a: 1, L: null
        }
    ];

    cases.forEach((caseItem, i) => {
        const drawFunction = (g, width, height) => {
            const range = 1.5;
            const xScale = d3.scaleLinear()
                .domain([caseItem.a - range, caseItem.a + range])
                .range([0, width]);
            const yScale = d3.scaleLinear()
                .domain([-3, 3])
                .range([height, 0]);

            drawAxes(g, xScale, yScale, width, height);

            const line = d3.line()
                .x(d => xScale(d.x))
                .y(d => yScale(d.y))
                .defined(d => !isNaN(d.y) && isFinite(d.y) && Math.abs(d.y) < 10);

            const leftData = d3.range(caseItem.a - range, caseItem.a - 0.01, 0.01)
                .map(x => ({x: x, y: caseItem.fnLeft(x)}));

            const leftPath = g.append('path')
                .datum(leftData)
                .attr('fill', 'none')
                .attr('stroke', 'var(--danger-color)')
                .attr('stroke-width', 2)
                .attr('d', line);
            animatePath(leftPath);

            const rightData = d3.range(caseItem.a + 0.01, caseItem.a + range, 0.01)
                .map(x => ({x: x, y: caseItem.fnRight(x)}));

            const rightPath = g.append('path')
                .datum(rightData)
                .attr('fill', 'none')
                .attr('stroke', 'var(--primary-color)')
                .attr('stroke-width', 2)
                .attr('d', line);
            animatePath(rightPath, 2000, false);

            g.append('line')
                .attr('x1', xScale(caseItem.a))
                .attr('y1', 0)
                .attr('x2', xScale(caseItem.a))
                .attr('y2', height)
                .attr('stroke', 'gray')
                .attr('stroke-dasharray', '2,2')
                .attr('opacity', 0.5);

            // 添加双边趋近动画
            setTimeout(() => {
                // 计算左右极限值
                const leftLimit = caseItem.fnLeft(caseItem.a - 0.001);
                const rightLimit = caseItem.fnRight(caseItem.a + 0.001);
                const avgLimit = isFinite(leftLimit) && isFinite(rightLimit) ? (leftLimit + rightLimit) / 2 : (caseItem.L || 0);
                animateLimitApproach(g, xScale, yScale, x => x < caseItem.a ? caseItem.fnLeft(x) : caseItem.fnRight(x), caseItem.a, avgLimit, width, height);
            }, 100);
        };

        let approachVal;
        if (caseItem.a === Math.PI/2) {
            approachVal = 'π/2';
        } else if (caseItem.a === 0) {
            approachVal = '0';
        } else if (caseItem.a === 1) {
            approachVal = '1';
        } else {
            approachVal = caseItem.a.toString();
        }
        const { g, width, height, div } = setup(container, i, caseItem.name, 'both', approachVal);
        div.__chartData = { drawFunction, annotationData: { type: 'limit', isSequence: false, approachPoint: caseItem.a, limitValue: caseItem.L, leftLimit: caseItem.L, rightLimit: caseItem.L } };
        drawFunction(g, width, height);
    });
}

// 第8页：极限的四则运算法则
function visualizeLimitOperations(containerId) {
    const container = getContainer(containerId, 'grid');
    if (!container) return;

  

const operations = [
    { name: '和<br>$x+x^2$', f: x => x, g: x => x*x, op: (a,b) => a+b },
    { name: '差<br>$x^2-x$', f: x => x*x, g: x => x, op: (a,b) => a-b },
    { name: '积<br>$x \\sin x$', f: x => x, g: x => Math.sin(x), op: (a,b) => a*b },
    { name: '商<br>$x^2/x$', f: x => x*x, g: x => x, op: (a,b) => a/b },
    { name: '数乘<br>$2\\sin x$', f: x => Math.sin(x), g: x => 2, op: (a,b) => a*b },
    { name: '幂<br>$x^2$', f: x => x, g: x => 2, op: (a,b) => Math.pow(a, b) },
    { name: '开方<br>$\\sqrt{x+4}$', f: x => x + 4, g: x => 0, op: (a,b) => Math.sqrt(a) },
    { name: '绝对值<br>$|x-1|$', f: x => x - 1, g: x => 0, op: (a,b) => Math.abs(a) },
    { name: '复合<br>$(x+1)^2$', f: x => x*x, g: x => x+1, op: (a,b) => (b*b) },
    { name: '最大值<br>$\\max(x, 1-x)$', f: x => x, g: x => 1-x, op: (a,b) => Math.max(a,b) },
    { name: '最小值<br>$\\min(x^2, x)$', f: x => x*x, g: x => x, op: (a,b) => Math.min(a,b) },
    { name: '幂指<br>$(x+2)^2$', f: x => x+2, g: x => 2, op: (a,b) => Math.pow(a,b) }
];

operations.forEach((op, i) => {
    const drawFunction = (g, width, height) => {
        const xScale = d3.scaleLinear().domain([-2, 2]).range([0, width]);
        const yScale = d3.scaleLinear().domain([-2, 4]).range([height, 0]);

        drawAxes(g, xScale, yScale, width, height);

        const data1 = d3.range(-2, 2, 0.05).map(x => ({x: x, y: op.f(x)}));
        const data2 = d3.range(-2, 2, 0.05).map(x => ({x: x, y: op.g(x)}));
        const dataResult = d3.range(-2, 2, 0.05).map(x => ({
            x: x,
            y: op.op(op.f(x), op.g(x))
        })).filter(d => !isNaN(d.y) && isFinite(d.y));

        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y))
            .defined(d => !isNaN(d.y) && isFinite(d.y));

        const path1 = g.append('path')
            .datum(data1)
            .attr('fill', 'none')
            .attr('stroke', 'var(--accent-color)')
            .attr('stroke-width', 1)
            .attr('stroke-dasharray', '3,3')
            .attr('d', line);
        animatePath(path1, 1500);

        const path2 = g.append('path')
            .datum(data2)
            .attr('fill', 'none')
            .attr('stroke', 'var(--primary-color)')
            .attr('stroke-width', 1)
            .attr('stroke-dasharray', '3,3')
            .attr('d', line);
        animatePath(path2, 1500);

        const pathResult = g.append('path')
            .datum(dataResult)
            .attr('fill', 'none')
            .attr('stroke', 'var(--success-color)')
            .attr('stroke-width', 2)
            .attr('d', line);
        animatePath(pathResult, 2000);
    };

    const { g, width, height, div } = setup(container, i, op.name);
    div.__chartData = {
        drawFunction,
        annotationData: {
            type: 'limit',
            isSequence: false,
            approachPoint: 0,
            limitValue: op.op(op.f(0), op.g(0)),
            leftLimit: op.op(op.f(0), op.g(0)),
            rightLimit: op.op(op.f(0), op.g(0))
        }
    };
    drawFunction(g, width, height);
});
}
    
// 第8.1页：极限运算方法
function visualizeLimitMethodsDetailed(containerId) {
    const container = getContainer(containerId, 'grid');
    if (!container) {
        console.error('Container vis-limit-methods-detailed not found');
        return;
    }

    const methods = [
        { name: '直接代入法<br>$\\frac{x^2+1}{x+2}$', fn: x => (x*x + 1)/(x+2), a: 1, L: 2/3 },
        { name: '因式分解法<br>$\\frac{x^2-1}{x-1}$', fn: x => Math.abs(x-1) > 0.01 ? (x*x - 1)/(x-1) : 2, a: 1, L: 2 },
        { name: '分子有理化<br>$\\frac{\\sqrt{x+1}-1}{x}$', fn: x => Math.abs(x) > 0.01 ? (Math.sqrt(x+1)-1)/x : 0.5, a: 0, L: 0.5 },
        { name: '分母有理化<br>$\\frac{x}{\\sqrt{x+4}-2}$', fn: x => Math.abs(Math.sqrt(x+4)-2) > 0.01 ? x/(Math.sqrt(x+4)-2) : 4, a: 0, L: 4 },
        { name: '无穷大比较法<br>$\\frac{2x^2-3}{3x^2+x}$', fn: x => (2*x*x - 3)/(3*x*x + x), a: 10, L: 2/3 },
        { name: '夹逼定理<br>$x^2\\sin(\\frac{1}{x})$', fn: x => Math.abs(x) > 0.01 ? x*x * Math.sin(1/x) : 0, a: 0, L: 0 },
        { name: '重要极限 I<br>$\\frac{\\sin x}{x}$', fn: x => Math.abs(x) > 0.001 ? Math.sin(x)/x : 1, a: 0, L: 1 },
        { name: '重要极限 II<br>$\\left(1+\\frac{1}{x}\\right)^x$', fn: x => x > 0.1 ? Math.pow(1+1/x, x) : Math.E, a: 10, L: Math.E },
        { name: '洛必达法则<br>$\\frac{e^x-1}{\\sin x}$', fn: x => Math.abs(x) > 0.001 ? (Math.exp(x)-1)/Math.sin(x) : 1, a: 0, L: 1 },
        { name: '等价无穷小<br>$\\frac{\\tan(2x)}{\\ln(1+x)}$', fn: x => Math.abs(x) > 0.01 ? Math.tan(2*x) / Math.log(1+x) : 2, a: 0, L: 2 },
        { name: '通分法<br>$\\frac{1}{x-1}-\\frac{2}{x^2-1}$', fn: x => Math.abs(x-1) > 0.01 ? 1/(x-1) - 2/(x*x-1) : 0.5, a: 1, L: 0.5 },
        { name: '变量替换法<br>$\\frac{e^x-1}{e^x+1}$', fn: x => (Math.exp(x) - 1)/(Math.exp(x) + 1), a: 0, L: 0 }
    ];

    methods.forEach((method, i) => {
        const drawFunction = (g, width, height) => {
            let xDomain, data;
            if (method.a >= 10) {
                xDomain = [1, 20];
                data = d3.range(1, 20, 0.5).map(x => ({x: x, y: method.fn(x)}));
            } else {
                xDomain = [method.a - 2, method.a + 2];
                data = d3.range(xDomain[0], xDomain[1], 0.02)
                    .filter(x => Math.abs(x - method.a) > 1e-6)
                    .map(x => ({x: x, y: method.fn(x)}));
            }

            const yExtent = d3.extent(data.filter(d => isFinite(d.y)), d => d.y);
            const yPadding = Math.abs(yExtent[1] - yExtent[0]) * 0.2 || 1;
            const yDomain = [yExtent[0] - yPadding, yExtent[1] + yPadding];

            const xScale = d3.scaleLinear().domain(xDomain).range([0, width]);
            const yScale = d3.scaleLinear().domain(yDomain).range([height, 0]);

            drawAxes(g, xScale, yScale, width, height);

            const line = d3.line()
                .x(d => xScale(d.x))
                .y(d => yScale(d.y))
                .defined(d => !isNaN(d.y) && isFinite(d.y));

            const path = g.append('path')
                .datum(data.filter(d => isFinite(d.y)))
                .attr('fill', 'none')
                .attr('stroke', 'var(--primary-color)')
                .attr('stroke-width', 2)
                .attr('d', line);
            animatePath(path, 2000, false);

            // 添加极限趋近动画
            setTimeout(() => {
                const approachVal = method.a >= 10 ? Infinity : method.a;
                animateLimitApproach(g, xScale, yScale, method.fn, approachVal, method.L, width, height);
            }, 100);

            if (method.a < 10) {
                g.append('circle')
                    .attr('cx', xScale(method.a))
                    .attr('cy', yScale(method.L))
                    .attr('r', 4)
                    .attr('fill', 'white')
                    .attr('stroke', 'var(--success-color)')
                    .attr('stroke-width', 2);
            }
        };

        const { g, width, height, div } = setup(container, i, method.name, 'both', method.a);
        div.__chartData = {
            drawFunction,
            annotationData: {
                type: 'limit',
                isSequence: false,
                approachPoint: method.a,
                limitValue: method.L,
                leftLimit: method.L,
                rightLimit: method.L
            }
        };
        drawFunction(g, width, height);
    });
}

// 第9页：极限计算方法
function visualizeLimitMethods(containerId) {
    const setup = setupD3(containerId);
    if (!setup) return;
    const { g, width, height } = setup;
    
    const panel = d3.select('#vis-limit-methods')
        .append('div')
        .attr('class', 'interactive-panel')
        .style('width', '50%')
        .style('fill', 'rgba(255, 255, 255, 0)');
 
    
    const methods = [
        {
            name: '因式分解法',
            problem: '$$\\lim\\limits_{x \\to 1} \\frac{x^2 - 1}{x - 1}$$',
            steps: [
                '分解: $\\frac{(x+1)(x-1)}{x-1}$',
                '约分: $x+1$',
                '代入: $1+1 = 2$'
            ],
            fn: x => Math.abs(x-1) > 0.01 ? (x*x - 1)/(x - 1) : 2,
            a: 1,
            L: 2
        },
        {
            name: '有理化法',
            problem: '$$\\lim\\limits_{x \\to 0} \\frac{\\sqrt{x+1}-1}{x}$$',
            steps: [
                '分子分母同乘 $\\sqrt{x+1}+1$',
                '= $\\frac{(x+1)-1}{x(\\sqrt{x+1}+1)}$',
                '= $\\frac{1}{\\sqrt{x+1}+1} = \\frac{1}{2}$'
            ],
            fn: x => Math.abs(x) > 0.01 ? (Math.sqrt(x+1)-1)/x : 0.5,
            a: 0,
            L: 0.5
        },
        {
            name: '等价无穷小',
            problem: '$$\\lim\\limits_{x \\to 0} \\frac{\\sin x}{x}$$',
            steps: [
                '当 $x \\to 0$ 时',
                '$\\sin x \\sim x$',
                '极限 = 1'
            ],
            fn: x => Math.abs(x) > 0.001 ? Math.sin(x)/x : 1,
            a: 0,
            L: 1
        }
    ];
    
    let currentMethod = 0;
    
    const buttonContainer = panel.append('div')
        .style('display', 'flex')
        .style('gap', '10px')
        .style('margin-bottom', '20px');
    
    methods.forEach((method, i) => {
        buttonContainer.append('button')
            .attr('class', 'nav-btn')
            .text(method.name)
            .on('click', () => showMethod(i));
    });
    
    const stepsContainer = panel.append('div')
        .style('background', 'rgba(0,0,0,0.05)')
        .style('padding', '20px')
        .style('border-radius', '8px');
    
    const xScale = d3.scaleLinear().domain([-2, 2]).range([0, width]);
    const yScale = d3.scaleLinear().domain([-1, 4]).range([height - 100, 0]);
    
    // 坐标轴
    g.append('g')
        .attr('transform', `translate(0, ${yScale(0)})`)
        .call(d3.axisBottom(xScale));
    
    g.append('g')
        .attr('transform', `translate(${xScale(0)}, 0)`)
        .call(d3.axisLeft(yScale));
    
    function showMethod(index) {
        currentMethod = index;
        const method = methods[index];
        
        // 清除之前的内容
        stepsContainer.selectAll('*').remove();
        g.selectAll('.method-graph').remove();
        
        // 显示问题
        stepsContainer.append('div')
            .style('font-size', '1.5rem')
            .style('margin-bottom', '20px')
            .html(method.problem);
        
        // 逐步显示步骤 - 只播放一次，不循环
        let stepIndex = 0;
        function showMethodStep() {
            if (stepIndex < method.steps.length) {
                const step = method.steps[stepIndex];
                stepsContainer.append('div')
                    .attr('class', 'formula-step fade-in')
                    .style('margin', '10px 0')
                    .style('padding-left', '20px')
                    .html(`步骤 ${stepIndex+1}: ${step}`);
                
                if (window.MathJax) {
                    MathJax.typesetPromise();
                }
                
                stepIndex++;
                if (stepIndex < method.steps.length) {
                    setTimeout(showMethodStep, 1000 / globalAnimationSpeed);
                }
            }
        }
        
        showMethodStep();
        
        // 绘制函数
        const data = d3.range(-2, 2, 0.01)
            .map(x => ({x: x, y: method.fn(x)}))
            .filter(d => !isNaN(d.y) && isFinite(d.y) && Math.abs(d.y) < 10);
        
        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y));
        
        const path = g.append('path')
            .attr('class', 'method-graph')
            .datum(data)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', 'var(--primary-color)')
            .attr('stroke-width', 2);
        
        // 标记极限点
        g.append('circle')
            .attr('class', 'method-graph')
            .attr('cx', xScale(method.a))
            .attr('cy', yScale(method.L))
            .attr('r', 6)
            .attr('fill', 'var(--success-color)');
        
        // 动画
        const totalLength = path.node().getTotalLength();
        path
            .attr('stroke-dasharray', totalLength + ' ' + totalLength)
            .attr('stroke-dashoffset', totalLength)
            .transition()
            .duration(2000 / globalAnimationSpeed)
            .ease(d3.easeLinear)
            .attr('stroke-dashoffset', 0);
    }
    
    showMethod(0);
}

// 第10页：第一重要极限
function visualizeImportantLimit1(containerId) {
    const container = getContainer(containerId, 'flex');
    if (!container) return;
    
    // 创建左右分栏布局
    const mainDiv = d3.select(container)
        .append('div')
        .style('display', 'flex')
        .style('height', '100%');
    
    // 左侧：图形展示
    const leftDiv = mainDiv.append('div')
        .style('flex', '1')
        .style('padding', '20px');
    
    // 右侧：练习题
    const rightDiv = mainDiv.append('div')
        .style('flex', '0.5')
        .style('padding', '20px')
        .style('background', 'rgba(52, 152, 219, 0.05)')
        .style('border-radius', '10px')
        .style('margin', '20px');
    
    rightDiv.append('h3')
        .style('color', '#3498db')
        .text('试试看：');
    
    // 练习题组
    const exercises = [
        { 
            problem: '$$\\lim_{x→0} \\frac{\\sin 2x}{x}$$',
            hint: '把2x看作整体',
            answer: '2'
        },
        { 
            problem: '$$\\lim_{x→0} \\frac{\\sin 3x}{2x}$$',
            hint: '分子分母都有系数',
            answer: '3/2'
        },
        { 
            problem: '$$\\lim_{x→0} \\frac{\\sin 5x}{\\sin 2x}$$',
            hint: '上下同除以x',
            answer: '5/2'
        }
    ];
    
    exercises.forEach((ex, i) => {
        const exDiv = rightDiv.append('div')
            .style('margin', '20px 0')
            .style('padding', '15px')
            .style('background', 'white')
            .style('border-radius', '8px');
        
        exDiv.append('div')
            .html(`题${i+1}：${ex.problem}`);
        
        const hintBtn = exDiv.append('button')
            .style('margin', '10px 5px')
            .style('padding', '5px 10px')
            .style('background', '#f39c12')
            .style('color', 'white')
            .style('border', 'none')
            .style('border-radius', '4px')
            .style('cursor', 'pointer')
            .text('提示')
            .on('click', function() {
                d3.select(this.parentNode)
                    .append('div')
                    .style('color', '#f39c12')
                    .style('margin-top', '5px')
                    .text(ex.hint);
            });
        
        const answerBtn = exDiv.append('button')
            .style('margin', '10px 5px')
            .style('padding', '5px 10px')
            .style('background', '#27ae60')
            .style('color', 'white')
            .style('border', 'none')
            .style('border-radius', '4px')
            .style('cursor', 'pointer')
            .text('答案')
            .on('click', function() {
                d3.select(this.parentNode)
                    .append('div')
                    .style('color', '#27ae60')
                    .style('margin-top', '5px')
                    .style('font-weight', 'bold')
                    .text(`答案：${ex.answer}`);
            });
    });
    
    // 左侧图形代码
    const titleDiv = leftDiv
        .append('div')
        .style('text-align', 'center')
        .style('font-size', '20px')
        .style('color', 'black')
        .style('margin-bottom', '10px')
        .html('$$\\lim\\limits_{x \\to 0} \\frac{\\sin x}{x} = 1$$');
    
    const width = 500;
    const height = 300;
    const margin = { top: 20, right: 50, bottom: 50, left: 50 };
    
    const svg = leftDiv
        .append('svg')
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom);
    
    const g = svg.append('g')
        .attr('transform', `translate(${margin.left}, ${margin.top})`);
    
    const xScale = d3.scaleLinear().domain([-Math.PI, Math.PI]).range([0, width]);
    const yScale = d3.scaleLinear().domain([-0.5, 1.5]).range([height, 0]);
    
    // 坐标轴
    g.append('g')
        .attr('transform', `translate(0, ${yScale(0)})`)
        .call(d3.axisBottom(xScale).tickFormat(d => {
            if (d === 0) return '0';
            if (d === Math.PI) return 'π';
            if (d === -Math.PI) return '-π';
            return d.toFixed(1);
        }));
    
    g.append('g')
        .call(d3.axisLeft(yScale));
    
    // 渲染MathJax
    if (window.MathJax) {
        MathJax.typesetPromise([titleDiv.node()]);
    }
    
    // 绘制sin(x)/x
    const data = [];
    for (let x = -Math.PI; x <= Math.PI; x += 0.01) {
        if (Math.abs(x) > 0.001) {
            data.push({ x: x, y: Math.sin(x) / x });
        }
    }
    
    const line = d3.line()
        .x(d => xScale(d.x))
        .y(d => yScale(d.y));
    
    g.append('path')
        .datum(data)
        .attr('d', line)
        .attr('fill', 'none')
        .attr('stroke', 'cyan')
        .attr('stroke-width', 3);
    
    // 极限值线 y=1
    g.append('line')
        .attr('x1', 0)
        .attr('x2', width)
        .attr('y1', yScale(1))
        .attr('y2', yScale(1))
        .attr('stroke', 'darkgreen')
        .attr('stroke-width', 6)
        .attr('stroke-dasharray', '5,5');
    
    g.append('text')
        .attr('x', width - 90)
        .attr('y', yScale(1) - 25)
        .attr('fill', 'darkgreen')
        .style('font-size', '24px')
        .text('y = 1');
    
    // x=0处的极限点
    g.append('circle')
        .attr('cx', xScale(0))
        .attr('cy', yScale(1))
        .attr('r', 6)
        .attr('fill', 'red')
        .attr('stroke', 'black')
        .attr('stroke-width', 2);
}

// 第11页：第二重要极限
function visualizeImportantLimit2(containerId) {
    const container = getContainer(containerId, 'flex');
    if (!container) return;
    
    // 创建主容器，确保垂直布局
    const mainDiv = d3.select(container)
        .append('div')
        .style('display', 'flex')
        .style('flex-direction', 'column')
        .style('align-items', 'center')
        .style('width', '100%');
    
    // 标题容器
    const titleDiv = mainDiv
        .append('div')
        .style('text-align', 'center')
        .style('font-size', '20px')
        .style('color', 'black')
        .style('margin-bottom', '10px')
        .style('width', '100%')
        .html('$$\\lim\\limits_{x \\to \\infty} \\left(1+\\frac{1}{x}\\right)^x = e$$');
    
    // 图表容器
    const chartDiv = mainDiv
        .append('div')
        .style('width', '100%')
        .style('display', 'flex')
        .style('justify-content', 'center');
    
    const width = 600;
    const height = 400;
    const margin = { top: 20, right: 50, bottom: 50, left: 50 };
    
    const svg = chartDiv
        .append('svg')
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom);
    
    const g = svg.append('g')
        .attr('transform', `translate(${margin.left}, ${margin.top})`);
    
    const xScale = d3.scaleLog().domain([1, 100]).range([0, width]);
    const yScale = d3.scaleLinear().domain([2, 3]).range([height, 0]);
    
    // 坐标轴
    g.append('g')
        .attr('transform', `translate(0, ${height})`)
        .call(d3.axisBottom(xScale).tickFormat(d => {
            if (d === 1) return '1';
            if (d === 10) return '10';
            if (d === 100) return '100';
            return d.toString();
        }));
    
    g.append('g')
        .call(d3.axisLeft(yScale));
    
    // 渲染MathJax
    if (window.MathJax) {
        MathJax.typesetPromise([titleDiv.node()]);
    }
    
    // 绘制(1+1/x)^x - 带动画效果
    const data = [];
    for (let x = 1; x <= 100; x *= 1.1) {
        data.push({ x: x, y: Math.pow(1 + 1/x, x) });
    }
    
    const line = d3.line()
        .x(d => xScale(d.x))
        .y(d => yScale(d.y));
    
    const path = g.append('path')
        .datum(data)
        .attr('d', line)
        .attr('fill', 'none')
        .attr('stroke', 'lime')
        .attr('stroke-width', 3);
    
    // 路径动画
    const totalLength = path.node().getTotalLength();
    path.attr('stroke-dasharray', totalLength + ' ' + totalLength)
        .attr('stroke-dashoffset', totalLength)
        .transition()
        .duration(2000)
        .attr('stroke-dashoffset', 0);
    
    // e值线 - 延迟出现
    const eLine = g.append('line')
        .attr('x1', 0)
        .attr('x2', width)
        .attr('y1', yScale(Math.E))
        .attr('y2', yScale(Math.E))
        .attr('stroke', 'orange')
        .attr('stroke-width', 6)
        .attr('stroke-dasharray', '5,5')
        .attr('opacity', 0);
    
    eLine.transition()
        .delay(1000)
        .duration(1000)
        .attr('opacity', 1);
    
    const eLabel = g.append('text')
        .attr('x', width - 120)
        .attr('y', yScale(Math.E) - 15)
        .attr('fill', 'orange')
        .style('font-size', '24px')
        .style('opacity', 0)
        .text(`e ≈ ${Math.E.toFixed(5)}`);
    
    eLabel.transition()
        .delay(1500)
        .duration(1000)
        .style('opacity', 1);
    
    // 添加数值表格 - 带动画和公式渲染
    const table = g.append('g')
        .attr('transform', `translate(50, 50)`)
        .style('opacity', 0);
    
    table.append('rect')
        .attr('width', 250)
        .attr('height', 180)
        .attr('fill', 'rgba(255, 255, 255, 0)')
        .attr('stroke', 'black')
        .attr('stroke-width', 2)
        .attr('rx', 5);
    
    const tableValues = [
        { x: 1, y: Math.pow(1 + 1/1, 1) },
        { x: 10, y: Math.pow(1 + 1/10, 10) },
        { x: 100, y: Math.pow(1 + 1/100, 100) },
        { x: 1000, y: Math.pow(1 + 1/1000, 1000) },
        { x: 10000, y: Math.pow(1 + 1/10000, 10000) }
    ];
    
    // 表格标题 - 使用MathJax公式
    const tableTitle = table.append('foreignObject')
        .attr('x', 10)
        .attr('y', 5)
        .attr('width', 230)
        .attr('height', 80);
    
    tableTitle.append('xhtml:div')
        .style('text-align', 'center')
        .style('font-size', '10px')
        .style('font-weight', 'bold')
        .html('$$\\left(1+\\frac{1}{x}\\right)^x$$');
    
    // 表格数据行 - 逐行动画出现
    tableValues.forEach((val, i) => {
        const row = table.append('g')
            .style('opacity', 0);
        
        // x值
        const xLabel = row.append('foreignObject')
            .attr('x', 10)
            .attr('y', 40 + i * 25)
            .attr('width', 80)
            .attr('height', 25);
        
        xLabel.append('xhtml:div')
            .style('font-size', '12px')
            .html(`$$x=${val.x}$$`);
        
        // 分隔符
        row.append('text')
            .attr('x', 90)
            .attr('y', 55 + i * 25)
            .attr('fill', 'black')
            .style('font-size', '12px')
            .text('→');
        
        // 计算结果
        row.append('text')
            .attr('x', 110)
            .attr('y', 55 + i * 25)
            .attr('fill', 'darkgreen')
            .style('font-size', '12px')
            .style('font-weight', 'bold')
            .text(`${val.y.toFixed(6)}`);
        
        // 逐行出现动画
        row.transition()
            .delay(2000 + i * 300)
            .duration(500)
            .style('opacity', 1);
    });
    
    // 表格整体出现动画
    table.transition()
        .delay(1800)
        .duration(500)
        .style('opacity', 1)
        .on('end', () => {
            // 渲染表格中的MathJax
            if (window.MathJax) {
                MathJax.typesetPromise([table.node()]);
            }
        });
    
    // 添加极限值点 - 最后出现
    const limitPoint = g.append('circle')
        .attr('cx', xScale(100))
        .attr('cy', yScale(Math.E))
        .attr('r', 0)
        .attr('fill', 'red')
        .attr('stroke', 'black')
        .attr('stroke-width', 2);
    
    limitPoint.transition()
        .delay(3000)
        .duration(800)
        .attr('r', 8)
        .transition()
        .duration(300)
        .attr('r', 6);
    
    // 添加收敛动画提示
    const convergenceText = g.append('text')
        .attr('x', width / 2)
        .attr('y', height - 35)
        .attr('text-anchor', 'middle')
        .attr('fill', 'darkblue')
        .style('font-size', '16px')
        .style('font-weight', 'bold')
        .style('opacity', 0)
        .text('当 x → ∞ 时，函数值收敛到 e');
    
    convergenceText.transition()
        .delay(3500)
        .duration(1000)
        .style('opacity', 1);
}

// 第11.1页：两个重要极限
function visualizeImportantLimitsDetailed(containerId) {
    const container = getContainer(containerId, 'grid');
    if (!container) {
        console.error('Container vis-important-limits-detailed not found');
        return;
    }

    const limits = [
        { name: '重要极限 I<br>$\\frac{\\sin x}{x}$', fn: x => Math.abs(x) > 0.001 ? Math.sin(x)/x : 1, center: 0, L: 1 },
        { name: '变形 I<br>$\\frac{\\tan x}{x}$', fn: x => Math.abs(x) > 0.001 ? Math.tan(x)/x : 1, center: 0, L: 1 },
        { name: '变形 II<br>$\\frac{1-\\cos x}{x^2}$', fn: x => Math.abs(x) > 0.001 ? (1-Math.cos(x))/(x*x) : 0.5, center: 0, L: 0.5 },
        { name: '变形 III<br>$\\frac{\\sin 2x}{x}$', fn: x => Math.abs(x) > 0.001 ? Math.sin(2*x)/x : 2, center: 0, L: 2 },
        { name: '变形 IV<br>$\\frac{\\arcsin x}{x}$', fn: x => Math.abs(x) > 0.001 && Math.abs(x) <= 1 ? Math.asin(x)/x : 1, center: 0, L: 1 },
        { name: '重要极限 II<br>$\\left(1+\\frac{1}{x}\\right)^x$', fn: x => x > 0.1 ? Math.pow(1+1/x, x) : Math.E, center: Infinity, L: Math.E },
        { name: '变形 I<br>$(1+x)^{\\frac{1}{x}}$', fn: x => Math.abs(x) > 0.01 && x > -1 ? Math.pow(1+x, 1/x) : Math.E, center: 0, L: Math.E },
        { name: '变形 II<br>$\\left(1+\\frac{2}{x}\\right)^x$', fn: x => x > 0.1 ? Math.pow(1+2/x, x) : Math.exp(2), center: Infinity, L: Math.exp(2) },
        { name: '变形 III<br>$\\left(1-\\frac{1}{x}\\right)^x$', fn: x => x > 1 ? Math.pow(1-1/x, x) : 1/Math.E, center: Infinity, L: 1/Math.E },
        { name: '变形 IV<br>$\\frac{\\ln(1+x)}{x}$', fn: x => Math.abs(x) > 0.001 && x > -1 ? Math.log(1+x)/x : 1, center: 0, L: 1 },
        { name: '变形 V<br>$\\frac{e^x-1}{x}$', fn: x => Math.abs(x) > 0.001 ? (Math.exp(x)-1)/x : 1, center: 0, L: 1 },
        { name: '变形 VI<br>$\\frac{2^x-1}{x}$', fn: x => Math.abs(x) > 0.001 ? (Math.pow(2,x)-1)/x : Math.log(2), center: 0, L: Math.log(2) }
    ];

    limits.forEach((limit, i) => {
        const drawFunction = (g, width, height) => {
            let xDomain, data;
            if (limit.center === 0) {
                xDomain = [-1, 1];
                data = d3.range(-1, 1, 0.01).filter(x => Math.abs(x) > 0.01)
                    .map(x => ({x: x, y: limit.fn(x)}));
            } else {
                xDomain = [1, 10];
                data = d3.range(1, 10, 0.1)
                    .map(x => ({x: x, y: limit.fn(x)}));
            }

            const yExtent = d3.extent(data, d => d.y);
            const yScale = d3.scaleLinear()
                .domain([Math.min(yExtent[0] - 0.5, limit.L - 1), Math.max(yExtent[1] + 0.5, limit.L + 1)])
                .range([height, 0]);
            const xScale = d3.scaleLinear().domain(xDomain).range([0, width]);

            drawAxes(g, xScale, yScale, width, height);

            const line = d3.line()
                .x(d => xScale(d.x))
                .y(d => yScale(d.y))
                .defined(d => !isNaN(d.y) && isFinite(d.y));

            const path = g.append('path')
                .datum(data)
                .attr('fill', 'none')
                .attr('stroke', 'var(--primary-color)')
                .attr('stroke-width', 2)
                .attr('d', line);
            animatePath(path, 2000, false);

            // 添加重要极限的特殊动画处理
            setTimeout(() => {
                const approachVal = limit.center === 0 ? 0 : (limit.center === Infinity ? Infinity : limit.center);
                animateLimitApproach(g, xScale, yScale, limit.fn, approachVal, limit.L, width, height);
            }, 100);
        };

        const approachVal = limit.center === 0 ? '0' : (limit.center === Infinity ? '∞' : limit.center.toString());
        const { g, width, height, div } = setup(container, i, limit.name, 'both', approachVal);
        div.__chartData = {
            drawFunction,
            annotationData: {
                type: 'limit',
                isSequence: false,
                approachPoint: limit.center,
                limitValue: limit.L,
                leftLimit: limit.L,
                rightLimit: limit.L
            }
        };
        drawFunction(g, width, height);
    });
}


// 第12页：无穷小与无穷大
function visualizeInfinitesimalInfinity(containerId) {
    const setup = setupD3(containerId);
    if (!setup) return;
    const { g, width, height } = setup;
    
    const xScale = d3.scaleLinear().domain([-2, 2]).range([0, width]);
    const yScale = d3.scaleLinear().domain([-5, 5]).range([height, 0]);
    
    // 坐标轴
    g.append('g')
        .attr('transform', `translate(0, ${yScale(0)})`)
        .call(d3.axisBottom(xScale));
    
    g.append('g')
        .attr('transform', `translate(${xScale(0)}, 0)`)
        .call(d3.axisLeft(yScale));
    
    // 无穷小函数
    const infinitesimals = [
        { fn: x => x, color: '#3498db', label: 'x' },
        { fn: x => x*x, color: '#2ecc71', label: 'x²' },
        { fn: x => x*x*x, color: '#e74c3c', label: 'x³' }
    ];
    
    infinitesimals.forEach(item => {
        const data = d3.range(-2, 2, 0.01)
            .map(x => ({x: x, y: item.fn(x)}))
            .filter(d => !isNaN(d.y) && isFinite(d.y));
        
        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y));
        
        g.append('path')
            .datum(data)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', item.color)
            .attr('stroke-width', 2);
    });
    
    // 无穷大函数 1/x
    const infinityData1 = d3.range(-2, -0.05, 0.01)
        .map(x => ({x: x, y: Math.min(Math.max(1/x, -5), 5)}));
    const infinityData2 = d3.range(0.05, 2, 0.01)
        .map(x => ({x: x, y: Math.min(Math.max(1/x, -5), 5)}));
    
    const line = d3.line()
        .x(d => xScale(d.x))
        .y(d => yScale(d.y));
    
    g.append('path')
        .datum(infinityData1)
        .attr('d', line)
        .attr('fill', 'none')
        .attr('stroke', 'orange')
        .attr('stroke-width', 2);
    
    g.append('path')
        .datum(infinityData2)
        .attr('d', line)
        .attr('fill', 'none')
        .attr('stroke', 'orange')
        .attr('stroke-width', 2);
    
    // 图例
    const legend = g.append('g')
        .attr('transform', `translate(${width - 150}, 30)`);
    
    legend.append('rect')
        .attr('width', 140)
        .attr('height', 120)
        .attr('fill', 'rgba(0, 0, 0, 0.7)')
        .attr('stroke', 'white')
        .attr('rx', 5);
    
    const items = [
        { color: '#3498db', text: 'x (一阶无穷小)' },
        { color: '#2ecc71', text: 'x² (二阶无穷小)' },
        { color: '#e74c3c', text: 'x³ (三阶无穷小)' },
        { color: 'orange', text: '1/x (无穷大)' }
    ];
    
    items.forEach((item, i) => {
        legend.append('line')
            .attr('x1', 10)
            .attr('x2', 30)
            .attr('y1', 25 + i * 25)
            .attr('y2', 25 + i * 25)
            .attr('stroke', item.color)
            .attr('stroke-width', 2);
        
        legend.append('text')
            .attr('x', 35)
            .attr('y', 30 + i * 25)
            .attr('fill', 'white')
            .style('font-size', '11px')
            .text(item.text);
    });
}

// 第13页：无穷小的比较
function visualizeInfinitesimalComparison(containerId) {
    const setup = setupD3(containerId);
    if (!setup) return;
    const { g, width, height } = setup;
    
    const panel = d3.select('#vis-infinitesimal-comparison')
        .append('div')
        .attr('class', 'interactive-panel draggable-panel');
    
    panel.append('h3').text('无穷小阶的比较');
    
    // 添加拖拽功能
    let isDragging = false;
    let dragOffset = { x: 0, y: 0 };
    
    // 鼠标按下事件
    panel.on('mousedown', function(event) {
        // 只在标题区域触发拖拽
        if (event.target.tagName === 'H3') {
            isDragging = true;
            const rect = this.getBoundingClientRect();
            dragOffset.x = event.clientX - rect.left;
            dragOffset.y = event.clientY - rect.top;
            
            // 添加拖拽样式
            d3.select(this).classed('dragging', true);
            
            // 阻止默认行为
            event.preventDefault();
        }
    });
    
    // 鼠标移动事件
    d3.select(document).on('mousemove.drag', function(event) {
        if (isDragging) {
            const panelNode = panel.node();
            const containerRect = panelNode.parentElement.getBoundingClientRect();
            
            // 计算新位置
            let newX = event.clientX - containerRect.left - dragOffset.x;
            let newY = event.clientY - containerRect.top - dragOffset.y;
            
            // 限制在容器范围内
            const panelRect = panelNode.getBoundingClientRect();
            newX = Math.max(0, Math.min(newX, containerRect.width - panelRect.width));
            newY = Math.max(0, Math.min(newY, containerRect.height - panelRect.height));
            
            // 应用新位置
            panelNode.style.left = newX + 'px';
            panelNode.style.top = newY + 'px';
        }
    });
    
    // 鼠标释放事件
    d3.select(document).on('mouseup.drag', function() {
        if (isDragging) {
            isDragging = false;
            d3.select(panel.node()).classed('dragging', false);
        }
    });
    
    // 创建滑块控制x的值
    const sliderContainer = panel.append('div')
        .attr('class', 'slider-container');
    
    sliderContainer.append('label').text('x值: ');
    const valueDisplay = sliderContainer.append('span')
        .attr('class', 'value-display')
        .text('0.5');
    
    const slider = sliderContainer.append('input')
        .attr('type', 'range')
        .attr('class', 'slider')
        .attr('min', '0.01')
        .attr('max', '1')
        .attr('step', '0.01')
        .attr('value', '0.5');
    
    // 比较表格
    const table = panel.append('table')
        .style('width', '100%')
        .style('margin-top', '20px');
    
    const functions = [
        { name: 'x', fn: x => x, order: 1 },
        { name: 'x²', fn: x => x*x, order: 2 },
        { name: 'x³', fn: x => x*x*x, order: 3 },
        { name: 'sin(x)', fn: x => Math.sin(x), order: 1 },
        { name: '1-cos(x)', fn: x => 1 - Math.cos(x), order: 2 }
    ];
    
    // 表头
    const header = table.append('tr');
    header.append('th').text('函数');
    header.append('th').text('值');
    header.append('th').text('阶');
    
    const rows = functions.map(f => {
        const row = table.append('tr');
        row.append('td').text(f.name);
        row.append('td').attr('class', 'value-cell').text('');
        row.append('td').text(f.order);
        return row;
    });
    
    // 图形区域
    const xScale = d3.scaleLinear().domain([0, 1]).range([0, width]);
    const yScale = d3.scaleLinear().domain([0, 1]).range([height - 50, 0]);
    
    // 坐标轴
    g.append('g')
        .attr('transform', `translate(0, ${height - 50})`)
        .call(d3.axisBottom(xScale));
    
    g.append('g')
        .call(d3.axisLeft(yScale));
    
    // 绘制函数
    functions.forEach((f, i) => {
        const data = d3.range(0, 1, 0.01)
            .map(x => ({x: x, y: f.fn(x)}));
        
        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y));
        
        g.append('path')
            .datum(data)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', d3.schemeCategory10[i])
            .attr('stroke-width', 2);
    });
    
    // 更新函数
    function update(x) {
        valueDisplay.text(x);
        
        rows.forEach((row, i) => {
            const value = functions[i].fn(x);
            row.select('.value-cell').text(value.toFixed(6));
        });
        
        // 标记当前x位置
        g.selectAll('.current-line').remove();
        g.append('line')
            .attr('class', 'current-line')
            .attr('x1', xScale(x))
            .attr('x2', xScale(x))
            .attr('y1', 0)
            .attr('y2', height - 50)
            .attr('stroke', 'red')
            .attr('stroke-dasharray', '3,3');
        
        // 标记各函数值
        g.selectAll('.current-point').remove();
        functions.forEach((f, i) => {
            g.append('circle')
                .attr('class', 'current-point')
                .attr('cx', xScale(x))
                .attr('cy', yScale(f.fn(x)))
                .attr('r', 4)
                .attr('fill', d3.schemeCategory10[i]);
        });
    }
    
    slider.on('input', function() {
        update(+this.value);
    });
    
    update(0.5);
}

// 第14页：等价无穷小
function visualizeEquivalentInfinitesimal(containerId) {
    const container = getContainer(containerId, 'grid');
    if (!container) return;
    
    const pairs = [
        { name: '正弦<br>$\\sin x \\sim x$', f1: Math.sin, f2: x => x },
        { name: '正切<br>$\\tan x \\sim x$', f1: Math.tan, f2: x => x },
        { name: '余弦<br>$1-\\cos x \\sim \\frac{x^2}{2}$', f1: x => 1-Math.cos(x), f2: x => x*x/2 },
        { name: '反正弦<br>$\\arcsin x \\sim x$', f1: Math.asin, f2: x => x },
        { name: '反正切<br>$\\arctan x \\sim x$', f1: Math.atan, f2: x => x },
        { name: '指数<br>$e^x-1 \\sim x$', f1: x => Math.exp(x)-1, f2: x => x },
        { name: '对数<br>$\\ln(1+x) \\sim x$', f1: x => Math.log(1+x), f2: x => x },
        { name: '幂函数<br>$(1+x)^2-1 \\sim 2x$', f1: x => Math.pow(1+x, 2)-1, f2: x => 2*x },
        { name: '双曲正弦<br>$\\sinh x \\sim x$', f1: x => Math.sinh(x), f2: x => x },
        { name: '高阶 I<br>$\\sin(x^2) \\sim x^2$', f1: x => Math.sin(x*x), f2: x => x*x },
        { name: '高阶 II<br>$x-\\sin x \\sim \\frac{x^3}{6}$', f1: x => x-Math.sin(x), f2: x => x*x*x/6 },
        { name: '高阶 III<br>$\\tan x-x \\sim \\frac{x^3}{3}$', f1: x => Math.tan(x)-x, f2: x => x*x*x/3 }
    ];
    
    pairs.forEach((pair, i) => {
        const drawFunction = (g, width, height) => {
            const xScale = d3.scaleLinear().domain([-0.5, 0.5]).range([0, width]);
            const yScale = d3.scaleLinear().domain([-0.3, 0.3]).range([height, 0]);

            drawAxes(g, xScale, yScale, width, height);

        const data1 = d3.range(-0.5, 0.5, 0.01)
            .map(x => ({x: x, y: pair.f1(x)}))
            .filter(d => !isNaN(d.y) && isFinite(d.y));
        
        const data2 = d3.range(-0.5, 0.5, 0.01)
            .map(x => ({x: x, y: pair.f2(x)}))
            .filter(d => !isNaN(d.y) && isFinite(d.y));
        
        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y));
        
            const path1 = g.append('path')
            .datum(data1)
            .attr('fill', 'none')
            .attr('stroke', 'var(--primary-color)')
                .attr('stroke-width', 2)
                .attr('d', line);
            animatePath(path1);
        
            const path2 = g.append('path')
            .datum(data2)
            .attr('fill', 'none')
            .attr('stroke', 'var(--accent-color)')
            .attr('stroke-width', 2)
                .attr('stroke-dasharray', '3,3')
                .attr('d', line);
            animatePath(path2);
        };

        const { g, width, height, div } = setup(container, i, pair.name, 'both', 0);
        div.__chartData = {
            drawFunction,
            annotationData: {
                type: 'limit',
                isSequence: false,
                approachPoint: 0,
                limitValue: 1,
                leftLimit: 1,
                rightLimit: 1
            }
        };
        drawFunction(g, width, height);
    });
}


// 第15页：等价无穷小应用
function visualizeEquivalentInfinitesimalApp(containerId) {
    const setup = setupD3(containerId);
    if (!setup) return;
    const { g, width, height } = setup;
    
    const panel = d3.select('#vis-equivalent-infinitesimal-app')
        .append('div')
        .attr('class', 'interactive-panel')
        .style('width', '50%');
    
    panel.append('h3').text('等价无穷小替换应用');
    
    const examples = [
        {
            original: '$$\\lim\\limits_{x \\to 0} \\frac{\\sin 3x \\cdot \\tan 2x}{x^2}$$',
            replaced: '$$\\lim\\limits_{x \\to 0} \\frac{3x \\cdot 2x}{x^2} = 6$$',
            steps: [
                'sin(3x) ~ 3x',
                'tan(2x) ~ 2x',
                '代入得 6'
            ]
        },
        {
            original: '$$\\lim\\limits_{x \\to 0} \\frac{e^x - 1}{\\sin x}$$',
            replaced: '$$\\lim\\limits_{x \\to 0} \\frac{x}{x} = 1$$',
            steps: [
                'e^x - 1 ~ x',
                'sin(x) ~ x',
                '代入得 1'
            ]
        },
        {
            original: '$$\\lim\\limits_{x \\to 0} \\frac{1 - \\cos x}{x^2}$$',
            replaced: '$$\\lim\\limits_{x \\to 0} \\frac{\\frac{x^2}{2}}{x^2} = \\frac{1}{2}$$',
            steps: [
                '1 - cos(x) ~ x²/2',
                '代入得 1/2'
            ]
        },
        {
            original: '$$\\lim\\limits_{x \\to 0} \\frac{\\ln(1+x)}{\\sin x}$$',
            replaced: '$$\\lim\\limits_{x \\to 0} \\frac{x}{x} = 1$$',
            steps: [
                'ln(1+x) ~ x',
                'sin(x) ~ x',
                '代入得 1'
            ]
        },
        {
            original: '$$\\lim\\limits_{x \\to 0} \\frac{\\tan x - x}{x^3}$$',
            replaced: '$$\\lim\\limits_{x \\to 0} \\frac{\\frac{x^3}{3}}{x^3} = \\frac{1}{3}$$',
            steps: [
                'tan(x) - x ~ x³/3',
                '代入得 1/3'
            ]
        }
    ];
    
    let currentExample = 0;
    let autoPlay = true;
    
    // 添加控制按钮
    const buttonContainer = panel.append('div')
        .attr('class', 'button-container');
    
    // 切换按钮
    buttonContainer.append('button')
        .attr('class', 'nav-btn')
        .text('上一个')
        .on('click', () => {
            currentExample = (currentExample - 1 + examples.length) % examples.length;
            showExample();
        });
    
    buttonContainer.append('button')
        .attr('class', 'nav-btn')
        .text('下一个')
        .on('click', () => {
            currentExample = (currentExample + 1) % examples.length;
            showExample();
        });
    
    // 自动播放开关
    buttonContainer.append('button')
        .attr('class', 'nav-btn')
        .text('暂停')
        .on('click', function() {
            autoPlay = !autoPlay;
            d3.select(this).text(autoPlay ? '暂停' : '播放');
            if (autoPlay) {
                showExample();
            }
        });
    
    function showExample() {
        // 清除之前的动画
        currentAnimations.forEach(clear => clear());
        currentAnimations = [];
        
        panel.selectAll('.example-content').remove();
        
        const example = examples[currentExample];
        const content = panel.append('div')
            .attr('class', 'example-content');
        
        // 添加页码显示
        content.append('div')
            .style('text-align', 'center')
            .style('margin-bottom', '15px')
            .style('color', 'var(--accent-color)')
            .style('font-weight', 'bold')
            .text(`例 ${currentExample + 1} / ${examples.length}`);
        
        content.append('div')
            .style('font-size', '1.5rem')
            .style('margin-bottom', '20px')
            .style('text-align', 'center')
            .html(`原式: ${example.original}`);
        
        // 立即渲染数学公式
        if (window.MathJax) {
            MathJax.typesetPromise();
        }
        
        setTimeout(() => {
            content.append('div')
                .attr('class', 'fade-in')
                .style('font-size', '1.3rem')
                .style('margin', '20px 0')
                .style('text-align', 'center')
                .html('应用等价无穷小替换:');
            
            // 步骤只显示一次，不循环
            example.steps.forEach((step, i) => {
                content.append('div')
                    .attr('class', 'fade-in')
                    .style('margin-left', '30px')
                    .style('margin-top', '10px')
                    .style('text-align', 'left')
                    .text(`• ${step}`);
            });
        }, 1000 / globalAnimationSpeed);
        
        setTimeout(() => {
            content.append('div')
                .attr('class', 'fade-in')
                .style('font-size', '1.5rem')
                .style('margin-top', '20px')
                .style('color', 'var(--success-color)')
                .style('text-align', 'center')
                .html(`结果: ${example.replaced}`);
            
            // 重新渲染数学公式
            if (window.MathJax) {
                MathJax.typesetPromise();
            }
        }, 2500 / globalAnimationSpeed);
        
        // 只有在自动播放模式下才继续下一个
        if (autoPlay) {
        currentExample = (currentExample + 1) % examples.length;
        const timeoutId = setTimeout(showExample, 5000 / globalAnimationSpeed);
        currentAnimations.push(() => clearTimeout(timeoutId));
        }
    }
    
    showExample();
}

// 第16页：连续函数
function visualizeContinuousFunctions(containerId) {
    const container = getContainer(containerId, 'grid');
    if (!container) return;
    
    const functions = [
        { name: '多项式<br>$x^3-3x+1$', fn: x => x*x*x - 3*x + 1 },
        { name: '有理函数<br>$\\frac{x^2+1}{x^2+2}$', fn: x => (x*x + 1)/(x*x + 2) },
        { name: '三角函数<br>$\\sin(2x)$', fn: x => Math.sin(2*x) },
        { name: '指数函数<br>$e^{-x^2}$', fn: x => Math.exp(-x*x) },
        { name: '对数函数<br>$\\ln(x+4)$', fn: x => Math.log(x + 4) },
        { name: '双曲函数<br>$\\tanh(x)$', fn: x => Math.tanh(x) },
        { name: '复合三角<br>$\\sin(\\cos x)$', fn: x => Math.sin(Math.cos(x)) },
        { name: '根式函数<br>$\\sqrt{4-x^2}$', fn: x => Math.abs(x) <= 2 ? Math.sqrt(4 - x*x) : undefined },
        { name: '反三角<br>$\\arcsin(x/2)$', fn: x => Math.abs(x) <= 2 ? Math.asin(x/2) : undefined },
        { name: '绝对值<br>$|\\sin x|$', fn: x => Math.abs(Math.sin(x)) },
        { name: '分段连续<br>$\\begin{cases} e^x, x<0 \\\\ 1, x \\ge 0 \\end{cases}$', fn: x => x < 0 ? Math.exp(x) : 1 },
        { name: '光滑曲线<br>$\\frac{x}{1+x^2}$', fn: x => x/(1 + x*x) },
        { name: '周期函数<br>$\\sin x + \\frac{\\sin 2x}{2}$', fn: x => Math.sin(x) + Math.sin(2*x)/2 },
        { name: 'Sigmoid<br>$\\frac{1}{1+e^{-x}}$', fn: x => 1/(1 + Math.exp(-x)) },
        { name: '高斯函数<br>$e^{-x^2/2}$', fn: x => Math.exp(-x*x/2) }
    ];

    functions.forEach((func, i) => {
        const drawFunction = (g, width, height) => {
    const xScale = d3.scaleLinear().domain([-3, 3]).range([0, width]);
    const yScale = d3.scaleLinear().domain([-2, 2]).range([height, 0]);
    
            drawAxes(g, xScale, yScale, width, height);

        const data = d3.range(-3, 3, 0.05)
            .map(x => ({x: x, y: func.fn(x)}))
                .filter(d => !isNaN(d.y) && isFinite(d.y));
        
        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y))
            .curve(d3.curveCatmullRom);
        
        const path = g.append('path')
            .datum(data)
            .attr('fill', 'none')
                .attr('stroke', 'var(--primary-color)')
            .attr('stroke-width', 2)
                .attr('d', line);

            animatePath(path, 2000, false);

            // 为第16页所有项添加双边趋近动画
            setTimeout(() => {
                // 选择一个合适的趋近点，通常选择0或函数定义域内的一个点
                const approachPoint = 0;
                const limitValue = func.fn(approachPoint);
                animateLimitApproach(g, xScale, yScale, func.fn, approachPoint, limitValue, width, height);
            }, 100);
        };

        const { g, width, height, div } = setup(container, i, func.name, 'both', '0');
        div.__chartData = {
            drawFunction,
            annotationData: {
                type: 'continuity',
                isSequence: false,
                approachPoint: 0,
                limitValue: func.fn(0),
                leftLimit: func.fn(0),
                rightLimit: func.fn(0),
                functionValue: func.fn(0)
            }
        };
        drawFunction(g, width, height);
    });
}

// 第17页：间断点类型
function visualizeDiscontinuities(containerId) {
    const container = getContainer(containerId, 'grid');
    if (!container) return;
    
    const discontinuities = [
        {
            name: '可去间断点<br>$\\frac{x^2-1}{x-1}$',
            fn: x => Math.abs(x-1) > 0.01 ? (x*x - 1)/(x - 1) : undefined,
            special: {x: 1, y: 2, type: 'removable'}
        },
        {
            name: '跳跃间断点<br>$\\begin{cases} x+1, x<0 \\\\ x-1, x \\ge 0 \\end{cases}$',
            fn: x => x < 0 ? x + 1 : x - 1,
            special: null
        },
        {
            name: '无穷间断点<br>$1/x^2$',
            fn: x => 1/(x*x),
            special: null
        },
        {
            name: '振荡间断点<br>$\\sin\\left(\\frac{1}{x}\\right)$',
            fn: x => Math.abs(x) > 0.01 ? Math.sin(1/x) : undefined,
            special: null
        },
        {
            name: '混合间断<br>$\\begin{cases} 1/x, x<0 \\\\ \\sqrt{x}, x \\ge 0 \\end{cases}$',
            fn: x => x < 0 ? 1/x : Math.sqrt(x),
            special: null
        },
        {
            name: '周期间断<br>$\\tan x$',
            fn: x => Math.tan(x),
            special: null
        },
        {
            name: '阶梯函数<br>$\\lfloor x \\rfloor$',
            fn: x => Math.floor(x),
            special: null
        },
        {
            name: '符号函数<br>$\\text{sgn}(x)$',
            fn: x => Math.sign(x),
            special: null
        }
    ];
    
    discontinuities.forEach((disc, i) => {
        const drawFunction = (g, width, height) => {
            const xScale = d3.scaleLinear().domain([-2, 2]).range([0, width]);
            const yScale = d3.scaleLinear().domain([-3, 3]).range([height, 0]);

            drawAxes(g, xScale, yScale, width, height);

        const data = d3.range(-2, 2, 0.01)
            .map(x => ({x: x, y: disc.fn(x)}))
            .filter(d => !isNaN(d.y) && isFinite(d.y) && Math.abs(d.y) < 10);
        
        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y));
        
            const path = g.append('path')
            .datum(data)
            .attr('fill', 'none')
            .attr('stroke', 'var(--danger-color)')
                .attr('stroke-width', 2)
                .attr('d', line);
            animatePath(path, 2000, false);

            // 为第17页所有项添加双边趋近动画
            setTimeout(() => {
                let approachPoint = 0; // 默认趋近点
                let limitValue = 0;
                
                // 根据不同的间断点类型设置趋近点
                if (disc.name.includes('可去间断')) {
                    approachPoint = 1;
                    limitValue = 2;
                } else if (disc.name.includes('阶梯函数') || disc.name.includes('符号函数')) {
                    approachPoint = 0;
                    limitValue = 0;
                } else {
                    approachPoint = 0;
                    limitValue = 0;
                }
                
                animateLimitApproach(g, xScale, yScale, disc.fn, approachPoint, limitValue, width, height);
            }, 100);

        if (disc.special && disc.special.type === 'removable') {
                g.append('circle')
                .attr('cx', xScale(disc.special.x))
                .attr('cy', yScale(disc.special.y))
                .attr('r', 4)
                .attr('fill', 'white')
                .attr('stroke', 'var(--danger-color)')
                .attr('stroke-width', 2);
        }
        };

        let discApproachVal = '0';
        if (disc.name.includes('可去间断')) {
            discApproachVal = '1';
        }
        const { g, width, height, div } = setup(container, i, disc.name, 'both', discApproachVal);

        // 根据间断点类型设置注释数据
        let discontinuityType = 'unknown';
        let leftLimit = '不存在', rightLimit = '不存在';
        let approachPoint = disc.name.includes('可去间断') ? 1 : 0;

        if (disc.name.includes('可去间断')) {
            discontinuityType = '可去间断点';
            leftLimit = '2';
            rightLimit = '2';
        } else if (disc.name.includes('跳跃间断')) {
            discontinuityType = '跳跃间断点';
            leftLimit = '1';
            rightLimit = '-1';
        } else if (disc.name.includes('无穷间断')) {
            discontinuityType = '无穷间断点';
            leftLimit = '+∞';
            rightLimit = '+∞';
        } else if (disc.name.includes('振荡间断')) {
            discontinuityType = '振荡间断点';
            leftLimit = '振荡';
            rightLimit = '振荡';
        }

        div.__chartData = {
            drawFunction,
            annotationData: {
                type: 'limit',
                isSequence: false,
                approachPoint: approachPoint,
                limitValue: null,
                leftLimit: leftLimit,
                rightLimit: rightLimit,
                discontinuityType: discontinuityType
            }
        };
        drawFunction(g, width, height);
    });
}

// 第18页：初等函数连续性
function visualizeElementaryFunctions(containerId) {
    const container = getContainer(containerId, 'grid');
    if (!container) return;

    const elementaryFunctions = [
        { name: '常数函数<br>$y = c$', fn: x => 1.5 },
        { name: '幂函数<br>$y = x^2$', fn: x => x*x },
        { name: '幂函数<br>$y = x^3$', fn: x => x*x*x },
        { name: '根式函数<br>$y = \\sqrt[3]{x}$', fn: x => Math.cbrt(x) },
        { name: '倒数函数<br>$y = \\frac{1}{x}$', fn: x => 1/x },
        { name: '指数函数<br>$y = e^x$', fn: x => Math.exp(x) },
        { name: '对数函数<br>$y = \\ln x$', fn: x => Math.log(x) },
        { name: '正弦函数<br>$y = \\sin x$', fn: x => Math.sin(x) },
        { name: '余弦函数<br>$y = \\cos x$', fn: x => Math.cos(x) },
        { name: '正切函数<br>$y = \\tan x$', fn: x => Math.tan(x) },
        { name: '反正弦<br>$y = \\arcsin x$', fn: x => Math.asin(x) },
        { name: '反余弦<br>$y = \\arccos x$', fn: x => Math.acos(x) },
        { name: '反正切<br>$y = \\arctan x$', fn: x => Math.atan(x) },
        { name: '双曲正弦<br>$y = \\sinh x$', fn: x => Math.sinh(x) },
        { name: '双曲余弦<br>$y = \\cosh x$', fn: x => Math.cosh(x) }
    ];

    elementaryFunctions.forEach((func, i) => {
        const drawFunction = (g, width, height) => {
            const xScale = d3.scaleLinear().domain([-3, 3]).range([0, width]);
            const yScale = d3.scaleLinear().domain([-3, 3]).range([height, 0]);

            drawAxes(g, xScale, yScale, width, height);

            const data = d3.range(-3, 3, 0.05)
            .map(x => ({x: x, y: func.fn(x)}))
            .filter(d => !isNaN(d.y) && isFinite(d.y) && Math.abs(d.y) < 10);
        
        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y));
        
            const path = g.append('path')
            .datum(data)
            .attr('fill', 'none')
            .attr('stroke', 'var(--info-color)')
                .attr('stroke-width', 2)
                .attr('d', line);
            animatePath(path, 2000, false);

            // 为第18页所有项添加双边趋近动画
            setTimeout(() => {
                let approachPoint = 0; // 默认趋近点
                let limitValue = func.fn(0);
                
                // 根据不同的函数类型选择合适的趋近点
                if (func.name.includes('对数函数')) {
                    approachPoint = 1; // 对数函数在x=1处
                    limitValue = func.fn(1);
                } else if (func.name.includes('倒数函数')) {
                    approachPoint = 1; // 避开x=0的奇点
                    limitValue = func.fn(1);
                } else if (func.name.includes('反正弦') || func.name.includes('反余弦')) {
                    approachPoint = 0.5; // 在定义域内
                    limitValue = func.fn(0.5);
                } else {
                    approachPoint = 0;
                    limitValue = func.fn(0);
                }
                
                animateLimitApproach(g, xScale, yScale, func.fn, approachPoint, limitValue, width, height);
            }, 100);
        };

        let funcApproachVal = '0';
        if (func.name.includes('对数函数') || func.name.includes('倒数函数')) {
            funcApproachVal = '1';
        } else if (func.name.includes('反正弦') || func.name.includes('反余弦')) {
            funcApproachVal = '0.5';
        }
        const { g, width, height, div } = setup(container, i, func.name, 'both', funcApproachVal);

        // 根据函数类型设置注释数据
        let approachPoint = 0;
        let limitValue = func.fn(0);
        if (func.name.includes('对数函数')) {
            approachPoint = 1;
            limitValue = func.fn(1);
        } else if (func.name.includes('倒数函数')) {
            approachPoint = 1;
            limitValue = func.fn(1);
        } else if (func.name.includes('反正弦') || func.name.includes('反余弦')) {
            approachPoint = 0.5;
            limitValue = func.fn(0.5);
        }

        div.__chartData = {
            drawFunction,
            annotationData: {
                type: 'continuity',
                isSequence: false,
                approachPoint: approachPoint,
                limitValue: limitValue,
                leftLimit: limitValue,
                rightLimit: limitValue,
                functionValue: limitValue
            }
        };
        drawFunction(g, width, height);
    });
}

// 第19页：连续性判定
function visualizeContinuityDetermination(containerId) {
    const container = getContainer(containerId, 'grid');
    if (!container) return;

    const continuityExamples = [
        { name: '连续<br>$\\sin x$', fn: x => Math.sin(x), a: 0, continuous: true },
        { name: '可去间断<br>$\\frac{x^2-1}{x-1}$', fn: x => Math.abs(x-1) > 0.01 ? (x*x-1)/(x-1) : undefined, a: 1, continuous: false, type: 'removable' },
        { name: '跳跃间断<br>$\\begin{cases} x, x<0 \\\\ x+1, x \\ge 0 \\end{cases}$', fn: x => x < 0 ? x : x + 1, a: 0, continuous: false, type: 'jump' },
        { name: '无穷间断<br>$1/x^2$', fn: x => 1/(x*x), a: 0, continuous: false, type: 'infinite' },
        { name: '振荡间断<br>$\\sin(1/x)$', fn: x => Math.abs(x) > 0.01 ? Math.sin(1/x) : undefined, a: 0, continuous: false, type: 'oscillating' },
        { name: '分段连续<br>$\\begin{cases} x^2, x<1 \\\\ 2x-1, x \\ge 1 \\end{cases}$', fn: x => x < 1 ? x*x : 2*x - 1, a: 1, continuous: true },
        { name: '绝对值连续<br>$|x-1|$', fn: x => Math.abs(x - 1), a: 1, continuous: true },
        { name: '指数连续<br>$e^{-x^2}$', fn: x => Math.exp(-x*x), a: 0, continuous: true },
        { name: '对数间断<br>$\\ln x$', fn: x => x > 0 ? Math.log(x) : undefined, a: 0, continuous: false, type: 'infinite' },
        { name: '复合连续<br>$\\sin(\\sqrt{|x|})$', fn: x => Math.sin(Math.sqrt(Math.abs(x))), a: 0, continuous: true }
    ];

    continuityExamples.forEach((example, i) => {
        const drawFunction = (g, width, height) => {
            const xScale = d3.scaleLinear().domain([example.a - 2, example.a + 2]).range([0, width]);
            const yScale = d3.scaleLinear().domain([-3, 3]).range([height, 0]);

            drawAxes(g, xScale, yScale, width, height);

            const data = d3.range(example.a - 2, example.a + 2, 0.02)
            .map(x => ({x: x, y: example.fn(x)}))
                .filter(d => !isNaN(d.y) && isFinite(d.y) && Math.abs(d.y) < 10);
        
        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y));
        
            const color = example.continuous ? 'var(--success-color)' : 'var(--danger-color)';

            const path = g.append('path')
            .datum(data)
            .attr('fill', 'none')
                .attr('stroke', color)
                .attr('stroke-width', 2)
                .attr('d', line);
            animatePath(path, 1500, false);

            // 为第19页所有项添加双边趋近动画
            setTimeout(() => {
                const limitValue = example.continuous ? example.fn(example.a) : (example.type === 'removable' ? 2 : 0);
                animateLimitApproach(g, xScale, yScale, example.fn, example.a, limitValue, width, height);
            }, 100);

        g.append('line')
            .attr('x1', xScale(example.a))
            .attr('y1', 0)
            .attr('x2', xScale(example.a))
                .attr('y2', height)
            .attr('stroke', 'gray')
                .attr('stroke-dasharray', '2,2')
                .attr('opacity', 0.5);

            if (!example.continuous && example.type === 'removable') {
                g.append('circle')
                    .attr('cx', xScale(example.a))
                    .attr('cy', yScale(2))
                    .attr('r', 4)
                    .attr('fill', 'black')
                    .attr('stroke', 'var(--danger-color)')
                    .attr('stroke-width', 2);
            } else if (example.continuous) {
                const pointY = example.fn(example.a);
                if (isFinite(pointY)) {
                    g.append('circle')
                        .attr('cx', xScale(example.a))
                        .attr('cy', yScale(pointY))
                        .attr('r', 3)
                        .attr('fill', 'var(--success-color)');
                }
            }
        };

        const { g, width, height, div } = setup(container, i, example.name, 'both', example.a);

        // 根据连续性设置注释数据
        let limitValue = null;
        let leftLimit = null;
        let rightLimit = null;
        let functionValue = null;

        if (example.continuous) {
            limitValue = example.fn(example.a);
            leftLimit = limitValue;
            rightLimit = limitValue;
            functionValue = limitValue;
        } else {
            if (example.type === 'removable') {
                leftLimit = 2;
                rightLimit = 2;
                limitValue = 2;
                functionValue = null; // 函数值不存在
            } else if (example.type === 'jump') {
                leftLimit = example.a;
                rightLimit = example.a + 1;
                limitValue = null; // 极限不存在
                functionValue = example.a + 1;
            } else if (example.type === 'infinite') {
                leftLimit = '+∞';
                rightLimit = '+∞';
                limitValue = null;
                functionValue = null;
            } else if (example.type === 'oscillating') {
                leftLimit = '振荡';
                rightLimit = '振荡';
                limitValue = null;
                functionValue = null;
            }
        }

        div.__chartData = {
            drawFunction,
            annotationData: {
                type: 'continuity',
                isSequence: false,
                approachPoint: example.a,
                limitValue: limitValue,
                leftLimit: leftLimit,
                rightLimit: rightLimit,
                functionValue: functionValue,
                discontinuityType: example.type || null
            }
        };
        drawFunction(g, width, height);
    });
}

// 第20页：实际应用
function visualizeApplications(containerId) {
    const setup = setupD3(containerId);
    if (!setup) return;
    const { g, width, height } = setup;
    
    // 瞬时速度演示
    const panel = d3.select('#vis-applications')
        .append('div')
        .attr('class', 'interactive-panel');
    
    panel.append('h3').text('极限在实际中的应用');
    
    const applications = [
        { name: '瞬时速度', icon: '🚗' },
        { name: '边际成本', icon: '💰' },
        { name: '图像压缩', icon: '🖼️' }
    ];
    
    const buttonContainer = panel.append('div')
        .attr('class', 'button-container');
    applications.forEach((app, i) => {
        buttonContainer.append('button')
            .attr('class', 'nav-btn')
            .text(`${app.icon} ${app.name}`)
            .on('click', () => showApplication(i));
    });
    
    function showApplication(index) {
        g.selectAll('*').remove();
        
        if (index === 0) {
            // 瞬时速度
            const xScale = d3.scaleLinear().domain([0, 5]).range([0, width]);
            const yScale = d3.scaleLinear().domain([0, 130]).range([height - 50, 0]);
            
            g.append('g')
                .attr('transform', `translate(0, ${height - 50})`)
                .call(d3.axisBottom(xScale).tickFormat(d => d + 's'));
            
            g.append('g')
                .call(d3.axisLeft(yScale).tickFormat(d => d + 'm'));
            
            // 位置函数 s(t) = 5t²
            const positionData = d3.range(0, 5, 0.05)
                .map(t => ({t: t, s: 5 * t * t}));
            
            const line = d3.line()
                .x(d => xScale(d.t))
                .y(d => yScale(d.s));
            
            g.append('path')
                .datum(positionData)
                .attr('d', line)
                .attr('fill', 'none')
                .attr('stroke', 'cyan')
                .attr('stroke-width', 3);
            
            // 移动的点
            let t = 0;
            const point = g.append('circle')
                .attr('r', 6)
                .attr('fill', 'red');
            
            const velocityText = g.append('text')
                .attr('x', width - 150)
                .attr('y', 30)
                .attr('fill', 'black')
                .style('font-size', '16px');
            
            function animate() {
                t = (t + 0.02) % 5;
                const s = 5 * t * t;
                const v = 10 * t; // 导数
                
                point
                    .attr('cx', xScale(t))
                    .attr('cy', yScale(s));
                
                velocityText.text(`速度: ${v.toFixed(1)} m/s`);
                
                requestAnimationFrame(animate);
            }
            
            animate();
            currentAnimations.push(() => {});
            
        } else if (index === 1) {
            // 边际成本
            const xScale = d3.scaleLinear().domain([0, 100]).range([0, width]);
            const yScale = d3.scaleLinear().domain([0, 300]).range([height - 50, 0]);
            
            g.append('g')
                .attr('transform', `translate(0, ${height - 50})`)
                .call(d3.axisBottom(xScale).tickFormat(d => d + '个'));
            
            g.append('g')
                .call(d3.axisLeft(yScale).tickFormat(d => '$' + d));
            
            // 成本函数 C(x) = 100 + 2x + 0.01x²
            const costData = d3.range(0, 100, 1)
                .map(x => ({x: x, c: 100 + 2*x + 0.01*x*x}));
            
            const line = d3.line()
                .x(d => xScale(d.x))
                .y(d => yScale(d.c));
            
            g.append('path')
                .datum(costData)
                .attr('d', line)
                .attr('fill', 'none')
                .attr('stroke', 'lime')
                .attr('stroke-width', 3);
            
            g.append('text')
                .attr('x', width / 2)
                .attr('y', 30)
                .attr('text-anchor', 'middle')
                .attr('fill', 'black')
                .text('成本函数: C(x) = 100 + 2x + 0.01x²');
            
        } else if (index === 2) {
            // 图像压缩
            const steps = 10;
            const imageSize = 100;
            
            for (let i = 0; i <= steps; i++) {
                const quality = i / steps;
                const x = (width / (steps + 1)) * (i + 0.5);
                const y = height / 2;
                
                const rect = g.append('rect')
                    .attr('x', x - imageSize/2)
                    .attr('y', y - imageSize/2)
                    .attr('width', imageSize)
                    .attr('height', imageSize)
                    .attr('fill', d3.interpolateViridis(quality))
                    .attr('opacity', 0.3 + quality * 0.7);
                
                g.append('text')
                    .attr('x', x)
                    .attr('y', y + imageSize/2 + 20)
                    .attr('text-anchor', 'middle')
                    .attr('fill', 'black')
                    .style('font-size', '12px')
                    .text(`${(quality * 100).toFixed(0)}%`);
            }
            
            g.append('text')
                .attr('x', width / 2)
                .attr('y', 30)
                .attr('text-anchor', 'middle')
                .attr('fill', 'black')
                .text('渐进式图像压缩：质量逐步逼近原图');
        }
    }
    
    showApplication(0);
}

// 第21页：总结
function visualizeSummary(containerId) {
    const setup = setupD3(containerId);
    if (!setup) return;
    const { g, width, height } = setup;
    
    // 创建思维导图
    const centerX = width / 2;
    const centerY = height / 2;
    
    // 中心节点
    const center = g.append('g')
        .attr('transform', `translate(${centerX}, ${centerY})`);
    
    center.append('circle')
        .attr('r', 0)
        .attr('fill', 'var(--primary-color)')
        .transition()
        .duration(500)
        .attr('r', 60);
    
    center.append('text')
        .attr('text-anchor', 'middle')
        .attr('dy', '0.3em')
        .attr('fill', 'black')
        .style('font-size', '24px')
        .style('font-weight', 'bold')
        .style('opacity', 0)
        .text('极限')
        .transition()
        .delay(500)
        .duration(500)
        .style('opacity', 1);
    
    // 分支
    const branches = [
        { angle: 0, text: '数列极限', color: '#3498db', detail: 'n→∞' },
        { angle: Math.PI/3, text: '函数极限', color: '#2ecc71', detail: 'x→a' },
        { angle: 2*Math.PI/3, text: '左右极限', color: '#e74c3c', detail: '单侧' },
        { angle: Math.PI, text: '运算法则', color: '#f39c12', detail: '四则' },
        { angle: 4*Math.PI/3, text: '重要极限', color: '#9b59b6', detail: '两个' },
        { angle: 5*Math.PI/3, text: '连续性', color: '#1abc9c', detail: '三条件' }
    ];
    
    branches.forEach((branch, i) => {
        const x = Math.cos(branch.angle) * 200;
        const y = Math.sin(branch.angle) * 200;
        
        // 连线
        const line = g.append('line')
            .attr('x1', centerX)
            .attr('y1', centerY)
            .attr('x2', centerX)
            .attr('y2', centerY)
            .attr('stroke', branch.color)
            .attr('stroke-width', 3)
            .style('opacity', 0);
        
        line.transition()
            .delay(1000 + i * 200)
            .duration(500)
            .attr('x2', centerX + x)
            .attr('y2', centerY + y)
            .style('opacity', 1);
        
        // 节点
        const node = g.append('g')
            .attr('transform', `translate(${centerX + x}, ${centerY + y})`)
            .style('opacity', 0);
        
        node.append('circle')
            .attr('r', 40)
            .attr('fill', branch.color);
        
        node.append('text')
            .attr('text-anchor', 'middle')
            .attr('dy', '-0.2em')
            .attr('fill', 'black')
            .style('font-size', '14px')
            .style('font-weight', 'bold')
            .text(branch.text);
        
        node.append('text')
            .attr('text-anchor', 'middle')
            .attr('dy', '1.2em')
            .attr('fill', 'black')
            .style('font-size', '11px')
            .text(branch.detail);
        
        node.transition()
            .delay(1500 + i * 200)
            .duration(500)
            .style('opacity', 1);
    });
    
    // 添加总结文字
    const summaryText = g.append('text')
        .attr('x', centerX)
        .attr('y', height - 30)
        .attr('text-anchor', 'middle')
        .attr('fill', 'black')
        .style('font-size', '16px')
        .style('opacity', 0)
        .text('极限是微分的基础，连续是积分的前提！');
    
    summaryText.transition()
        .delay(3000)
        .duration(1000)
        .style('opacity', 1);
}


    // 浮动菜单功能
    document.addEventListener('DOMContentLoaded', function() {
        const menuToggle = document.getElementById('menu-toggle');
        const menuContent = document.getElementById('menu-content');
        
        if (menuToggle && menuContent) {
            menuToggle.addEventListener('click', function(e) {
                e.stopPropagation();
                menuToggle.classList.toggle('active');
                menuContent.classList.toggle('active');
            });
            
            // 点击页面其他地方关闭菜单
            document.addEventListener('click', function(e) {
                if (!menuToggle.contains(e.target) && !menuContent.contains(e.target)) {
                    menuToggle.classList.remove('active');
                    menuContent.classList.remove('active');
                }
            });
            
            // 防止菜单内容点击时关闭菜单
            menuContent.addEventListener('click', function(e) {
                e.stopPropagation();
            });
        }

        // 章节目录菜单功能
        const chapterToggle = document.getElementById('chapter-toggle');
        const chapterContent = document.getElementById('chapter-content');
        
        if (chapterToggle && chapterContent) {
            chapterToggle.addEventListener('click', function(e) {
                e.stopPropagation();
                chapterToggle.classList.toggle('active');
                chapterContent.classList.toggle('active');
            });
            
            // 点击页面其他地方关闭菜单
            document.addEventListener('click', function(e) {
                if (!chapterToggle.contains(e.target) && !chapterContent.contains(e.target)) {
                    chapterToggle.classList.remove('active');
                    chapterContent.classList.remove('active');
                }
            });
            
            // 防止菜单内容点击时关闭菜单
            chapterContent.addEventListener('click', function(e) {
                e.stopPropagation();
            });
        }
    });

    // 章节目录菜单切换函数
    function toggleChapterMenu() {
        const chapterToggle = document.getElementById('chapter-toggle');
        const chapterContent = document.getElementById('chapter-content');
        
        if (chapterToggle && chapterContent) {
            chapterToggle.classList.toggle('active');
            chapterContent.classList.toggle('active');
        }
    }
</script>
<!-- 浮动菜单按钮 -->
<div id="floating-menu">
<div class="menu-toggle" id="menu-toggle">
<span class="menu-icon">☰</span>
</div>
<div class="menu-content" id="menu-content">
<a class="menu-item" href="../网页资源/lab 2-1.html" target="_blank">
<span class="menu-icon">LAB</span>
<span class="menu-text">图像压缩与数列极限实验室</span>
</a>
<a class="menu-item" href="../网页资源/lab 2-2.html" target="_blank">
<span class="menu-icon">LAB</span>
<span class="menu-text">数列极限案例探索实验室</span>
</a>
<a class="menu-item" href="../网页资源/lab 2-3.html" target="_blank">
<span class="menu-icon">LAB</span>
<span class="menu-text">函数极限与自变量变化实验室</span>
</a>
<a class="menu-item" href="../网页资源/lab 2-4.html" target="_blank">
<span class="menu-icon">LAB</span>
<span class="menu-text">左右极限与存在性判定实验室</span>
</a>
<a class="menu-item" href="../网页资源/lab 2-5.html" target="_blank">
<span class="menu-icon">LAB</span>
<span class="menu-text">无穷大与无穷小倒数关系实验室</span>
</a>
<a class="menu-item" href="../网页资源/lab 2-6.html" target="_blank">
<span class="menu-icon">LAB</span>
<span class="menu-text">重要极限实验室</span>
</a>
<a class="menu-item" href="../网页资源/lab 2-7.html" target="_blank">
<span class="menu-icon">LAB</span>
<span class="menu-text">无穷小比较实验室</span>
</a>
<a class="menu-item" href="../网页资源/lab 2-8.html" target="_blank">
<span class="menu-icon">LAB</span>
<span class="menu-text">函数增量实验室</span>
</a>
<a class="menu-item" href="../网页资源/lab 2-9.html" target="_blank">
<span class="menu-icon">LAB</span>
<span class="menu-text">等价无穷小倒水游戏</span>
</a>
<a class="menu-item" href="../网页资源/lab 2-10.html" target="_blank">
<span class="menu-icon">LAB</span>
<span class="menu-text">连续与间断游戏</span>
</a>
<a class="menu-item" href="../网页资源/lab 2-11.html" target="_blank">
<span class="menu-icon">LAB</span>
<span class="menu-text">函数连续性实验室</span>
</a>
<a class="menu-item" href="../网页资源/lab 2-12.html" target="_blank">
<span class="menu-icon">LAB</span>
<span class="menu-text">函数间断点实验室</span>
</a>
<a class="menu-item" href="../网页资源/lab 2-13.html" target="_blank">
<span class="menu-icon">LAB</span>
<span class="menu-text">极限与连续游戏</span>
</a>
<a class="menu-item" href="../习题/assets/limit.html" target="_blank">
<span class="menu-icon">EXER</span>
<span class="menu-text">习题练习</span>
</a>
</div>
</div>
<!-- 章节目录菜单 -->
<div id="chapter-menu">
<div class="menu-toggle" id="chapter-toggle">
<span class="menu-icon">📚</span>
</div>
<div class="menu-content" id="chapter-content">
<a class="menu-item" href="#" onclick="scrollToStep('intro'); toggleChapterMenu();">
<span class="menu-icon">🏠</span>
<span class="menu-text">标题页</span>
</a>
<a class="menu-item" href="#" onclick="scrollToStep('toc'); toggleChapterMenu();">
<span class="menu-icon">📋</span>
<span class="menu-text">目录</span>
</a>
<a class="menu-item" href="#" onclick="scrollToStep('why-limit'); toggleChapterMenu();">
<span class="menu-icon">1</span>
<span class="menu-text">为什么要学极限？</span>
</a>
<a class="menu-item" href="#" onclick="scrollToStep('intuitive-limit'); toggleChapterMenu();">
<span class="menu-icon">2</span>
<span class="menu-text">什么是极限？</span>
</a>
<a class="menu-item" href="#" onclick="scrollToStep('convergent-sequences'); toggleChapterMenu();">
<span class="menu-icon">3</span>
<span class="menu-text">数列极限（收敛）</span>
</a>
<a class="menu-item" href="#" onclick="scrollToStep('divergent-sequences'); toggleChapterMenu();">
<span class="menu-icon">4</span>
<span class="menu-text">数列极限（发散）</span>
</a>
<a class="menu-item" href="#" onclick="scrollToStep('sequence-calculation'); toggleChapterMenu();">
<span class="menu-icon">5</span>
<span class="menu-text">数列极限的计算方法</span>
</a>
<a class="menu-item" href="#" onclick="scrollToStep('function-limits'); toggleChapterMenu();">
<span class="menu-icon">6</span>
<span class="menu-text">函数的极限</span>
</a>
<a class="menu-item" href="#" onclick="scrollToStep('one-sided-limits'); toggleChapterMenu();">
<span class="menu-icon">7</span>
<span class="menu-text">左极限与右极限</span>
</a>
<a class="menu-item" href="#" onclick="scrollToStep('one-sided-detailed'); toggleChapterMenu();">
<span class="menu-icon">8</span>
<span class="menu-text">左右极限详细演示</span>
</a>
<a class="menu-item" href="#" onclick="scrollToStep('limit-operations'); toggleChapterMenu();">
<span class="menu-icon">9</span>
<span class="menu-text">极限的四则运算法则</span>
</a>
<a class="menu-item" href="#" onclick="scrollToStep('limit-methods-detailed'); toggleChapterMenu();">
<span class="menu-icon">10</span>
<span class="menu-text">极限运算方法</span>
</a>
<a class="menu-item" href="#" onclick="scrollToStep('limit-methods'); toggleChapterMenu();">
<span class="menu-icon">11</span>
<span class="menu-text">极限计算技巧</span>
</a>
<a class="menu-item" href="#" onclick="scrollToStep('important-limit-1'); toggleChapterMenu();">
<span class="menu-icon">12</span>
<span class="menu-text">第一重要极限</span>
</a>
<a class="menu-item" href="#" onclick="scrollToStep('important-limit-2'); toggleChapterMenu();">
<span class="menu-icon">13</span>
<span class="menu-text">第二重要极限</span>
</a>
<a class="menu-item" href="#" onclick="scrollToStep('important-limits-detailed'); toggleChapterMenu();">
<span class="menu-icon">14</span>
<span class="menu-text">两个重要极限</span>
</a>
<a class="menu-item" href="#" onclick="scrollToStep('infinitesimal-infinity'); toggleChapterMenu();">
<span class="menu-icon">15</span>
<span class="menu-text">无穷小与无穷大</span>
</a>
<a class="menu-item" href="#" onclick="scrollToStep('infinitesimal-comparison'); toggleChapterMenu();">
<span class="menu-icon">16</span>
<span class="menu-text">无穷小的比较</span>
</a>
<a class="menu-item" href="#" onclick="scrollToStep('equivalent-infinitesimal'); toggleChapterMenu();">
<span class="menu-icon">17</span>
<span class="menu-text">常用等价无穷小</span>
</a>
<a class="menu-item" href="#" onclick="scrollToStep('equivalent-infinitesimal-app'); toggleChapterMenu();">
<span class="menu-icon">18</span>
<span class="menu-text">等价无穷小应用技巧</span>
</a>
<a class="menu-item" href="#" onclick="scrollToStep('continuous-functions'); toggleChapterMenu();">
<span class="menu-icon">19</span>
<span class="menu-text">函数的连续性</span>
</a>
<a class="menu-item" href="#" onclick="scrollToStep('discontinuities'); toggleChapterMenu();">
<span class="menu-icon">20</span>
<span class="menu-text">间断点的分类</span>
</a>
<a class="menu-item" href="#" onclick="scrollToStep('elementary-functions'); toggleChapterMenu();">
<span class="menu-icon">21</span>
<span class="menu-text">初等函数的连续性</span>
</a>
<a class="menu-item" href="#" onclick="scrollToStep('continuity-determination'); toggleChapterMenu();">
<span class="menu-icon">22</span>
<span class="menu-text">连续性的判定与应用</span>
</a>
<a class="menu-item" href="#" onclick="scrollToStep('applications'); toggleChapterMenu();">
<span class="menu-icon">23</span>
<span class="menu-text">极限的实际应用</span>
</a>
<a class="menu-item" href="#" onclick="scrollToStep('summary'); toggleChapterMenu();">
<span class="menu-icon">24</span>
<span class="menu-text">章节总结</span>
</a>
</div>
</div>
</body>
</html>
