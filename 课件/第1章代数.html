<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>第一章：函数基础 (交互式课件)</title>
    <script src="../common-assets/js/d3-7.8.5.min.js"></script>
    <!-- 使用统一的MathJax配置文件，避免配置冲突 -->
     
       <script src="../common-assets/js/mathjax-config.js"></script>
       <script type="text/javascript" id="MathJax-script" async
               src="../common-assets/js/mathjax-3.2.2-tex-svg.min.js">
       </script>
   

    <style>
        @import url('../common-assets/css/fonts.css');

        :root {
            --chalkboard-bg: transparent;
            --chalk-text: #ecf0f1;
            --visualization-bg: #fdfdfd00;
            --primary-color: #3498db;
            --accent-color: #e67e22;
            --success-color: #2ecc71;
            --danger-color: #e74c3c;
            --warning-color: #f39c12;
            --info-color: #9b59b6;
            --text-color: #34495e;
            --heading-font: 'Noto Serif SC', serif;
            --handwriting-font: 'Noto Serif SC', serif;
        }

        body {
            font-family: var(--heading-font);

            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            overflow: auto;
            height: 100vh;
            width: 100vw;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 0;
        }
        #presentation-container {
            width: 100vw;
            height: 100vh;
            max-width: 100vw;
            aspect-ratio: 16 / 9;
            position: relative;
            background: rgba(255, 255, 255, 0);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            overflow: auto;
        }

        .slide {
            position: absolute;
            width: 100%;
            height: 100%;
            opacity: 0;
            visibility: hidden;
            display: flex;
            transition: opacity 0.6s ease-in-out;
        }

        .slide.active {
            opacity: 1;
            visibility: visible;
            z-index: 10;
        }

        /* iframe容器样式 */
        .iframe-container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        .iframe-nav-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1000;
            pointer-events: none;  /* 完全禁用事件，让iframe内容可交互 */
            background: transparent;
        }

        /* 添加导航提示 */
        .iframe-nav-hint {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 1002;
            pointer-events: none;
        }

        .chalkboard {
            flex: 0 0 35%;
            background-color: #2c3e50 !important;
            background-image: url('../common-assets/images/black-felt.png');
            border: 10px solid #8B4513; /* 木质边框 */
            box-shadow: 0 10px 20px rgba(0,0,0,0.5), inset 0 0 15px rgba(0,0,0,0.7);
            color: var(--chalk-text, #f0f0f0);
            padding: 10px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            overflow-y: auto;
            box-sizing: border-box;
        }

        .chalkboard h2 {
            font-family: var(--handwriting-font);
            font-size: 2.2rem;
            color: #f1c40f;
            border-bottom: 2px solid rgba(241, 196, 15, 0.5);
            padding-bottom: 2px;
            margin-bottom:3px;
        }

        .chalkboard h3 {
            font-family: var(--handwriting-font);
            font-size: 1.5rem;
            color: var(--primary-color);
            margin-top: 5px;
            margin-bottom: 5px;
        }

        .chalkboard p, .chalkboard li {
            font-size: 1.1rem;
            line-height: 1.7;
            margin-bottom: 15px;
        }
        .chalkboard ol {
            padding-left: 25px;
        }

        .chalkboard ul {
            list-style-type: '→ ';
            padding-left: 20px;
        }

        .math-formula {
            font-size: 1.3rem;
            color: #1abc9c;
            background: rgba(0,0,0,0.2);
            padding: 15px;
            border-radius: 5px;
            text-align: center;
            margin: 15px 0;
            line-height: 1.5;
        }

        .highlight {
            color: var(--warning-color);
            font-weight: bold;
        }

        .visualization {
            flex: 1;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: auto;
            position: relative;
            box-sizing: border-box;
          
        }

        .visualization.full-width {
             background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
        }
        .visualization.white-bg {
            background: white;
        }

        .value-display {
            position: absolute;
            top: 150px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            min-width: 150px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .value-item {
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .value-item:last-child {
            margin-bottom: 0;
        }

        .value-label {
            font-size: 12px;
            color: #ccc;
            margin-right: 10px;
        }

        .value-number {
            font-size: 14px;
            font-weight: bold;
            color: #fff;
            text-align: right;
        }


        .vis-container {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .vis-title {
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--text-color);
            margin-bottom: 10px;
        }

        .formula-rule {
            font-size: 1.2rem;
            color: #16a085;
            background: rgba(0,0,0,0.15);
            padding: 12px;
            border-radius: 5px;
            margin: 10px 0;
        }

        /* 历史页面样式 */
        .main-title {
            position: absolute;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 36px;
            color: #ffd700;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
            animation: glow 2s ease-in-out infinite alternate;
            z-index: 20;
        }

        @keyframes glow {
            from { text-shadow: 0 0 20px rgba(255, 215, 0, 0.5); }
            to { text-shadow: 0 0 30px rgba(255, 215, 0, 0.8), 0 0 40px rgba(255, 215, 0, 0.6); }
        }

        .clock-container {
            width: 600px;
            height: 600px;
            position: relative;
            margin: auto;
        }

        .event-marker {
            position: absolute;
            width: 120px;
            height: 120px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transform: scale(0);
            transition: all 0.3s ease-out;
        }

        .event-marker.active {
            opacity: 1;
            transform: scale(1);
        }

        .event-icon {
            width: 70px;
            height: 70px;
            background: rgba(255, 255, 255, 0.1);
            border: 3px solid #ffd700;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            margin-bottom: 12px;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        .event-year {
            color: #ffd700;
            font-size: 16px;
            font-weight: bold;
        }

        .event-name {
            color: white;
            font-size: 14px;
            text-align: center;
            max-width: 140px;
        }

        .center-clock {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 540px;
            height: 540px;
            border: 1px solid #ffd700;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 6px;
            color: #ffd700;
            background: rgba(0, 0, 0, 0);
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.3);
        }

        .floating-quote {
            position: absolute;
            color: #ffd700;
            font-size: 18px;
            max-width: 350px;
            opacity: 0;
        }

        .world-label { font-size: 20px; font-weight: bold; fill: #2c3e50; }
        .world-description { font-size: 14px; fill: #7f8c8d; }
        .axis-label { font-size: 12px; fill: #34495e; }
        .operation-box { fill: white; stroke: #3498db; stroke-width: 2; rx: 8; filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1)); }
        .result-box { fill: #2ecc71; stroke: #27ae60; stroke-width: 2; rx: 8; filter: drop-shadow(0 3px 6px rgba(46,204,113,0.3));}
        .transformation-arrow { stroke: #9b59b6; stroke-width: 2; stroke-dasharray: 5,5; fill: none; animation: dash 20s linear infinite; }
        @keyframes dash { to { stroke-dashoffset: -100; } }
        .number-node { transition: all 0.3s ease; }
        .number-node:hover { transform: scale(1.2); }
        .highlight-path { stroke-width: 3; filter: drop-shadow(0 0 6px currentColor); }

        .animation-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            align-items: center;
            gap: 15px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 20px;
            z-index: 101;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 25px;
        }

        .animation-controls.active { display: flex; }
        .control-btn { width: 35px; height: 35px; border: none; border-radius: 50%; background: #3498db; color: white; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 14px; transition: all 0.3s ease; box-shadow: 0 2px 8px rgba(52, 152, 219, 0.3); }
        .control-btn:hover { background: #2980b9; transform: translateY(-2px); box-shadow: 0 4px 12px rgba(52, 152, 219, 0.5); }
        .control-btn.play-pause { width: 45px; height: 45px; background: #e74c3c; font-size: 16px; }
        .control-btn.play-pause:hover { background: #c0392b; }
        .control-btn.paused { background: #27ae60; }
        .control-btn.paused:hover { background: #229954; }
        .speed-indicator { font-size: 14px; font-weight: bold; color: #2c3e50; min-width: 40px; text-align: center; }

        .page-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 14px;
            z-index: 100;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }



        .nav-hint {
            position: absolute;
            top: 60px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 12px;
            border-radius: 15px;
            font-size: 12px;
            z-index: 100;
            opacity: 0.8;
            backdrop-filter: blur(10px);
        }

        /* 翻页按钮样式 */
        .nav-buttons {
            position: absolute;
            top: 60px;
            right: 20px;
            display: flex;
            gap: 5px;
            z-index: 100;
        }

        .nav-btn {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 4px 8px;
            border-radius: 15px;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            user-select: none;
            min-width: 30px;
            text-align: center;
        }

        .nav-btn:hover {
            background: rgba(0, 0, 0, 0.8);
            border-color: rgba(255, 255, 255, 0.6);
            transform: translateY(-1px);
        }

        .nav-btn:active {
            transform: translateY(0);
            background: rgba(0, 0, 0, 0.9);
        }

        .nav-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
        }

        .nav-btn:disabled:hover {
            background: rgba(0, 0, 0, 0.6);
            border-color: rgba(255, 255, 255, 0.3);
            transform: none;
        }

        @keyframes twinkle { 0%, 100% { opacity: 0.3; } 50% { opacity: 1; } }
        .pulse { animation: pulse 2s ease-in-out infinite; }
        @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }

        /* 复合函数可视化样式 */
        .composite-container {
            font-family: 'JetBrains Mono', 'Noto Sans TC', monospace;
            background-color: #f8fafc;
            color: #1f2937;
            background-image:
                linear-gradient(rgba(0,0,0,0.04) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0,0,0,0.04) 1px, transparent 1px);
            background-size: 20px 20px;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 2rem;
        }
        .scope {
            transition: all 0.8s cubic-bezier(0.4, 0, 0.2, 1);
            border-width: 2px;
            border-style: solid;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            display: inline-block;
            white-space: nowrap;
        }
        .scope-f {
            border-color: #dc2626;
            background-color: rgba(220, 38, 38, 0.05);
        }
        .scope-g {
            border-color: #2563eb;
            background-color: rgba(37, 99, 235, 0.05);
        }
        .highlight-g {
            box-shadow: 0 0 20px rgba(37, 99, 235, 0.4);
        }
        .highlight-f {
            box-shadow: 0 0 20px rgba(220, 38, 38, 0.4);
        }
        .composite-fade-in {
            animation: compositeFadeIn 0.5s ease-in-out forwards;
        }
        .composite-fade-out {
            animation: compositeFadeOut 0.8s ease-in-out forwards;
        }
        .composite-shrink-out {
            animation: compositeShrinkOut 0.8s cubic-bezier(0.4, 0, 0.2, 1) forwards;
        }
        @keyframes compositeFadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes compositeFadeOut {
            from { opacity: 1; transform: scale(1); }
            to { opacity: 0; transform: scale(0.8); }
        }
        @keyframes compositeShrinkOut {
            from { opacity: 1; transform: scale(1); padding: 0.5rem 1rem; }
            to { opacity: 0; transform: scale(0); padding: 0; margin: 0; width:0; height:0; }
        }
        .composite-moving-element {
            position: absolute;
            transition: all 0.8s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 100;
        }

        /* 全局动画控制面板 - 简约透明设计 */
        .global-animation-controls {
            position: fixed;
            bottom: 30px;
            right: 30px;
            display: flex;
            gap: 8px;
            z-index: 1000;
        }

        .global-control-btn {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.8);
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: normal;
            transition: all 0.2s ease;
            backdrop-filter: blur(5px);
            min-width: 50px;
            text-align: center;
        }

        .global-control-btn:hover {
            background: rgba(0, 0, 0, 0.5);
            color: rgba(255, 255, 255, 1);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .global-control-btn:active {
            transform: scale(0.95);
        }

        .global-control-btn.pause {
            background: rgba(255, 107, 107, 0.3);
            border-color: rgba(255, 107, 107, 0.4);
        }

        .global-control-btn.pause:hover {
            background: rgba(255, 107, 107, 0.5);
        }

        /* 首页导航按钮样式 */
        .home-nav-buttons {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 40px;
            flex-wrap: wrap;
        }

        .nav-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            text-decoration: none;
            color: white;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            min-width: 120px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .nav-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-5px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }

        .nav-btn .btn-icon {
            font-size: 1.2rem;
            margin-bottom: 8px;
            font-weight: bold;
            letter-spacing: 1px;
        }

        .nav-btn .btn-text {
            font-size: 1.1rem;
            font-weight: 500;
        }

        /* 不同按钮的特殊颜色 */
        .home-btn:hover {
            background: rgba(52, 152, 219, 0.3);
            border-color: rgba(52, 152, 219, 0.6);
        }

        .story-btn:hover {
            background: rgba(155, 89, 182, 0.3);
            border-color: rgba(155, 89, 182, 0.6);
        }

        .exercise-btn:hover {
            background: rgba(46, 204, 113, 0.3);
            border-color: rgba(46, 204, 113, 0.6);
        }

        .resource-btn:hover {
            background: rgba(230, 126, 34, 0.3);
            border-color: rgba(230, 126, 34, 0.6);
        }

        /* 响应式设计 */
        @media (max-width: 768px) {
            .home-nav-buttons {
                gap: 15px;
                margin-top: 30px;
            }
            
            .nav-btn {
                padding: 12px 16px;
                min-width: 100px;
            }
            
            .nav-btn .btn-icon {
                font-size: 1rem;
            }
            
            .nav-btn .btn-text {
                font-size: 1rem;
            }
        }

        /* 浮动菜单样式 */
        #floating-menu {
            position: fixed;
            bottom: 20px;
            right: 200px;
            z-index: 9999;
            font-family: var(--heading-font);
        }

        /* 章节目录菜单样式 */
        #chapter-menu {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 9999;
            font-family: var(--heading-font);
        }

        .menu-toggle {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.8);
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: normal;
            transition: all 0.2s ease;
            backdrop-filter: blur(5px);
            min-width: 50px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .menu-toggle:hover {
            background: rgba(0, 0, 0, 0.5);
            color: rgba(255, 255, 255, 1);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .menu-toggle:active {
            transform: scale(0.95);
        }

        .menu-toggle .menu-icon {
            font-size: 12px;
            font-weight: normal;
            transition: transform 0.3s ease;
        }

        .menu-toggle.active .menu-icon {
            transform: rotate(45deg);
        }

        .menu-content {
            position: absolute;
            bottom: 50px;
            right: 0;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 10px 0;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            opacity: 0;
            visibility: hidden;
            transform: translateY(20px);
            transition: all 0.3s ease;
            min-width: 220px;
            max-height: 400px;
            overflow-y: auto;
        }

        .menu-content.active {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        /* 自定义滚动条样式 */
        .menu-content::-webkit-scrollbar {
            width: 6px;
        }

        .menu-content::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
            border-radius: 3px;
        }

        .menu-content::-webkit-scrollbar-thumb {
            background: rgba(102, 126, 234, 0.5);
            border-radius: 3px;
        }

        .menu-content::-webkit-scrollbar-thumb:hover {
            background: rgba(102, 126, 234, 0.7);
        }

        .menu-item {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            text-decoration: none;
            color: #333;
            transition: all 0.3s ease;
            border-radius: 10px;
            margin: 0 8px;
        }

        .menu-item:hover {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            transform: translateX(5px);
        }

        .menu-item .menu-icon {
            font-size: 12px;
            margin-right: 10px;
            width: 40px;
            text-align: center;
            font-weight: bold;
            letter-spacing: 0.5px;
        }

        .menu-item .menu-text {
            font-size: 14px;
            font-weight: 500;
        }

        /* 响应式设计 */
        @media (max-width: 768px) {
            #floating-menu {
                bottom: 15px;
                right: 150px;
            }
            
            .menu-content {
                min-width: 200px;
            }
            
            .menu-item {
                padding: 8px 12px;
            }
            
            .menu-item .menu-text {
                font-size: 13px;
            }
        }
    </style>

    <style>
        .return-home-panel {
            position: fixed;
            top: 16px;
            left: 16px;
            display: flex;
            gap: 10px;
            z-index: 9999;
            flex-wrap: wrap;
        }
        .return-home-panel .return-link {
            padding: 8px 14px;
            border-radius: 999px;
            background: rgba(15, 23, 42, 0.8);
            color: #f8fafc;
            font-size: 14px;
            text-decoration: none;
            box-shadow: 0 6px 20px rgba(15, 23, 42, 0.25);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .return-home-panel .return-link:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 24px rgba(15, 23, 42, 0.35);
        }
        .return-home-panel .return-link.return-main {
            background: rgba(79, 70, 229, 0.85);
        }
        @media (max-width: 640px) {
            .return-home-panel {
                top: 12px;
                left: 12px;
                right: 12px;
                justify-content: center;
            }
            .return-home-panel .return-link {
                width: 100%;
                text-align: center;
            }
        }
    </style>
</head>
<body>
    <div class="return-home-panel">
        <a class="return-link return-sub" href="index.html">← 返回课件目录</a>
        <a class="return-link return-main" href="../index.html">⌂ 返回主站</a>
    </div>

<div id="presentation-container">

    <div class="slide active">
        <div class="chalkboard" style="flex: 1; text-align: center; ">
            <h2 style="font-size: 4rem; border: none;">第一章</h2>
            <p style="font-size: 2.5rem; color: white;">代数与函数</p>
            
            <!-- 导航按钮组 -->
            <div class="home-nav-buttons">
                <a href="../index.html" class="nav-btn home-btn">
                    <span class="btn-icon">HOME</span>
                    <span class="btn-text">主页</span>
                </a>
                <a href="../故事书/index.html" class="nav-btn story-btn">
                    <span class="btn-icon">STORY</span>
                    <span class="btn-text">故事书</span>
                </a>
                <a href="../习题/index.html" class="nav-btn exercise-btn">
                    <span class="btn-icon">EXERCISE</span>
                    <span class="btn-text">习题</span>
                </a>
                <a href="../网页资源/index.html" class="nav-btn resource-btn">
                    <span class="btn-icon">RESOURCE</span>
                    <span class="btn-text">网页资源</span>
                </a>
            </div>
        </div>
    </div>

    <!-- 目录页 -->
    <div class="slide">
        <div class="chalkboard" style="flex: 1; text-align: center;   overflow-y: auto; align-items: flex-start; justify-content: flex-start;">
            <div style="writing-mode: vertical-rl; text-orientation: mixed; font-size: 3rem; border: none; margin-bottom: 1.5rem; height: 8rem; display: flex; align-items: flex-start; justify-content: center;">
                目录
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 1.5rem; margin: 0 auto; max-width: 1400px; text-align: left;">
                <div style="background: rgba(255,255,255,0.1); padding: 0.8rem; border-radius: 10px; backdrop-filter: blur(10px);">
                    <h3 style="color: #e74c3c; font-size: 1.3rem; margin-bottom: 0.5rem; border-bottom: 2px solid #e74c3c; padding-bottom: 0.2rem;">1. 指数运算</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; font-size: 1rem; line-height: 1.3;">
                        <div>• 指数定义与性质</div>
                        <div>• 乘除法法则</div>
                        <div>• 幂的幂法则</div>
                        <div>• 零负指数</div>
                        <div>• 分数指数</div>
                        <div></div>
                    </div>
                </div>
                
                <div style="background: rgba(255,255,255,0.1); padding: 0.8rem; border-radius: 10px; backdrop-filter: blur(10px);">
                    <h3 style="color: #e74c3c; font-size: 1.3rem; margin-bottom: 0.5rem; border-bottom: 2px solid #e74c3c; padding-bottom: 0.2rem;">2. 对数运算</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; font-size: 1rem; line-height: 1.3;">
                        <div>• 对数定义与性质</div>
                        <div>• 乘积商幂对数</div>
                        <div>• 换底公式</div>
                        <div>• 常用对数系统</div>
                        <div></div>
                        <div></div>
                    </div>
                </div>
                
                <div style="background: rgba(255,255,255,0.1); padding: 0.8rem; border-radius: 10px; backdrop-filter: blur(10px);">
                    <h3 style="color: #e74c3c; font-size: 1.3rem; margin-bottom: 0.5rem; border-bottom: 2px solid #e74c3c; padding-bottom: 0.2rem;">3. 常量与变量</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; font-size: 1rem; line-height: 1.3;">
                        <div>• 常量变量概念</div>
                        <div>• 区间表示法</div>
                        <div>• 开闭区间</div>
                        <div></div>
                        <div></div>
                        <div></div>
                    </div>
                </div>
                
                <div style="background: rgba(255,255,255,0.1); padding: 0.8rem; border-radius: 10px; backdrop-filter: blur(10px);">
                    <h3 style="color: #e74c3c; font-size: 1.3rem; margin-bottom: 0.5rem; border-bottom: 2px solid #e74c3c; padding-bottom: 0.2rem;">4. 函数基础</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; font-size: 1rem; line-height: 1.3;">
                        <div>• 函数定义表示</div>
                        <div>• 定义域值域</div>
                        <div>• 基本性质</div>
                        <div></div>
                        <div></div>
                        <div></div>
                    </div>
                </div>
                
                <div style="background: rgba(255,255,255,0.1); padding: 0.8rem; border-radius: 10px; backdrop-filter: blur(10px);">
                    <h3 style="color: #e74c3c; font-size: 1.3rem; margin-bottom: 0.5rem; border-bottom: 2px solid #e74c3c; padding-bottom: 0.2rem;">5. 函数性质</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; font-size: 1rem; line-height: 1.3;">
                        <div>• 单调性</div>
                        <div>• 奇偶性</div>
                        <div>• 反函数</div>
                        <div>• 复合函数</div>
                        <div></div>
                        <div></div>
                    </div>
                </div>
                
                <div style="background: rgba(255,255,255,0.1); padding: 0.8rem; border-radius: 10px; backdrop-filter: blur(10px);">
                    <h3 style="color: #e74c3c; font-size: 1.3rem; margin-bottom: 0.5rem; border-bottom: 2px solid #e74c3c; padding-bottom: 0.2rem;">6. 基本初等函数</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; font-size: 1rem; line-height: 1.3;">
                        <div>• 常数幂函数</div>
                        <div>• 指数函数</div>
                        <div>• 对数函数</div>
                        <div>• 三角函数</div>
                        <div>• 反三角函数</div>
                        <div></div>
                    </div>
                </div>
            </div>
            
            <div style="margin-top: 1.5rem; text-align: center;">
            </div>
        </div>
    </div>

    <!-- 视频介绍页 -->
    <div class="slide">
        <div class="chalkboard" style="flex: 1; text-align: center; padding: 1rem; overflow: hidden; display: flex; flex-direction: column; justify-content: center;">
            
            <!-- B站视频小块嵌入 -->
            <div style="position: relative; width: 100%; max-width: 400px; height: 0; padding-bottom: 28%; margin: 0 auto;">
                <iframe 
                    src="https://player.bilibili.com/player.html?bvid=BV1ph4y1g75E&t=22.7&autoplay=0&high_quality=1" 
                    style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: none; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.2);"
                    allowfullscreen>
                </iframe>
            </div>
        </div>
    </div>

    <div class="slide">
        <div class="chalkboard">
            <h2>指数</h2>
            <h3>定义</h3>
            <p>指数表示一个数（底数）连续乘以自身多少次。</p>
            <div class="math-formula">
                $a^n = \underbrace{a \times a \times \dots \times a}_{n \text{ 个}}$
            </div>
            <p>其中，$a$ 是 <span class="highlight">底数</span>，$n$ 是 <span class="highlight">指数</span>。</p>
            <h3>例子</h3>
            <p>$2^3 = 2 \times 2 \times 2 = 8$</p>
            <p>$10^4 = 10 \times 10 \times 10 \times 10 = 10000$</p>
        </div>
        <div class="visualization" id="vis-exponents"></div>
    </div>

    <div class="slide">
        <div class="chalkboard">
            <h3>乘法法则</h3>
            <div class="formula-rule">
                $a^m \cdot a^n = a^{m+n}$
            </div>
            <p>同底数幂相乘，<span class="highlight">底数不变，指数相加</span>。</p>
            <p>例：$2^3 \cdot 2^4 = 2^{3+4} = 2^7 = 128$</p>
            <h3>除法法则</h3>
            <div class="formula-rule">
                $\frac{a^m}{a^n} = a^{m-n}$
            </div>
            <p>同底数幂相除，<span class="highlight">底数不变，指数相减</span>。</p>
            <p>例：$\frac{5^7}{5^3} = 5^{7-3} = 5^4 = 625$</p>
        </div>
        <div class="visualization" id="vis-exponent-rules-1"></div>
    </div>

    <div class="slide">
        <div class="chalkboard">
            <h3>幂的幂法则</h3>
            <div class="formula-rule">
                $(a^m)^n = a^{m \cdot n}$
            </div>
            <p>幂的幂，<span class="highlight">底数不变，指数相乘</span>。</p>
            <p>例：$(3^2)^4 = 3^{2 \times 4} = 3^8$</p>
            <h3>乘积的幂法则</h3>
            <div class="formula-rule">
                $(ab)^n = a^n \cdot b^n$
            </div>
            <p>积的幂等于<span class="highlight">幂的积</span>。</p>
            <p>例：$(2 \times 3)^4 = 2^4 \times 3^4 = 16 \times 81$</p>
        </div>
        <div class="visualization" id="vis-exponent-rules-2"></div>
    </div>

    <div class="slide">
        <div class="chalkboard">
            <h3>零指数</h3>
            <div class="formula-rule">
                $a^0 = 1$ （$a \neq 0$）
            </div>
            <p>任何非零数的零次方都等于 <span class="highlight">1</span>。</p>
            <p>可以通过 $\frac{a^m}{a^m} = a^{m-m} = a^0$ 来理解。一个数除以自身等于 1。</p>
            <h3>负指数</h3>
            <div class="formula-rule">
                $a^{-n} = \frac{1}{a^n}$
            </div>
            <p>负指数表示<span class="highlight">倒数</span>。</p>
            <p>可以从 $\frac{a^0}{a^n} = a^{0-n} = a^{-n}$ 推导出来。</p>
        </div>
        <div class="visualization" id="vis-special-exponents"></div>
    </div>

    <div class="slide">
        <div class="chalkboard">
              <h3>分数指数</h3>
            <p>分数指数是<span class="highlight">开方运算</span>的另一种写法。</p>


            <div class="formula-rule">
                $a^{\frac{1}{n}} = \sqrt[n]{a}$
            </div>
            <p>读作：$a$ 的 $n$ 分之一次方等于 $a$ 的 $n$ 次方根。</p>

            <p>• $27^{\frac{1}{3}} = \sqrt[3]{27} = 3$</p>
            <p>• $16^{\frac{1}{4}} = \sqrt[4]{16} = 2$</p>
            <p>• $8^{\frac{1}{3}} = \sqrt[3]{8} = 2$</p>


            <p>指数 $\frac{1}{n}$ 表示：<span class="highlight">"什么数的 $n$ 次方等于底数？"</span></p>
        </div>
        <div class="visualization" id="vis-fractional-exponents"></div>
    </div>

    <div class="slide">
       <div class="visualization full-width" id="vis-log-history">
            <div class="clock-container">
                <!-- 轨道圈 -->
                <div class="orbit" style="position: absolute; width: 550px; height: 550px; border: 1px dashed rgba(255, 255, 255, 0.1); border-radius: 50%; top: 50%; left: 50%; transform: translate(-50%, -50%);"></div>
                <div class="orbit" style="position: absolute; width: 450px; height: 450px; border: 1px dashed rgba(255, 255, 255, 0.1); border-radius: 50%; top: 50%; left: 50%; transform: translate(-50%, -50%);"></div>
                <div class="orbit" style="position: absolute; width: 350px; height: 350px; border: 1px dashed rgba(255, 255, 255, 0.1); border-radius: 50%; top: 50%; left: 50%; transform: translate(-50%, -50%);"></div>

                <!-- 中心时钟 -->
                <div class="center-clock pulse">
                    <span style="font-family: 'Times New Roman', serif;">∞</span>
                </div>

                <!-- 事件标记 -->
                <div class="event-marker" id="event1" style="top: 10px; left: 240px;">
                    <div class="event-icon">📜</div>
                    <div class="event-year">1614</div>
                    <div class="event-name">对数诞生</div>
                </div>

                <div class="event-marker" id="event2" style="top: 80px; right: 10px;">
                    <div class="event-icon">🔭</div>
                    <div class="event-year">1619</div>
                    <div class="event-name">开普勒定律</div>
                </div>

                <div class="event-marker" id="event3" style="bottom: 100px; right: 20px;">
                    <div class="event-icon">⚓</div>
                    <div class="event-year">1620</div>
                    <div class="event-name">航海革命</div>
                </div>

                <div class="event-marker" id="event4" style="bottom: 120px; left: 20px;">
                    <div class="event-icon">📏</div>
                    <div class="event-year">1622</div>
                    <div class="event-name">计算尺发明</div>
                </div>

                <div class="event-marker" id="event5" style="top: 120px; left: 10px;">
                    <div class="event-icon">🚀</div>
                    <div class="event-year">1969</div>
                    <div class="event-name">人类登月</div>
                </div>

                <!-- 漂浮引言 -->
                <div class="floating-quote" id="quote1" style="top: 280px; right: -220px;">
                    "对数的发明，让天文学家的寿命延长了一倍"
                    <div style="text-align: right; font-size: 14px; margin-top: 12px;">- 拉普拉斯</div>
                </div>

                <div class="floating-quote" id="quote2" style="bottom: 480px; left: -120px;">
                    "没有对数表，我不可能完成行星定律的计算"
                    <div style="text-align: right; font-size: 14px; margin-top: 12px;">- 开普勒</div>
                </div>
            </div>
        </div>
    </div>

    <div class="slide">
        <div class="chalkboard">
            <h2>对数</h2>
            <p>对数是<strong>指数</strong>的逆运算。</p>
            <p>如果 $b^y = x$，那么 $\log_b(x) = y$</p>
            <ul>
                <li>$b$ 是底数</li>
                <li>$x$ 是真数</li>
                <li>$y$ 就是以$b$为底$x$的对数</li>
            </ul>
            <p>对数 $y$ 回答了一个问题："底数 $b$ 需要自身相乘多少次才能得到 $x$？"</p>
            <p>将复杂的大数<strong>乘除</strong>运算，转化为简单的<strong>加减</strong>运算。</p>
        </div>
        <div class="visualization" id="vis-log-definition">
            <svg id="animation2" width="100%" height="100%"></svg>
        </div>
    </div>

    <div class="slide">
        <div class="visualization full-width white-bg" id="vis-log-operations">
            <svg id="animation3" width="100vw" height="100vh"></svg>
        </div>
        <div class="animation-controls" id="animationControls">
            <button class="control-btn" onclick="changeSpeed(-1)" title="减速">🐌</button>
            <div class="speed-indicator" id="speedIndicator">1×</div>
            <button class="control-btn" onclick="changeSpeed(1)" title="加速">🚀</button>
            <button class="control-btn play-pause" onclick="togglePlayPause()" id="playPauseBtn" title="暂停/播放">⏸️</button>
        </div>
    </div>

    <div class="slide">
        <div class="chalkboard">
            <h3>乘积的对数</h3>
            <p>$\log_b(xy) = \log_b(x) + \log_b(y)$</p>
            <p style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px;">
                <strong>例：</strong>$\log_2(8 \times 4) = \log_2(8) + \log_2(4) = 3 + 2 = 5$<br>
                验证：$2^5 = 32 = 8 \times 4$ ✓
            </p>

            <h3>商的对数</h3>
            <p>$\log_b(\frac{x}{y}) = \log_b(x) - \log_b(y)$</p>
            <p style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px;">
                <strong>例：</strong>$\log_2(\frac{16}{4}) = \log_2(16) - \log_2(4) = 4 - 2 = 2$<br>
                验证：$2^2 = 4 = \frac{16}{4}$ ✓
            </p>

            <h3>幂的对数</h3>
            <p>$\log_b(x^n) = n \cdot \log_b(x)$</p>
            <p style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px;">
                <strong>例：</strong>$\log_2(8^3) = 3 \cdot \log_2(8) = 3 \times 3 = 9$<br>
                验证：$2^9 = 512 = 8^3$ ✓
            </p>

            <h3>换底公式</h3>
            <p>$\log_b(x) = \frac{\log_a(x)}{\log_a(b)}$</p>
            <p style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px;">
                <strong>例：</strong>$\log_2(8) = \frac{\log_{10}(8)}{\log_{10}(2)} = \frac{0.903}{0.301} \approx 3$ ✓
            </p>
        </div>
        <div class="visualization" id="vis-log-properties">
        </div>
    </div>

    <div class="slide">
        <div class="chalkboard">
            <h3>常用对数系统</h3>
            <div style="margin: 20px 0;">
                <h3 style="color: #e74c3c;">常用对数（lg）</h3>
                <p>以10为底的对数：$\lg(x) = \log_{10}(x)$</p>
                <ul>
                    <li>$\lg(10) = 1$</li>
                    <li>$\lg(100) = 2$</li>
                    <li>$\lg(1000) = 3$</li>
                </ul>
            </div>
            <div style="margin: 20px 0;">
                <h3 style="color: #27ae60;">自然对数（ln）</h3>
                <p>以$e$为底的对数：$\ln(x) = \log_e(x)$</p>
                <p>其中 $e \approx 2.718...$（欧拉数）</p>
                <ul>
                    <li>$\ln(e) = 1$</li>
                    <li>$\ln(e^2) = 2$</li>
                    <li>$\ln(1) = 0$</li>
                </ul>
            </div>
        </div>
         <div class="visualization" id="vis-common-logs">
              <svg id="animation5" width="100%" height="100%"></svg>
        </div>
    </div>

    <div class="slide">
        <div class="chalkboard">
            <h2>常量与变量</h2>
            <p>在问题研究过程中，<span class="highlight">取值始终保持不变</span>的量。</p>
            <ul>
                <li>例如：圆周率 $\pi \approx 3.14159$，自然常数 $e \approx 2.718$。</li>
                <li>在 $y=2x+1$ 中，数字 $2$ 和 $1$ 都是常量。</li>
            </ul>
            <p>在一定范围内，<span class="highlight">可以取不同数值</span>的量。</p>
            <ul>
                <li>例如：时间 $t$，温度 $T$，速度 $v$。</li>
                <li>在 $y=2x+1$ 中，$x$ 和 $y$ 都是变量。$x$ 是自变量，$y$ 是因变量。</li>
            </ul>
        </div>
        <div class="visualization" id="vis-variables"></div>
    </div>

    <div class="slide">
        <div class="chalkboard">
            <h3>闭区间 [a, b]</h3>
            <p>包括端点 $a$ 和 $b$。$a \le x \le b$</p>
            <h3>开区间 (a, b)</h3>
            <p>不包括端点 $a$ 和 $b$。$a < x < b$</p>
            <h3>半开半闭区间</h3>
            <p>$[a, b)$：包括 $a$，不包括 $b$。$a \le x < b$</p>
            <p>$(a, b]$：不包括 $a$，包括 $b$。$a < x \le b$</p>
        </div>
        <div class="visualization" id="vis-intervals"></div>
    </div>

    <div class="slide">
        <div class="chalkboard">
            <h2>函数</h2>
            <p>函数是一种<span class="highlight">特殊的对应关系</span>，就像一个"加工机器"。</p>
            <p>对于每一个输入的数值 $x$（来自一个指定的集合 A），这台机器都能产出<span class="highlight">唯一确定</span>的输出数值 $y$（来自集合 B）。</p>
            <div class="math-formula">
                $y = f(x)$
            </div>
            <ul>
                <li>$x$：自变量 (Input)</li>
                <li>$f$：对应法则 (Rule / Machine)</li>
                <li>$y$：因变量 (Output)</li>
            </ul>
        </div>
        <div class="visualization" id="vis-function-machine"></div>
    </div>

    <div class="slide">
        <div class="chalkboard">
            <h3>定义域</h3>
            <p>思考：要让函数表达式有意义，$x$ 可以取哪些值？</p>

            <ul>
                <li>分母不能为零。</li>
                <li>偶次根号下的数必须大于等于零。</li>
                <li>对数的真数必须大于零。</li>
            </ul>

            <p>$f(x) = \frac{1}{x-2}$，分母 $x-2 \neq 0$，所以定义域是 $x \neq 2$。</p>
            <p>$g(x) = \sqrt{x-3}$，根号下 $x-3 \ge 0$，所以定义域是 $x \ge 3$。</p>
        </div>
        <div class="visualization" id="vis-domain"></div>
    </div>

    <div class="slide">
        <div class="chalkboard">
            <h3>值域</h3>
            <p>当 $x$ 取遍定义域中的所有值时，对应的 $y$ 值组成了值域。</p>
            <ul>
                <li>观察法：对于简单函数，直接观察图像。</li>
                <li>配方法：对于二次函数。</li>
                <li>反函数法：求反函数的定义域。</li>
            </ul>

            <p>$f(x) = x^2$。因为平方永远是非负数，所以值域是 $y \ge 0$。</p>
            <p>$g(x) = \sin(x)$。正弦函数的值在 -1 和 1 之间波动，所以值域是 $[-1, 1]$。</p>
        </div>
        <div class="visualization" id="vis-range"></div>
    </div>

    <div class="slide">
        <div class="chalkboard">
            <h3>函数的基本性质</h3>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
                <div>
                    <h4><span class="highlight">单调性</span></h4>
                    <p>描述函数图像是"上坡"还是"下坡"</p>

                </div>
                <div>
                    <h4><span class="highlight">奇偶性</span></h4>
                    <p>描述函数图像的对称性</p>

                </div>
                <div>
                    <h4><span class="highlight">周期性</span></h4>
                    <p>描述函数图像的重复性</p>

                </div>
                <div>
                    <h4> <span class="highlight">有界性</span></h4>
                    <p>描述函数值的范围限制</p>

                </div>
            </div>

        </div>
        <div class="visualization" id="vis-properties-intro"></div>
    </div>

    <div class="slide">
        <div class="chalkboard">
            <h3>单调递增</h3>
            <p>在一个区间内，如果函数值 $y$ <span class="highlight">随着 $x$ 的增大而增大</span>，那么函数在该区间上是单调递增的。</p>
            <p>几何上看，图像是<span class="highlight">从左到右上升的（上坡）</span>。</p>
            <div class="math-formula">
                若 $x_1 < x_2$，则 $f(x_1) < f(x_2)$
            </div>
        </div>
        <div class="visualization" id="vis-monotonicity-inc"></div>
    </div>

    <div class="slide">
        <div class="chalkboard">
            <h3>单调递减</h3>
            <p>在一个区间内，如果函数值 $y$ <span class="highlight">随着 $x$ 的增大而减小</span>，那么函数在该区间上是单调递减的。</p>
            <p>几何上看，图像是<span class="highlight">从左到右下降的（下坡）</span>。</p>
            <div class="math-formula">
                若 $x_1 < x_2$，则 $f(x_1) > f(x_2)$
            </div>
        </div>
        <div class="visualization" id="vis-monotonicity-dec"></div>
    </div>

    <div class="slide">
        <div class="chalkboard">
            <h3>单调区间</h3>
            <p>函数的单调性在不同区间可能呈现不同特征。</p>
            <p>分析函数性质时，需要明确划分其单调递增和单调递减的区间范围。</p>
            <p> $f(x) = x^2$</p>
            <ul>
                <li>在区间 $(-\infty, 0]$ 上，函数<span class="highlight">单调递减</span>。</li>
                <li>在区间 $[0, +\infty)$ 上，函数<span class="highlight">单调递增</span>。</li>
            </ul>
            <p>点 $x=0$ 是它的"转折点"。</p>
        </div>
        <div class="visualization" id="vis-monotonicity-intervals"></div>
    </div>

    <div class="slide">
        <div class="chalkboard">
            <h3>奇偶性</h3>
            <p>奇偶性描述的是函数图像关于<span class="highlight">坐标轴或原点</span>的对称性。</p>
            <p>判断奇偶性的前提是：函数的<span class="highlight">定义域必须关于原点对称</span>。</p>
            <ul>
                <li><strong>偶函数</strong>：图像关于 Y 轴对称。</li>
                <li><strong>奇函数</strong>：图像关于原点对称。</li>
            </ul>
        </div>
        <div class="visualization" id="vis-parity-intro"></div>
    </div>

    <div class="slide">
        <div class="chalkboard">
            <h3>偶函数</h3>
                    <p>如果对于定义域内的任意 $x$，都满足：</p>
            <div class="math-formula">
                $f(-x) = f(x)$
            </div>
            <p>那么 $f(x)$ 就是一个偶函数。</p>
            <p>函数图像关于 <span class="highlight">Y 轴对称</span>。就像镜子一样。</p>
            <p>$f(x) = x^2$, $f(x) = |x|$, $f(x) = \cos(x)$</p>
        </div>
        <div class="visualization" id="vis-even-function"></div>
    </div>

    <div class="slide">
        <div class="chalkboard">
            <h3>奇函数</h3>
            <p>如果对于定义域内的任意 $x$，都满足：</p>
            <div class="math-formula">
                $f(-x) = -f(x)$
            </div>
            <p>那么 $f(x)$ 就是一个奇函数。</p>
            <p>函数图像关于 <span class="highlight">原点 (0,0) 对称</span>。图像旋转180度后会与原图重合。</p>
            <p>$f(x) = x$, $f(x) = x^3$, $f(x) = \sin(x)$</p>
        </div>
        <div class="visualization" id="vis-odd-function"></div>
    </div>

    <div class="slide">
        <div class="chalkboard">
            <h3>反函数</h3>
            <p>如果函数 $f$ 把 $x$ 变成了 $y$，那么它的反函数 $f^{-1}$ 就是把 $y$ <span class="highlight">变回</span> $x$ 的操作。</p>
            <div class="math-formula">
                若 $y = f(x)$，则 $x = f^{-1}(y)$
            </div>
            <p><span class="highlight">注意</span>：只有单调函数（严格一对一的函数）才有反函数。</p>
        </div>
        <div class="visualization" id="vis-inverse-machine"></div>
    </div>

    <div class="slide">
        <div class="chalkboard">
                <h3>反函数与原函数</h3>
            <ul>
                <li>原函数 $f(x)$ 的<span class="highlight">定义域</span>是反函数 $f^{-1}(x)$ 的<span class="highlight">值域</span>。</li>
                <li>原函数 $f(x)$ 的<span class="highlight">值域</span>是反函数 $f^{-1}(x)$ 的<span class="highlight">定义域</span>。</li>
            </ul>
            <p>函数 $y=f(x)$ 和它的反函数 $y=f^{-1}(x)$ 的图像关于直线 <span class="highlight">$y=x$ 对称</span>。</p>
        </div>
        <div class="visualization" id="vis-inverse-graph"></div>
    </div>

    <div class="slide">
        <div class="visualization" id="vis-elementary-intro" style="flex: 1; padding: 0; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);"></div>
    </div>

    <div class="slide">
        <div class="iframe-container" style="position: relative; width: 100%; height: 100%;">
            <iframe id="iframe-power-constant" src="常数函数与幂函数.html" style="width: 100%; height: 100%; border: none;"></iframe>
            <div class="iframe-nav-overlay" data-slide="27" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1000; pointer-events: none; background: transparent;"></div>
        </div>
    </div>

    <div class="slide">
        <div class="iframe-container" style="position: relative; width: 100%; height: 100%;">
            <iframe id="iframe-exp" src="指数函数可视化.html" style="width: 100%; height: 100%; border: none;"></iframe>
            <div class="iframe-nav-overlay" data-slide="28" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1000; pointer-events: none; background: transparent;"></div>
        </div>
    </div>

    <div class="slide">
        <div class="iframe-container" style="position: relative; width: 100%; height: 100%;">
            <iframe id="iframe-log" src="对数函数可视化.html" style="width: 100%; height: 100%; border: none;"></iframe>
            <div class="iframe-nav-overlay" data-slide="29" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1000; pointer-events: none; background: transparent;"></div>
        </div>
    </div>
    <div class="slide">
        <div class="iframe-container" style="position: relative; width: 100%; height: 100%;">
            <iframe id="iframe-inverse" src="指对数互为反函数.html" style="width: 100%; height: 100%; border: none;"></iframe>
            <div class="iframe-nav-overlay" data-slide="30" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1000; pointer-events: none; background: transparent;"></div>
        </div>
    </div>
    <div class="slide">
        <div class="iframe-container" style="position: relative; width: 100%; height: 100%;">
            <iframe id="iframe-trig" src="三角函数.html" style="width: 100%; height: 100%; border: none;"></iframe>
            <div class="iframe-nav-overlay" data-slide="31" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1000; pointer-events: none; background: transparent;"></div>
        </div>
    </div>

    <div class="slide">
        <div class="iframe-container" style="position: relative; width: 100%; height: 100%;">
            <iframe id="iframe-inv-trig" src="反三角函数可视化.html" style="width: 100%; height: 100%; border: none;"></iframe>
            <div class="iframe-nav-overlay" data-slide="32" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1000; pointer-events: none; background: transparent;"></div>
        </div>
    </div>

    <div class="slide">
        <div class="chalkboard">
            <h3>复合函数</h3>
            <p>如果 $u=g(x)$，而 $y=f(u)$，那么 $y=f(g(x))$ 就是一个复合函数。</p>
            <ul>
                <li>$g(x)$ 是<span class="highlight">内层函数</span>。</li>
                <li>$f(u)$ 是<span class="highlight">外层函数</span>。</li>
            </ul>
            <p>计算时，要<span class="highlight">由内向外</span>，层层计算。</p>

            <p>1. 先算内层函数：$u = g(x)$</p>
            <p>2. 再把结果 $u$ 代入外层函数：$y = f(u)$</p>

        </div>
        <div class="visualization" id="vis-composite-machine">
            <!-- 自动播放的复合函数动画 -->
            <div id="composite-auto-animation" style="width: 100%; height: 100%; position: relative; border-radius: 10px; overflow: auto;">
                <!-- 计算流程区 -->
                <div id="calculation-flow" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center;">
                    <!-- 步骤1：内层计算 -->
                    <div id="step1" style="margin-bottom: 30px; opacity: 0; transition: all 0.8s;">
                        <div style="color: #87ceeb; font-size: 20px; margin-bottom: 10px;">步骤1：计算内层函数 $g(x)$</div>
                        <div style="color: white; font-size: 24px; font-family: 'JetBrains Mono', monospace;">
                            $g(2) = 2 + 1 = $<span id="inner-result" style="color: #00ff00; font-weight: bold;">3</span>
                        </div>
                    </div>

                    <!-- 箭头 -->
                    <div id="arrow" style="margin-bottom: 30px; opacity: 0; transition: all 0.8s;">
                        <div style="color: #ffd700; font-size: 30px;">↓</div>
                        <div style="color: #87ceeb; font-size: 16px;">将结果代入外层函数 $f(u)$</div>
                    </div>

                    <!-- 步骤2：外层计算 -->
                    <div id="step2" style="margin-bottom: 30px; opacity: 0; transition: all 0.8s;">
                        <div style="color: #87ceeb; font-size: 20px; margin-bottom: 10px;">步骤2：计算外层函数 $f(u)$</div>
                        <div style="color: white; font-size: 24px; font-family: 'JetBrains Mono', monospace;">
                            $f(3) = 3^2 = $<span id="final-result" style="color: #ff6b6b; font-weight: bold; font-size: 32px;">9</span>
                        </div>
                    </div>

                    <!-- 最终答案 -->
                    <div id="final-answer" style="opacity: 0; transition: all 0.8s;">
                        <div style="color: #ffd700; font-size: 28px; font-weight: bold; text-shadow: 2px 2px 4px rgba(0,0,0,0.5);">
                            $f(g(2)) = 9$
                        </div>
                    </div>
                </div>

                <!-- 动画粒子效果 -->
                <div id="particles" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;"></div>
            </div>
        </div>
    </div>









    <!-- 翻页按钮 -->
    <div class="nav-buttons">
        <button class="nav-btn" id="prev-btn" onclick="previousSlide()" title="上一页 (←)">‹</button>
        <button class="nav-btn" id="next-btn" onclick="nextSlide()" title="下一页 (→)">›</button>
    </div>

    <div class="page-indicator" id="page-indicator">1 / 32</div>

    <!-- 全局动画控制面板 -->
    <div class="global-animation-controls" id="globalAnimationControls">
        <button class="global-control-btn" id="globalPlayPauseBtn">暂停</button>
        <button class="global-control-btn" id="globalSpeedBtn">1.0x</button>
    </div>

</div>

<script>
    let slides, totalSlides, counter, currentSlide = 0;
    let currentAnimation;

    const animationState = {
        isPaused: false,
        speed: 1,
        resumeCallback: null,
    };

    // 全局动画控制变量
    let globalAnimationPlaying = true;
    let globalAnimationSpeed = 1.0;
    let currentAnimationFunction = null;

    // 全局动画控制函数
    function initGlobalAnimationControls() {
        const playPauseBtn = document.getElementById('globalPlayPauseBtn');
        const speedBtn = document.getElementById('globalSpeedBtn');
        const controlPanel = document.getElementById('globalAnimationControls');

        // 速度选项：0.5x, 1x, 1.5x, 2x, 3x, 4x, 6x
        const speedOptions = [0.5, 1, 1.5, 2, 3, 4, 6];
        let currentSpeedIndex = 1; // 默认1x

        // 播放/暂停按钮
        playPauseBtn.addEventListener('click', () => {
            globalAnimationPlaying = !globalAnimationPlaying;
            playPauseBtn.textContent = globalAnimationPlaying ? '暂停' : '播放';
            playPauseBtn.className = globalAnimationPlaying ? 'global-control-btn' : 'global-control-btn pause';

            // 更新动画状态
            animationState.isPaused = !globalAnimationPlaying;

            // 通知iframe页面
            notifyIframeAnimationControl();
        });

        // 速度按钮（循环切换）
        speedBtn.addEventListener('click', () => {
            currentSpeedIndex = (currentSpeedIndex + 1) % speedOptions.length;
            globalAnimationSpeed = speedOptions[currentSpeedIndex];
            speedBtn.textContent = globalAnimationSpeed.toFixed(1) + 'x';
            animationState.speed = globalAnimationSpeed;

            // 通知iframe页面
            notifyIframeAnimationControl();
        });

        // 根据当前页面显示/隐藏控制面板
        updateControlPanelVisibility();
    }

    // 通知iframe页面动画控制状态
    function notifyIframeAnimationControl() {
        const currentSlideElement = slides[currentSlide];
        if (currentSlideElement) {
            const iframe = currentSlideElement.querySelector('iframe');
            if (iframe && iframe.contentWindow) {
                try {
                    iframe.contentWindow.postMessage({
                        type: 'animationControl',
                        playing: globalAnimationPlaying,
                        speed: globalAnimationSpeed
                    }, '*');
                } catch (e) {
                    console.log('无法向iframe发送消息:', e);
                }
            }
        }
    }

    // 更新控制面板可见性
    function updateControlPanelVisibility() {
        const controlPanel = document.getElementById('globalAnimationControls');
        const currentSlideElement = slides[currentSlide];

        // 检查当前页面是否有动画
        const hasAnimation = currentSlideElement && (
            currentSlideElement.querySelector('.visualization') ||
            currentSlideElement.querySelector('iframe')
        );

        controlPanel.style.display = hasAnimation ? 'flex' : 'none';
    }

    /**
     * 更新翻页按钮状态
     */
    function updateNavButtons() {
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        
        if (prevBtn && nextBtn) {
            // 在第一页时禁用上一页按钮
            prevBtn.disabled = (currentSlide === 0);
            // 在最后一页时禁用下一页按钮
            nextBtn.disabled = (currentSlide === totalSlides - 1);
        }
    }

    /**
     * 切换到下一张幻灯片
     * 支持循环播放：最后一页后回到第一页
     */
    function nextSlide() {
        if (!slides || totalSlides === 0) return;
        currentSlide = (currentSlide + 1) % totalSlides;
        showSlide(currentSlide);
    }

    /**
     * 切换到上一张幻灯片
     * 支持循环播放：第一页前回到最后一页
     */
    function previousSlide() {
        if (!slides || totalSlides === 0) return;
        currentSlide = (currentSlide - 1 + totalSlides) % totalSlides;
        showSlide(currentSlide);
    }

    /**
     * 页面加载完成后的初始化
     * 设置幻灯片导航和交互控制
     */
    document.addEventListener('DOMContentLoaded', function() {
        // 获取所有幻灯片元素
        slides = document.querySelectorAll('.slide');
        totalSlides = slides.length;
        // 获取页面指示器元素
        counter = document.getElementById('page-indicator');

        // 初始化全局动画控制
        initGlobalAnimationControls();

        // 监听来自iframe的消息
        window.addEventListener('message', (event) => {
            if (event.data.type === 'requestAnimationState') {
                // iframe请求当前动画状态
                event.source.postMessage({
                    type: 'animationControl',
                    playing: globalAnimationPlaying,
                    speed: globalAnimationSpeed
                }, '*');
            }
        });

        // 显示第一张幻灯片
        showSlide(0);

        // 键盘导航事件监听（支持方向键、翻页笔等）
        document.addEventListener('keydown', (e) => {
            // 检查是否在iframe页面
            const currentSlide = document.querySelector('.slide.active');
            const iframe = currentSlide ? currentSlide.querySelector('iframe') : null;

            // 下一页的按键
            if (e.key === 'ArrowRight' || e.key === 'ArrowDown' || e.key === ' ' ||
                e.key === 'PageDown' || e.key === 'Enter') {
                e.preventDefault();
                nextSlide();

                // 如果在iframe页面，也通知iframe
                if (iframe && iframe.contentWindow) {
                    try {
                        iframe.contentWindow.postMessage({
                            type: 'navigation',
                            action: 'next'
                        }, '*');
                    } catch (e) {
                        console.log('无法向iframe发送导航消息:', e);
                    }
                }
            }
            // 上一页的按键
            else if (e.key === 'ArrowLeft' || e.key === 'ArrowUp' ||
                     e.key === 'PageUp' || e.key === 'Backspace') {
                e.preventDefault();
                previousSlide();

                // 如果在iframe页面，也通知iframe
                if (iframe && iframe.contentWindow) {
                    try {
                        iframe.contentWindow.postMessage({
                            type: 'navigation',
                            action: 'previous'
                        }, '*');
                    } catch (e) {
                        console.log('无法向iframe发送导航消息:', e);
                    }
                }
            }
            // 首页
            else if (e.key === 'Home') {
                e.preventDefault();
                goToSlide(0);
            }
            // 末页
            else if (e.key === 'End') {
                e.preventDefault();
                goToSlide(totalSlides - 1);
            }
        });

        // 鼠标滚轮导航事件监听（支持iframe页面）
        document.addEventListener('wheel', (e) => {
            // 检查是否在iframe页面
            const currentSlide = document.querySelector('.slide.active');
            const iframe = currentSlide ? currentSlide.querySelector('iframe') : null;

            // 总是阻止默认滚动行为，使用我们的翻页逻辑
            e.preventDefault();

            if (e.deltaY > 0) {
                // 向下滚动：下一页
                nextSlide();

                // 如果在iframe页面，也通知iframe
                if (iframe && iframe.contentWindow) {
                    try {
                        iframe.contentWindow.postMessage({
                            type: 'navigation',
                            action: 'next'
                        }, '*');
                    } catch (e) {
                        console.log('无法向iframe发送导航消息:', e);
                    }
                }
            } else {
                // 向上滚动：上一页
                previousSlide();

                // 如果在iframe页面，也通知iframe
                if (iframe && iframe.contentWindow) {
                    try {
                        iframe.contentWindow.postMessage({
                            type: 'navigation',
                            action: 'previous'
                        }, '*');
                    } catch (e) {
                        console.log('无法向iframe发送导航消息:', e);
                    }
                }
            }
        }, { passive: false });

        // 为iframe页面添加特殊的事件处理
        function setupIframeNavigation() {
            const overlays = document.querySelectorAll('.iframe-overlay');

            overlays.forEach(overlay => {
                // 为覆盖层添加滚轮事件监听
                overlay.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    if (e.deltaY > 0) {
                        nextSlide();
                    } else {
                        previousSlide();
                    }
                }, { passive: false });

                // 为覆盖层添加键盘事件监听
                overlay.addEventListener('keydown', (e) => {
                    if (e.key === 'ArrowRight' || e.key === ' ') {
                        e.preventDefault();
                        nextSlide();
                    } else if (e.key === 'ArrowLeft') {
                        e.preventDefault();
                        previousSlide();
                    }
                });

                // 让覆盖层可以接收键盘事件
                overlay.setAttribute('tabindex', '0');
            });
        }

        // 添加全局键盘事件处理，确保在iframe页面也能工作
        function handleGlobalKeydown(e) {
            // 检查当前是否在iframe页面
            const currentSlide = document.querySelector('.slide.active');
            const hasIframe = currentSlide && currentSlide.querySelector('iframe');

            if (hasIframe) {
                if (e.key === 'ArrowRight' || e.key === ' ') {
                    e.preventDefault();
                    nextSlide();
                } else if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    previousSlide();
                }
            }
        }

        // 添加额外的全局键盘监听
        document.addEventListener('keydown', handleGlobalKeydown);

        // 初始化iframe导航
        setupIframeNavigation();
    });

    /**
     * 显示指定索引的幻灯片
     * @param {number} index - 幻灯片索引（0-38）
     */
    function showSlide(index) {
        // 边界检查
        if (!slides || index < 0 || index >= totalSlides) return;

        // 隐藏所有幻灯片
        slides.forEach(slide => slide.classList.remove('active'));

        // 显示当前幻灯片
        currentSlide = index;
        slides[currentSlide].classList.add('active');

        // 更新页面指示器（右上角的页码）
        counter.textContent = `${currentSlide + 1} / ${totalSlides}`;

        // 更新翻页按钮状态
        updateNavButtons();

        // 特殊处理：第8页（对数运算）显示动画控制面板
        const controls = document.getElementById('animationControls');
        if (currentSlide === 8) { // 对数运算页面
             controls.classList.add('active');
        } else {
             controls.classList.remove('active');
        }

        // 更新全局动画控制面板可见性
        updateControlPanelVisibility();

        // 运行当前幻灯片的可视化
        runVisualization(currentSlide);

        // 渲染数学公式（MathJax）
        setTimeout(() => renderMathJax(slides[currentSlide]), 50);
    }

    /**
     * 跳转到指定幻灯片
     * @param {number} index - 目标幻灯片索引
     */
    function goToSlide(index) {
        showSlide(index);
    }



    /**
     * 渲染指定容器中的MathJax数学公式
     * @param {HTMLElement} container - 包含数学公式的容器元素
     */
    const renderMathJax = async (container) => {
        if (window.MathJax && window.MathJax.typesetPromise) {
            try {
                await window.MathJax.typesetPromise([container]);
            } catch (error) {
                console.warn('MathJax rendering failed:', error);
            }
        }
    };

    /**
     * 渲染SVG中的MathJax数学公式
     * @param {SVGElement} svgElement - 包含foreignObject的SVG元素
     */
    const renderMathJaxInSVG = async (svgElement) => {
        if (window.MathJax && window.MathJax.typesetPromise) {
            try {
                // 查找SVG中所有的foreignObject元素
                const foreignObjects = svgElement.querySelectorAll('foreignObject');
                if (foreignObjects.length > 0) {
                    await window.MathJax.typesetPromise(Array.from(foreignObjects));
                }
            } catch (error) {
                console.warn('MathJax SVG rendering failed:', error);
            }
        }
    };

    /**
     * 根据容器ID渲染MathJax数学公式
     * @param {string} containerId - 容器元素的ID
     */
    const renderMathJaxInContainer = async (containerId) => {
        if (window.MathJax && window.MathJax.typesetPromise) {
            try {
                const container = document.getElementById(containerId);
                if (container) {
                    await window.MathJax.typesetPromise([container]);
                }
            } catch (error) {
                console.warn('MathJax container rendering failed:', error);
            }
        }
    };

    function togglePlayPause() {
        animationState.isPaused = !animationState.isPaused;
        const btn = document.getElementById('playPauseBtn');
        if (animationState.isPaused) {
            btn.innerHTML = '<span>▶️</span>';
            btn.classList.add('paused');
        } else {
            btn.innerHTML = '<span>⏸️</span>';
            btn.classList.remove('paused');
            if (animationState.resumeCallback) {
                animationState.resumeCallback();
            }
        }
    }

    function changeSpeed(direction) {
        const speeds = [0.5, 1, 1.5, 2, 3];
        let currentIndex = speeds.indexOf(animationState.speed);
        if (direction > 0 && currentIndex < speeds.length - 1) currentIndex++;
        else if (direction < 0 && currentIndex > 0) currentIndex--;
        animationState.speed = speeds[currentIndex];
        document.getElementById('speedIndicator').textContent = animationState.speed + '×';
    }

    function waitForResume() {
        return new Promise(resolve => {
            if (!animationState.isPaused) {
                resolve();
                return;
            }
            animationState.resumeCallback = () => {
                animationState.resumeCallback = null;
                resolve();
            };
        });
    }

    function scaledDelay(baseDelay) { return baseDelay / animationState.speed; }
    function scaledDuration(baseDuration) { return baseDuration / animationState.speed; }


    // --- D3 可视化辅助函数 ---

    /**
     * 设置D3.js可视化的基础结构
     * @param {string} containerId - 容器元素的ID
     * @param {Object} margins - 边距设置 {top, right, bottom, left}
     * @returns {Object|null} 包含svg, g, width, height的对象，失败时返回null
     */
    function setupD3(containerId, margins = {top: 40, right: 40, bottom: 40, left: 40}) {
        const container = d3.select(`#${containerId}`);
        if (container.empty()) {
            console.error("Container not found:", containerId);
            return null;
        }
        // 清除之前的内容
        container.html('');

        // 获取容器尺寸
        const bounds = container.node().getBoundingClientRect();
        if (bounds.width === 0 || bounds.height === 0) return null;

        // 创建SVG元素
        const svg = container.append('svg')
            .attr('width', bounds.width)
            .attr('height', bounds.height);

        // 计算绘图区域尺寸
        const width = bounds.width - margins.left - margins.right;
        const height = bounds.height - margins.top - margins.bottom;

        // 创建绘图组，应用边距变换
        const g = svg.append('g')
            .attr('transform', `translate(${margins.left}, ${margins.top})`);

        return { container, svg, g, width, height };
    }

    function drawAxes(g, xScale, yScale, width, height) {
        g.append('g')
            .attr('transform', `translate(0, ${yScale(0)})`)
            .call(d3.axisBottom(xScale).ticks(10))
            .call(g => g.select(".domain").attr("stroke-width", 1.5).attr("stroke", "#333"))
            .call(g => g.selectAll(".tick line").remove());

        g.append('g')
            .attr('transform', `translate(${xScale(0)}, 0)`)
            .call(d3.axisLeft(yScale).ticks(10))
            .call(g => g.select(".domain").attr("stroke-width", 1.5).attr("stroke", "#333"))
            .call(g => g.selectAll(".tick line").remove());
    }

    function animatePath(path) {
        if (!path.node()) return;
        const totalLength = path.node().getTotalLength();
        path.attr("stroke-dasharray", totalLength + " " + totalLength)
            .attr("stroke-dashoffset", totalLength)
            .transition()
            .duration(2000)
            .ease(d3.easeLinear)
            .attr("stroke-dashoffset", 0);
    }

    // --- Individual Visualization Functions ---


    // --- Individual Visualization Functions ---


    /**
     * 第2页：指数基础概念可视化
     * 功能：动态展示指数运算的基本概念
     * 内容：2^0, 2^1, 2^2, 2^3 的值和图形表示
     * 动画：点依次出现，连线绘制，标签显示
     * 教学目标：理解指数表示重复乘法的概念
     */
    function visualizeExponents(containerId) {
        const setup = setupD3(containerId);
        if (!setup) return;
        const { g, width, height } = setup;
        const data = [ { x: 0, y: 1, label: "2^0" }, { x: 1, y: 2, label: "2^1" }, { x: 2, y: 4, label: "2^2" }, { x: 3, y: 8, label: "2^3" }];
        const xScale = d3.scaleLinear().domain([-1, 4]).range([0, width]);
        const yScale = d3.scaleLinear().domain([0, 10]).range([height, 0]);
        g.selectAll("rect").data(data).enter().append("rect")
            .attr("x", d => xScale(d.x) - width/10).attr("y", height).attr("width", width/5).attr("height", 0)
            .attr("fill", "var(--primary-color)")
            .transition().duration(1000).delay((d, i) => i * 300)
            .attr("y", d => yScale(d.y)).attr("height", d => height - yScale(d.y));
        g.selectAll(".label").data(data).enter().append("text")
            .attr("class", "label").attr("x", d => xScale(d.x)).attr("y", d => yScale(d.y) - 10).attr("text-anchor", "middle")
            .attr("font-size", "1.2em").attr("fill", "var(--text-color)").style("opacity", 0).text(d => d.y)
            .transition().duration(500).delay((d, i) => 1000 + i * 300).style("opacity", 1);

        // 渲染数学公式
        setTimeout(() => {
            renderMathJaxInContainer(containerId);
        }, 2000);
    }

   // --- 新增的可视化函数来自用户提供的指数课件 ---

    /**
     * 第3页：指数运算法则1可视化
     * 功能：演示同底数幂的乘法和除法法则
     * 内容：a^m · a^n = a^(m+n), a^m / a^n = a^(m-n)
     * 动画：指数相加和相减的过程演示
     * 教学目标：掌握指数运算的基本法则
     */
    function visualizeExponentRules1New(containerId) {
        const setup = setupD3(containerId);
        if (!setup) return;
        const { svg, g, width, height } = setup;

        const mulY = height * 0.25;
        const mulGroup = g.append("g");
        const mulText = mulGroup.append("text").attr("x", width / 2).attr("y", mulY - 30).attr("text-anchor", "middle").attr("font-size", "1.8em").attr("fill", "var(--text-color)");
        mulText.append("tspan").text("2").style("font-weight", "bold");
        mulText.append("tspan").text("3").attr("baseline-shift", "super").attr("font-size", "0.7em");
        mulText.append("tspan").text(" × ");
        mulText.append("tspan").text("2").style("font-weight", "bold");
        mulText.append("tspan").text("2").attr("baseline-shift", "super").attr("font-size", "0.7em");
        const circles1 = g.selectAll(".c1").data(d3.range(3)).enter().append("circle").attr("class", "c1").attr("cy", mulY).attr("cx", (d, i) => width * 0.2 + i * 40).attr("r", 15).attr("fill", "var(--primary-color)");
        const circles2 = g.selectAll(".c2").data(d3.range(2)).enter().append("circle").attr("class", "c2").attr("cy", mulY).attr("cx", (d, i) => width * 0.8 - i * 40).attr("r", 15).attr("fill", "var(--accent-color)");
        circles1.transition().delay(1000).duration(1500).attr("cx", (d, i) => width/2 - 100 + i * 40);
        circles2.transition().delay(1000).duration(1500).attr("cx", (d, i) => width/2 + 20 + i * 40);
        const mulResult = g.append("text").attr("x", width / 2).attr("y", mulY + 70).attr("text-anchor", "middle").attr("font-size", "1.8em").attr("fill", "var(--success-color)").style("opacity", 0);
        mulResult.append("tspan").text("= 2");
        mulResult.append("tspan").text("3+2").attr("baseline-shift", "super").attr("font-size", "0.7em");
        mulResult.append("tspan").text(" = 2");
        mulResult.append("tspan").text("5").attr("baseline-shift", "super").attr("font-size", "0.7em");
        mulResult.transition().delay(2600).duration(1000).style("opacity", 1);

        const divY = height * 0.75;
        g.append("line").attr("x1", 0).attr("y1", height/2).attr("x2", width).attr("y2", height/2).attr("stroke", "#ddd").attr("stroke-width", 2);
        const divText = g.append("text").attr("x", width / 2).attr("y", divY - 50).attr("text-anchor", "middle").attr("font-size", "1.8em").attr("fill", "var(--text-color)");
        divText.append("tspan").text("5").style("font-weight", "bold");
        divText.append("tspan").text("4").attr("baseline-shift", "super").attr("font-size", "0.7em");
        divText.append("tspan").text(" ÷ ");
        divText.append("tspan").text("5").style("font-weight", "bold");
        divText.append("tspan").text("2").attr("baseline-shift", "super").attr("font-size", "0.7em");
        const divCircles = g.selectAll(".c3").data(d3.range(4)).enter().append("g").attr("class", "c3").attr("transform", (d, i) => `translate(${width/2 - 75 + i * 50}, ${divY})`);
        divCircles.append("circle").attr("r", 18).attr("fill", "var(--info-color)");
        divCircles.filter((d, i) => i >= 2).transition().delay(4000).duration(1000).style("opacity", 0.3).select("circle").attr("fill", "#ccc");
        divCircles.filter((d, i) => i >= 2).append("line").attr("x1", -15).attr("y1", -15).attr("x2", 15).attr("y2", 15).attr("stroke", "var(--danger-color)").attr("stroke-width", 3).style("opacity", 0).transition().delay(4000).duration(1000).style("opacity", 1);
        const divResult = g.append("text").attr("x", width / 2).attr("y", divY + 70).attr("text-anchor", "middle").attr("font-size", "1.8em").attr("fill", "var(--success-color)").style("opacity", 0);
        divResult.append("tspan").text("= 5");
        divResult.append("tspan").text("4-2").attr("baseline-shift", "super").attr("font-size", "0.7em");
        divResult.append("tspan").text(" = 5");
        divResult.append("tspan").text("2").attr("baseline-shift", "super").attr("font-size", "0.7em");
        divResult.transition().delay(5100).duration(1000).style("opacity", 1);

        // 渲染数学公式
        setTimeout(() => {
            renderMathJaxInContainer(containerId);
        }, 6500);
    }

    /**
     * 第4页：指数运算法则2可视化
     * 功能：演示幂的幂和乘积的幂法则
     * 内容：(a^m)^n = a^(m·n), (ab)^n = a^n · b^n
     * 动画：大圆圈分散成小圆泡，展示指数相乘过程
     * 教学目标：理解复合指数运算规律
     */
    function visualizeExponentRules2New(containerId) {
        const setup = setupD3(containerId, {top: 0, right: 0, bottom: 0, left: 0});
        if (!setup) return;
        const { svg, g, width, height } = setup;

        // 无背景，纯净视觉
        svg.style("background", "transparent");

        // 创建定义
        const defs = svg.append("defs");

        // 发光效果滤镜
        const glowFilter = defs.append("filter")
            .attr("id", "glow2")
            .attr("x", "-50%").attr("y", "-50%")
            .attr("width", "200%").attr("height", "200%");

        glowFilter.append("feGaussianBlur")
            .attr("stdDeviation", "3")
            .attr("result", "coloredBlur");

        const feMerge = glowFilter.append("feMerge");
        feMerge.append("feMergeNode").attr("in", "coloredBlur");
        feMerge.append("feMergeNode").attr("in", "SourceGraphic");

        // 渐变定义
        const gradient = defs.append("radialGradient")
            .attr("id", "bubbleGradient")
            .attr("cx", "30%")
            .attr("cy", "30%");

        gradient.append("stop")
            .attr("offset", "0%")
            .attr("stop-color", "#74b9ff")
            .attr("stop-opacity", 0.9);

        gradient.append("stop")
            .attr("offset", "100%")
            .attr("stop-color", "#0984e3")
            .attr("stop-opacity", 0.7);

        // 标题
        g.append("text")
            .attr("x", width/2)
            .attr("y", 50)
            .attr("text-anchor", "middle")
            .attr("font-size", "2em")
            .attr("font-weight", "300")
            .attr("fill", "#2d3436")
            .text("(2³)⁴ = ?")
            .style("opacity", 0)
            .transition()
            .delay(500)
            .duration(800)
            .style("opacity", 1);

        // 第一阶段：显示一个大圆圈代表 (2³)
        setTimeout(() => {
            const bigCircle = g.append("circle")
                .attr("cx", width/2)
                .attr("cy", height/2 - 50)
                .attr("r", 0)
                .attr("fill", "url(#bubbleGradient)")
                .attr("stroke", "#0984e3")
                .attr("stroke-width", 3)
                .attr("filter", "url(#glow2)")
                .style("opacity", 0.8);

            // 大圆圈展开动画
            bigCircle.transition()
                .duration(1000)
                .attr("r", 60)
                .ease(d3.easeBounceOut);

            // 大圆圈内的标签
            g.append("text")
                .attr("x", width/2)
                .attr("y", height/2 - 45)
                .attr("text-anchor", "middle")
                .attr("font-size", "1.8em")
                .attr("font-weight", "bold")
                .attr("fill", "white")
                .text("2³")
                .style("opacity", 0)
                .transition()
                .delay(800)
                .duration(600)
                .style("opacity", 1);

            // 说明文字
            g.append("text")
                .attr("x", width/2)
                .attr("y", height/2 + 40)
                .attr("text-anchor", "middle")
                .attr("font-size", "1.2em")
                .attr("fill", "#636e72")
                .text("一个大圆圈代表 2³")
                .style("opacity", 0)
                .transition()
                .delay(1200)
                .duration(600)
                .style("opacity", 1);

        }, 1000);

        // 第二阶段：大圆圈分散成4个小圆泡
        setTimeout(() => {
            // 隐藏说明文字 - 使用更可靠的选择器
            const explanationText = g.selectAll("text").filter(function() {
                return d3.select(this).text() === "一个大圆圈代表 2³";
            });

            if (!explanationText.empty()) {
                explanationText.transition()
                    .duration(500)
                    .style("opacity", 0);
            }



            // 创建4个小圆泡的位置 - 围绕大圆圈分布
            const centerX = width/2;
            const centerY = height/2 - 50;
            const radius = 120; // 围绕大圆圈的半径
            const bubblePositions = [
                {x: centerX, y: centerY - radius}, // 上方
                {x: centerX + radius, y: centerY}, // 右方
                {x: centerX, y: centerY + radius}, // 下方
                {x: centerX - radius, y: centerY}  // 左方
            ];

            // 创建4个小圆泡，从大圆圈的位置开始
            bubblePositions.forEach((pos, i) => {
                // 创建小圆泡，初始位置在大圆圈中心
                const bubble = g.append("circle")
                    .attr("cx", width/2)
                    .attr("cy", height/2 - 50)
                    .attr("r", 15) // 开始很小
                    .attr("fill", "url(#bubbleGradient)")
                    .attr("stroke", "#0984e3")
                    .attr("stroke-width", 2)
                    .attr("filter", "url(#glow2)")
                    .style("opacity", 0);

                // 小圆泡出现并移动到目标位置
                bubble.transition()
                    .delay(500 + i * 150)
                    .duration(100)
                    .style("opacity", 0.8)
                    .transition()
                    .duration(800)
                    .attr("cx", pos.x)
                    .attr("cy", pos.y)
                    .attr("r", 35)
                    .ease(d3.easeBackOut);

                // 小圆泡标签
                g.append("text")
                    .attr("x", width/2)
                    .attr("y", height/2 - 45)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "1.2em")
                    .attr("font-weight", "bold")
                    .attr("fill", "white")
                    .text("2³")
                    .style("opacity", 0)
                    .transition()
                    .delay(600 + i * 150)
                    .duration(800)
                    .attr("x", pos.x)
                    .attr("y", pos.y + 5)
                    .style("opacity", 1)
                    .ease(d3.easeBackOut);
            });

            // 大圆圈爆炸效果：先放大再消失
            setTimeout(() => {
                g.selectAll("circle").filter(function() {
                    return d3.select(this).attr("r") == "60";
                }).transition()
                    .duration(300)
                    .attr("r", 80)
                    .style("opacity", 0.3)
                    .transition()
                    .duration(200)
                    .attr("r", 100)
                    .style("opacity", 0);

                // 大圆圈标签也消失
                g.selectAll("text").filter(function() {
                    return d3.select(this).text() === "2³" && d3.select(this).attr("font-size") === "1.8em";
                }).transition()
                    .duration(500)
                    .style("opacity", 0);
            }, 1000);

        }, 3000);

        // 第三阶段：显示最终计算结果
        setTimeout(() => {


            // 计算结果
            g.append("text")
                .attr("x", width/2)
                .attr("y", height/2 + 180)
                .attr("text-anchor", "middle")
                .attr("font-size", "2.2em")
                .attr("font-weight", "bold")
                .attr("fill", "#e74c3c")
                .text("(2³)⁴ = 2³×⁴ = 2¹²")
                .style("opacity", 0)
                .transition()
                .delay(800)
                .duration(800)
                .style("opacity", 1);

            // 解释文字
            g.append("text")
                .attr("x", width/2)
                .attr("y", height/2 + 220)
                .attr("text-anchor", "middle")
                .attr("font-size", "1.3em")
                .attr("fill", "#636e72")
                .text("幂的幂：底数不变，指数相乘")
                .style("opacity", 0)
                .transition()
                .delay(1200)
                .duration(800)
                .style("opacity", 1);

        }, 6000);

        // 渲染数学公式
        setTimeout(() => {
            renderMathJaxInContainer(containerId);
        }, 7000);
    }

    /**
     * 第5页：特殊指数可视化
     * 功能：演示零指数和负指数的概念
     * 内容：a^0 = 1, a^(-n) = 1/a^n
     * 动画：数值变换和倒数关系展示
     * 教学目标：理解特殊指数的定义和意义
     */
    function visualizeSpecialExponentsNew(containerId) {
        const setup = setupD3(containerId);
        if (!setup) return;
        const { svg, g, width, height } = setup;

        const sectionHeight = height / 2;
        const sectionWidth = width;

        // --- Section 1: Zero Exponent ---
        const zeroGroup = g.append("g");
        const scaleGroup = zeroGroup.append("g")
            .attr("transform", `translate(${sectionWidth / 2}, ${sectionHeight * 0.6})`);

        scaleGroup.append("polygon").attr("points", "-10,0 10,0 0,15").attr("fill", "#555");
        const beam = scaleGroup.append("line").attr("x1", -100).attr("x2", 100).attr("stroke", "#555").attr("stroke-width", 4);
        const leftPan = scaleGroup.append("text").attr("x", -70).attr("y", -15).attr("font-size", "1.5em").attr("text-anchor", "middle");
        const rightPan = scaleGroup.append("text").attr("x", 70).attr("y", -15).attr("font-size", "1.5em").attr("text-anchor", "middle");

        // 零指数动画 - 立即开始
        leftPan.append("tspan").text("a³").style("opacity", 0).transition().delay(0).duration(500).style("opacity", 1);
        rightPan.append("tspan").text("a³").style("opacity", 0).transition().delay(0).duration(500).style("opacity", 1);

        setTimeout(() => {
            leftPan.html("a³ ÷ a³");
            rightPan.html("a³ ÷ a³");
        }, 800);

        setTimeout(() => {
            beam.transition().duration(500).attr("transform", "rotate(5)").transition().duration(500).attr("transform", "rotate(-5)").transition().duration(500).attr("transform", "rotate(0)");
            leftPan.html("a⁰").attr("font-size", "1.5em").attr("fill", "var(--danger-color)");
            rightPan.html("1").attr("font-size", "1.5em").attr("fill", "var(--success-color)");
        }, 1500);

        // --- Section 2: Negative Exponent ---
        g.append("line").attr("x1", 0).attr("y1", sectionHeight).attr("x2", width).attr("y2", sectionHeight).attr("stroke", "#ddd");
        const negGroup = g.append("g").attr("transform", `translate(0, ${sectionHeight})`);

        // 负指数动画 - 1秒后开始
        const negTitle = negGroup.append("text").attr("x", sectionWidth/2).attr("y", sectionHeight * 0.2).attr("text-anchor", "middle").attr("font-size", "1.5em").text("a² ÷ a⁵ = ?").style("opacity", 0).transition().delay(1000).duration(500).style("opacity", 1);

        const fraction = negGroup.append("g").attr("transform", `translate(${sectionWidth/2}, ${sectionHeight * 0.6})`).style("opacity", 0);
        const numerator = fraction.selectAll(".num").data("aa".split("")).enter().append("text").attr("class", "num").text("a").attr("x", (d,i) => -25 + i * 25).attr("y", -15).attr("font-size", "1.5em");

        const denominator = fraction.selectAll(".den").data("aaaaa".split("")).enter().append("text").attr("class", "den").text("a").attr("x", (d,i) => -60 + i * 25).attr("y", 25).attr("font-size", "1.5em");
        fraction.append("line").attr("x1", -70).attr("x2", 70).attr("stroke", "#333").attr("stroke-width", 2);

        // 分数显示 - 1秒后
        fraction.transition().delay(1000).duration(500).style("opacity", 1);

        // 标红相消项 - 2.5秒后
        setTimeout(() => {
            // 安全地处理选择器，避免DOM元素不存在的问题
            if (numerator && !numerator.empty() && denominator && !denominator.empty()) {
                for(let i=0; i<2; i++){
                    const numElement = numerator.filter((d, j) => i === j);
                    const denElement = denominator.filter((d, j) => i === j);

                    if (!numElement.empty()) {
                        numElement.attr("fill", "var(--danger-color)");
                    }
                    if (!denElement.empty()) {
                        denElement.attr("fill", "var(--danger-color)");
                    }
                }
            }
        }, 2500);

        // 3.5秒后：隐藏标题
        setTimeout(() => {
            // 安全地隐藏标题
            if (negTitle && !negTitle.empty()) {
                negTitle.style("opacity", 0);
                console.log("标题隐藏成功");
            }
        }, 3500);

        // 5秒后：原始分数（带约分标记）左移，最终结果右侧显示
        setTimeout(() => {
            // 安全地处理分数移动和结果显示
            if (fraction && !fraction.empty()) {
                // 原始分数（带约分标记）左移到25%位置，保持显示
                fraction.transition()
                    .duration(800)
                    .attr("transform", `translate(${sectionWidth * 0.25}, ${sectionHeight * 0.6})`);

                console.log("约分分数成功左移并保持显示");

                // 在右侧65%位置显示最终结果
                const resultGroup = negGroup.append("g")
                  .attr("transform", `translate(${sectionWidth * 0.65}, ${sectionHeight * 0.6})`)
                  .style("opacity", 0);

                const finalEq = resultGroup.append("text").attr("text-anchor", "middle").attr("font-size", "1.8em");
                finalEq.append("tspan").text("a").attr("fill", "#e74c3c");
                finalEq.append("tspan").text("-3").attr("baseline-shift", "super").attr("font-size", "0.6em").attr("fill", "#e74c3c");
                finalEq.append("tspan").text(" = ");

                // 创建分数形式的1/a³
                const fracGroup = resultGroup.append("g").attr("transform", "translate(40, 0)");
                fracGroup.append("text").attr("x", 0).attr("y", -10).attr("text-anchor", "middle").attr("font-size", "1.4em").text("1");
                fracGroup.append("line").attr("x1", -15).attr("x2", 25).attr("y1", 0).attr("y2", 0).attr("stroke", "#333").attr("stroke-width", 2);
                fracGroup.append("text").attr("x", 0).attr("y", 20).attr("text-anchor", "middle").attr("font-size", "1.4em").text("a³");

                // 淡入最终结果
                resultGroup.transition()
                    .delay(400)
                    .duration(800)
                    .style("opacity", 1);

                // 添加连接箭头
                const arrow = negGroup.append("g")
                  .attr("transform", `translate(${sectionWidth * 0.45}, ${sectionHeight * 0.6})`)
                  .style("opacity", 0);

                // 箭头线
                arrow.append("line")
                  .attr("x1", 0)
                  .attr("x2", 35)
                  .attr("y1", 0)
                  .attr("y2", 0)
                  .attr("stroke", "#e74c3c")
                  .attr("stroke-width", 3);

                // 箭头头部（三角形）
                arrow.append("path")
                  .attr("d", "M35,0 L25,-5 L25,5 Z")
                  .attr("fill", "#e74c3c");

                // 淡入箭头
                arrow.transition()
                    .delay(600)
                    .duration(500)
                    .style("opacity", 1);

                console.log("Successfully added fraction left-move, result, and arrow!");
            }
        }, 5000);

        // 渲染数学公式
        setTimeout(() => {
            renderMathJaxInContainer(containerId);
        }, 6000);
    }

    /**
     * 第6页：分数指数可视化
     * 功能：演示分数指数与根式的关系
     * 内容：a^(1/n) = ⁿ√a，分数指数的计算
     * 动画：3D立方体和根式变换
     * 教学目标：理解分数指数是开方运算的另一种表示
     */
    function visualizeFractionalExponents(containerId) {
        const container = d3.select(`#${containerId}`);
        if (container.empty()) return;
        container.html('');

        const bounds = container.node().getBoundingClientRect();
        const width = bounds.width;
        const height = bounds.height;

        // 创建三个区域的布局容器
        const mainDiv = container.append('div')
            .style('width', '100%')
            .style('height', '100%')
            .style('display', 'flex')
            .style('flex-direction', 'column')
            .style('gap', '20px')
            .style('padding', '20px')
            .style('box-sizing', 'border-box');

        // 第一个例子：27^(1/3) = 3
        const section1 = mainDiv.append('div')
            .style('flex', '1')
            .style('display', 'flex')
            .style('align-items', 'center')
            .style('gap', '40px');

        const canvas1 = section1.append('div')
            .style('flex', '1')
            .attr('id', 'canvas-27')
            .style('height', '100%');

        const text1 = section1.append('div')
            .style('flex', '1')
            .style('text-align', 'center');

        text1.append('h3')
            .style('font-size', '1.8em')
            .style('color', 'var(--text-color)')
            .style('margin', '0')
            .html('$27^{\\frac{1}{3}} = \\sqrt[3]{27} = 3$');

        text1.append('p')
            .style('font-size', '1.2em')
            .style('color', '#7f8c8d')
            .style('margin-top', '10px')
            .text('27个单位立方体 = 3×3×3');

        // 第二个例子：16^(1/4) = 2
        const section2 = mainDiv.append('div')
            .style('flex', '1')
            .style('display', 'flex')
            .style('align-items', 'center')
            .style('gap', '40px');

        const canvas2 = section2.append('div')
            .style('flex', '1')
            .attr('id', 'canvas-16')
            .style('height', '100%');

        const text2 = section2.append('div')
            .style('flex', '1')
            .style('text-align', 'center');

        text2.append('h3')
            .style('font-size', '1.8em')
            .style('color', 'var(--text-color)')
            .style('margin', '0')
            .html('$16^{\\frac{1}{4}} = \\sqrt[4]{16} = 2$');

        text2.append('p')
            .style('font-size', '1.2em')
            .style('color', '#7f8c8d')
            .style('margin-top', '10px')
            .text('16个单位 = 2×2×2×2');

        // 第三个例子：8^(2/3) = 4
        const section3 = mainDiv.append('div')
            .style('flex', '1')
            .style('display', 'flex')
            .style('align-items', 'center')
            .style('gap', '20px');

        const step1Div = section3.append('div')
            .style('flex', '1')
            .style('text-align', 'center');

        step1Div.append('div')
            .attr('id', 'canvas-8')
            .style('height', '120px');

        step1Div.append('p')
            .style('font-size', '1.2em')
            .style('margin-top', '10px')
            .html('$\\sqrt[3]{8} = 2$');

        const arrow = section3.append('div')
            .style('font-size', '2em')
            .style('color', 'var(--text-color)')
            .text('→');

        const step2Div = section3.append('div')
            .style('flex', '1')
            .style('text-align', 'center');

        step2Div.append('div')
            .attr('id', 'canvas-4')
            .style('height', '120px');

        step2Div.append('p')
            .style('font-size', '1.2em')
            .style('margin-top', '10px')
            .html('$2^2 = 4$');

        const result = section3.append('div')
            .style('flex', '1')
            .style('text-align', 'center')
            .style('display', 'flex')
            .style('align-items', 'center')
            .style('justify-content', 'center');

        result.append('h3')
            .style('font-size', '1.6em')
            .style('color', 'black')
            .style('margin', '0')
            .html('$8^{\\frac{2}{3}} = 4$');

        // 使用Canvas API绘制3D效果的立方体
        setTimeout(() => {
            draw3DCubes('canvas-27', 3, 3, 3); // 3×3×3
            draw3DCubes('canvas-16', 2, 2, 4); // 2×2×4 表示16
            draw3DCubes('canvas-8', 2, 2, 2);  // 2×2×2
            drawSquareGrid('canvas-4', 2, 2);   // 2×2正方形

            // 渲染数学公式
            renderMathJaxInContainer(containerId);
        }, 100);

        // 绘制3D立方体阵列
        function draw3DCubes(canvasId, nx, ny, nz) {
            const canvasDiv = document.getElementById(canvasId);
            if (!canvasDiv) return;

            const canvas = document.createElement('canvas');
            const rect = canvasDiv.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height || 150;
            canvasDiv.appendChild(canvas);

            const ctx = canvas.getContext('2d');
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const cubeSize = Math.min(canvas.width, canvas.height) / Math.max(nx, ny, nz) / 2;

            // 等距投影绘制立方体
            for(let x = 0; x < nx; x++) {
                for(let y = 0; y < ny; y++) {
                    for(let z = 0; z < nz; z++) {
                        const offsetX = (x - nx/2 + 0.5) * cubeSize * 1.2;
                        const offsetY = (y - ny/2 + 0.5) * cubeSize * 0.7;
                        const offsetZ = (z - nz/2 + 0.5) * cubeSize * 1.2;

                        const isoX = centerX + (offsetX - offsetY) * 0.866;
                        const isoY = centerY + (offsetX + offsetY) * 0.5 - offsetZ;

                        drawIsometricCube(ctx, isoX, isoY, cubeSize * 0.8);
                    }
                }
            }
        }

        // 绘制单个等距立方体
        function drawIsometricCube(ctx, x, y, size) {
            const s = size;
            const h = s * 0.866; // sqrt(3)/2

            // 顶面（最亮）
            ctx.fillStyle = '#5dade2';
            ctx.beginPath();
            ctx.moveTo(x, y - s);
            ctx.lineTo(x + h, y - s/2);
            ctx.lineTo(x, y);
            ctx.lineTo(x - h, y - s/2);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = '#3498db';
            ctx.stroke();

            // 右面（中等亮度）
            ctx.fillStyle = '#3498db';
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + h, y - s/2);
            ctx.lineTo(x + h, y + s/2);
            ctx.lineTo(x, y + s);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = '#2874a6';
            ctx.stroke();

            // 左面（最暗）
            ctx.fillStyle = '#2874a6';
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x, y + s);
            ctx.lineTo(x - h, y + s/2);
            ctx.lineTo(x - h, y - s/2);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = '#1e5f8e';
            ctx.stroke();
        }

        // 绘制正方形网格
        function drawSquareGrid(canvasId, rows, cols) {
            const canvasDiv = document.getElementById(canvasId);
            if (!canvasDiv) return;

            const canvas = document.createElement('canvas');
            const rect = canvasDiv.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height || 150;
            canvasDiv.appendChild(canvas);

            const ctx = canvas.getContext('2d');
            const gridSize = Math.min(canvas.width, canvas.height) * 0.6;
            const cellSize = gridSize / Math.max(rows, cols);
            const startX = (canvas.width - gridSize) / 2;
            const startY = (canvas.height - gridSize) / 2;

            // 绘制填充
            ctx.fillStyle = '#e74c3c';
            ctx.fillRect(startX, startY, gridSize, gridSize);

            // 绘制网格线
            ctx.strokeStyle = '#c0392b';
            ctx.lineWidth = 2;

            for(let i = 0; i <= rows; i++) {
                ctx.beginPath();
                ctx.moveTo(startX, startY + i * cellSize);
                ctx.lineTo(startX + gridSize, startY + i * cellSize);
                ctx.stroke();
            }

            for(let j = 0; j <= cols; j++) {
                ctx.beginPath();
                ctx.moveTo(startX + j * cellSize, startY);
                ctx.lineTo(startX + j * cellSize, startY + gridSize);
                ctx.stroke();
            }
        }
    }

    /**
     * 第7页：对数发展历史可视化
     * 功能：时间轴动画展示对数的历史发展
     * 内容：1614年对数诞生，开普勒定律，航海革命，计算尺发明，人类登月
     * 动画：星空背景，事件标记依次出现，连接线绘制，名人名言显示
     * 教学目标：了解对数在科学发展中的重要作用
     */
     function visualizeLogHistory(containerId) {
        function createStars() {
            const container = document.getElementById('vis-log-history');
            if (!container) return;
            container.querySelectorAll('.star').forEach(star => star.remove());
            for (let i = 0; i < 40; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.style.position = 'absolute';
                star.style.width = '2px';
                star.style.height = '2px';
                star.style.background = '#fff';
                star.style.borderRadius = '50%';
                star.style.top = Math.random() * 100 + '%';
                star.style.left = Math.random() * 100 + '%';
                star.style.opacity = Math.random();
                star.style.animation = `twinkle ${1 + Math.random() * 1.5}s infinite`;
                star.style.zIndex = '1';
                container.appendChild(star);
            }
        }

        function drawConnections() {
            d3.select('#vis-log-history .clock-container svg').remove();
            const svg = d3.select('#vis-log-history .clock-container')
                .append('svg')
                .attr('width', '600')
                .attr('height', '600')
                .style('position', 'absolute')
                .style('top', '0')
                .style('left', '0')
                .style('pointer-events', 'none');
            const connections = [ {x1: 300, y1: 300, x2: 300, y2: 70}, {x1: 300, y1: 300, x2: 530, y2: 150}, {x1: 300, y1: 300, x2: 520, y2: 470}, {x1: 300, y1: 300, x2: 90, y2: 460}, {x1: 300, y1: 300, x2: 70, y2: 190} ];
            connections.forEach((conn, i) => {
                setTimeout(() => {
                    svg.append('line').attr('x1', conn.x1).attr('y1', conn.y1).attr('x2', conn.x1).attr('y2', conn.y1)
                       .attr('stroke', '#ffd700').attr('stroke-width', 2).attr('opacity', 0.4)
                       .transition().duration(400).attr('x2', conn.x2).attr('y2', conn.y2);
                }, i * 100);
            });
        }

        createStars();
        setTimeout(() => document.getElementById('event1')?.classList.add('active'), 500);
        setTimeout(() => document.getElementById('event2')?.classList.add('active'), 1750);
        setTimeout(() => document.getElementById('event3')?.classList.add('active'), 3250);
        setTimeout(() => document.getElementById('event4')?.classList.add('active'), 4750);
        setTimeout(() => document.getElementById('event5')?.classList.add('active'), 6250);
        setTimeout(() => { let q = document.getElementById('quote1'); if(q) {q.style.opacity = '1'; q.style.transition = 'opacity 0.6s';}}, 2000);
        setTimeout(() => { let q = document.getElementById('quote2'); if(q) {q.style.opacity = '1'; q.style.transition = 'opacity 0.6s';}}, 4000);
        setTimeout(drawConnections, 7000);

        // 渲染数学公式
        setTimeout(() => {
            renderMathJaxInContainer(containerId);
        }, 1000);
    }

    /**
     * 第8页：对数定义可视化
     * 功能：通过动画演示对数的定义和计算过程
     * 内容：log₂(8) = 3 的求解过程，指数过程和对数过程的对比
     * 动画：指数路径绘制，节点依次出现，对数倒推过程
     * 教学目标：理解对数是指数的逆运算
     */
    function visualizeLogDefinition(containerId) {
        const svg = d3.select("#animation2");
        if(svg.empty()) return;
        svg.selectAll("*").remove();
        const bounds = svg.node().getBoundingClientRect();
        const width = bounds.width, height = bounds.height;
        const centerX = width / 2;
        const base = 2, number = 8;
        const logResult = Math.log(number) / Math.log(base);

        svg.append("text").attr("x", centerX).attr("y", 50).attr("text-anchor", "middle").style("font-size", "20px").text(`求 log₂(8) = ?`);
        svg.append("text").attr("x", centerX).attr("y", 80).attr("text-anchor", "middle").style("font-size", "16px").text(`也就是，需要多少个 2 相乘才能得到 8？`);

        const expGroup = svg.append("g");
        expGroup.append("text").attr("x", 50).attr("y", 150).text("指数过程:").style("font-size", "16px").style("font-weight", "bold");

        let pathData = "M 150 145";
        for (let i = 1; i <= logResult; i++) { pathData += ` L ${150 + i * 50} 145`; }

        const expPath = expGroup.append("path").attr("d", pathData).attr("stroke", "#3498db").attr("stroke-width", 2).attr("fill", "none");
        const totalLength = expPath.node().getTotalLength();

        expPath.attr("stroke-dasharray", `${totalLength} ${totalLength}`).attr("stroke-dashoffset", totalLength)
            .transition().duration(2000).ease(d3.easeLinear).attr("stroke-dashoffset", 0);

        for (let i = 0; i <= logResult; i++) {
            const val = Math.pow(base, i);
            const node = expGroup.append("g").attr("transform", `translate(${150 + i * 50}, 145)`).style("opacity", 0);
            node.append("circle").attr("r", 15).attr("fill", i === 0 ? "#e67e22" : "#3498db");
            node.append("text").text(val === 1 ? '起点' : val).attr("y", 40).attr("text-anchor", "middle").style("fill", "#2c3e50");
            if (i > 0) {
                 expGroup.append("text").text(`×${base}`).attr("x", 150 + (i - 1) * 50 + 25).attr("y", 125).attr("text-anchor", "middle").style("opacity", 0)
                 .transition().delay(1000 + i*500).duration(500).style("opacity", 1);
            }
            node.transition().delay(1000 + i * 500).duration(500).style("opacity", 1);
        }

        const logGroup = svg.append("g").style("opacity", 0);
        logGroup.transition().delay(4500).duration(500).style("opacity", 1);

        logGroup.append("text").attr("x", 50).attr("y", 300).text("对数过程:").style("font-size", "16px").style("font-weight", "bold").style("fill", "#000000");
        logGroup.append("text").attr("x", centerX).attr("y", 330).text(`从 8 开始，每次除以 2，数一下除了几次`).attr("text-anchor", "middle").style("font-size", "16px").style("font-weight", "bold").style("fill", "#000000");

        let count = 0;
        function animateDivision(val, step) {
            if (val < base) {
                logGroup.append("text").attr("x", centerX).attr("y", 450).text(`总共除了 ${count} 次, 所以 log₂(8) = ${count}`).attr("text-anchor", "middle").style("font-size", "24px").style("fill", "#000000").style("font-weight", "bold").style("opacity", 0)
                    .transition().duration(500).style("opacity", 1);
                return;
            }
            const startX = 150 + step * 100;
            const g = logGroup.append("g").style("opacity", 0);
            g.transition().delay(4500 + step * 1500 + 500).duration(500).style("opacity", 1);
            g.append("rect").attr("x", startX - 25).attr("y", 350).attr("width", 50).attr("height", 30).attr("fill", "#3498db").attr("rx", 5);
            g.append("text").text(val).attr("x", startX).attr("y", 370).attr("text-anchor", "middle").style("fill", "#000000").style("font-weight", "bold");
            g.append("text").text(`÷${base}`).attr("x", startX + 50).attr("y", 370).attr("text-anchor", "middle").style("font-weight", "bold");
            const nextVal = val / base;
            count++;
            const gNext = logGroup.append("g").style("opacity", 0);
            gNext.transition().delay(4500 + step * 1500 + 1500).duration(500).style("opacity", 1);
            gNext.append("rect").attr("x", startX + 75).attr("y", 350).attr("width", 50).attr("height", 30).attr("fill", "#2ecc71").attr("rx", 5);
            gNext.append("text").text(nextVal).attr("x", startX + 100).attr("y", 370).attr("text-anchor", "middle").style("fill", "#000000").style("font-weight", "bold");
            logGroup.append("text").text(`${count}次`).attr("x", startX + 50).attr("y", 410).attr("text-anchor", "middle").style("fill", "#000000").style("font-weight", "bold")
            .style("opacity", 0).transition().delay(4500 + step * 1500 + 1500).duration(500).style("opacity", 1);
            animateDivision(nextVal, step + 1);
        }
        animateDivision(number, 0);

        // 渲染数学公式
        setTimeout(() => {
            renderMathJaxInContainer(containerId);
        }, 1000);
    }

    /**
     * 第9页：对数运算法则可视化
     * 功能：动画演示对数运算法则的应用
     * 内容：乘积、商、幂的对数运算法则
     * 动画：数字变换，运算过程展示，支持播放控制
     * 教学目标：掌握对数运算的基本法则
     */
    function visualizeLogOperations(containerId) {
        const svg = d3.select("#animation3");
        if(svg.empty()) return;
        svg.selectAll("*").remove();

        const width = 1100, height = 800;
        const margin = {top: 220, right: 50, bottom: 120, left: 50};
        const innerWidth = width - margin.left - margin.right;

        const g = svg.append("g").attr("transform", `translate(${margin.left}, ${margin.top})`);

        // 创建背景区域
        const upperBg = g.append("rect")
            .attr("x", -30)
            .attr("y", -60)
            .attr("width", innerWidth + 60)
            .attr("height", 100)
            .attr("fill", "#ecf8ff")
            .attr("rx", 10)
            .style("opacity", 0.3);

        const lowerBg = g.append("rect")
            .attr("x", -30)
            .attr("y", 90)
            .attr("width", innerWidth + 60)
            .attr("height", 100)
            .attr("fill", "#f0f9e8")
            .attr("rx", 10)
            .style("opacity", 0.3);

        const numbers = [2, 4, 8, 16, 32, 64, 128, 256, 512];
        const logs = [1, 2, 3, 4, 5, 6, 7, 8, 9];

        const scaleNumbers = d3.scalePoint().domain(numbers).range([0, innerWidth]).padding(0.5);
        const scaleLogs = d3.scalePoint().domain(logs).range([0, innerWidth]).padding(0.5);

        // 数字轴
        const numberAxis = g.append("g").attr("class", "number-axis");
        numberAxis.call(d3.axisBottom(scaleNumbers));
        numberAxis.selectAll("text").style("font-size", "14px").style("font-weight", "bold");

        // 为数字轴添加节点 - 显示2的幂次方
        numbers.forEach((num, i) => {
            const nodeG = numberAxis.append("g")
                .attr("class", "number-node")
                .attr("transform", `translate(${scaleNumbers(num)}, 0)`);
            nodeG.append("circle")
                .attr("r", 18)
                .attr("cy", -30)
                .attr("fill", "#3498db")
                .attr("fill-opacity", 0.2)
                .attr("stroke", "#3498db")
                .attr("stroke-width", 2);

            // 使用外置文本标签来显示公式
            const textElement = nodeG.append("foreignObject")
                .attr("x", -15)
                .attr("y", -38)
                .attr("width", 30)
                .attr("height", 20)
                .html(`<div style="font-size: 12px; text-align: center; color: #2c3e50; font-weight: bold;">$2^{${i+1}}$</div>`);

            // 渲染这个节点的数学公式
            if (window.MathJax && window.MathJax.typesetPromise) {
                setTimeout(() => {
                    window.MathJax.typesetPromise([textElement.node()]).catch(error => {
                        console.warn('MathJax rendering failed for number node:', error);
                    });
                }, 50);
            }
        });

        // 对数轴
        const logAxis = g.append("g").attr("transform", `translate(0, 150)`).attr("class", "log-axis");
        logAxis.call(d3.axisBottom(scaleLogs));
        logAxis.selectAll("text").style("font-size", "14px").style("font-weight", "bold");

        // 为对数轴添加节点
        logs.forEach(log => {
            const nodeG = logAxis.append("g")
                .attr("class", "number-node")
                .attr("transform", `translate(${scaleLogs(log)}, 0)`);
            nodeG.append("rect")
                .attr("x", -25)
                .attr("y", -42)
                .attr("width", 50)
                .attr("height", 24)
                .attr("fill", "#2ecc71")
                .attr("fill-opacity", 0.2)
                .attr("stroke", "#2ecc71")
                .attr("stroke-width", 2)
                .attr("rx", 5);

            // 使用外置文本标签来显示公式
            const textElement = nodeG.append("foreignObject")
                .attr("x", -25)
                .attr("y", -38)
                .attr("width", 50)
                .attr("height", 20)
                .html(`<div style="font-size: 10px; text-align: center; color: #2c3e50; font-weight: bold;">$\\log_2(${Math.pow(2, log)})$</div>`);

            // 渲染这个节点的数学公式
            if (window.MathJax && window.MathJax.typesetPromise) {
                setTimeout(() => {
                    window.MathJax.typesetPromise([textElement.node()]).catch(error => {
                        console.warn('MathJax rendering failed for log node:', error);
                    });
                }, 50);
            }
        });

        g.append("text")
            .attr("x", -40)
            .attr("y", -95)
            .attr("class", "world-description")
            .attr("text-anchor", "start")
            .style("font-weight", "bold")
            .text("(乘法、除法、幂运算)");

        g.append("text")
            .attr("x", -40)
            .attr("y", 225)
            .attr("class", "world-description")
            .attr("text-anchor", "start")
            .style("font-weight", "bold")
            .text("(加法、减法、乘法)");

        // 添加垂直连接线（虚线）
        numbers.forEach((num, i) => {
            g.append("line")
                .attr("x1", scaleNumbers(num))
                .attr("y1", 20)
                .attr("x2", scaleLogs(logs[i]))
                .attr("y2", 130)
                .attr("stroke", "#9b59b6")
                .attr("stroke-width", 1)
                .attr("stroke-dasharray", "3,3")
                .style("opacity", 0.3);
        });

        // 渲染数学公式
        setTimeout(async () => {
            if (window.MathJax && window.MathJax.typesetPromise) {
                try {
                    // 先渲染整个SVG
                    await window.MathJax.typesetPromise([svg.node()]);
                    // 再专门渲染SVG中的公式
                    await renderMathJaxInSVG(svg.node());
                } catch (error) {
                    console.warn('MathJax rendering failed:', error);
                }
            }
        }, 200);

        const operations = [
            { type: 'multiply', num1: 16, num2: 32, log1: 4, log2: 5, title: '乘法运算', desc: '16 × 32 = ?' },
            { type: 'divide', num1: 256, num2: 16, log1: 8, log2: 4, title: '除法运算', desc: '256 ÷ 16 = ?' },
            { type: 'power', num1: 8, num2: 3, log1: 3, log2: 3, title: '幂运算', desc: '8³ = ?' }
        ];

        async function animateOperation(op) {
            return new Promise(resolve => {
                svg.selectAll(".animation-element").remove();

                let logResult, numResult, opSymbol, logOpSymbol, logFormula, numFormula;
                switch(op.type) {
                    case 'multiply':
                        logResult = op.log1 + op.log2;
                        numResult = op.num1 * op.num2;
                        opSymbol = '×';
                        logOpSymbol = '+';
                        logFormula = `${op.num1}\\times ${op.num2}=2^{${op.log1}}\\times 2^{${op.log2}}=2^{(${op.log1}+${op.log2})}=2^{${logResult}}=${numResult}`;
                        numFormula = `${op.num1} \\times ${op.num2} = ${numResult}`;
                        break;
                    case 'divide':
                        logResult = op.log1 - op.log2;
                        numResult = op.num1 / op.num2;
                        opSymbol = '÷';
                        logOpSymbol = '−';
                        logFormula = `${op.num1}\\div ${op.num2}=\\frac{2^{${op.log1}}}{2^{${op.log2}}}=2^{(${op.log1}-${op.log2})}=2^{${logResult}}=${numResult}`;
                        numFormula = `${op.num1} \\div ${op.num2} = ${numResult}`;
                        break;
                    case 'power':
                        logResult = op.log1 * op.log2;
                        numResult = Math.pow(op.num1, op.num2);
                        opSymbol = '^';
                        logOpSymbol = '×';
                        logFormula = `${op.num1}^{${op.num2}}=(2^{${op.log1}})^{${op.num2}}=2^{${op.log1}\\times ${op.log2}}=2^{${logResult}}=${numResult}`;
                        numFormula = `${op.num1}^{${op.num2}} = ${numResult}`;
                        break;
                }

                const animGroup = g.append("g").attr("class", "animation-element");

                // 问题框
                const questionBox = animGroup.append("g");
                questionBox.append("rect")
                    .attr("x", innerWidth/2 - 150)
                    .attr("y", -130)
                    .attr("width", 300)
                    .attr("height", 50)
                    .attr("class", "operation-box");

                const mainText = questionBox.append("text")
                    .attr("x", innerWidth/2)
                    .attr("y", -100)
                    .attr("text-anchor", "middle")
                    .style("font-size", "24px")
                    .style("font-weight", "bold");

                async function step1() {
                    await waitForResume();
                    mainText.text(op.desc)
                        .style("opacity", 0)
                        .transition().duration(scaledDuration(1000)).style("opacity", 1);
                    await new Promise(resolve => setTimeout(resolve, scaledDelay(1000)));
                }

                async function step2() {
                    await waitForResume();
                    // 创建移动的圆点
                    const mover1 = animGroup.append("circle")
                        .attr("r", 10)
                        .attr("fill", "#e67e22")
                        .attr("cx", scaleNumbers(op.num1))
                        .attr("cy", 0)
                        .attr("class", "highlight-path");

                    let mover2;
                    if (op.type !== 'power') {
                        mover2 = animGroup.append("circle")
                            .attr("r", 10)
                            .attr("fill", "#3498db")
                            .attr("cx", scaleNumbers(op.num2))
                            .attr("cy", 0)
                            .attr("class", "highlight-path");
                    }

                    // 下移动画
                    const pathDown1 = animGroup.append("path")
                        .attr("d", `M${scaleNumbers(op.num1)},0 Q${scaleNumbers(op.num1)},75 ${scaleLogs(op.log1)},150`)
                        .attr("stroke", "#e67e22")
                        .attr("stroke-width", 2)
                        .attr("fill", "none")
                        .attr("class", "highlight-path");

                    const len1 = pathDown1.node().getTotalLength();
                    pathDown1.attr("stroke-dasharray", len1 + " " + len1)
                        .attr("stroke-dashoffset", len1)
                        .transition().delay(scaledDelay(500)).duration(scaledDuration(1000)).attr("stroke-dashoffset", 0);

                    mover1.transition().delay(scaledDelay(500)).duration(scaledDuration(1000))
                        .attr("cx", scaleLogs(op.log1))
                        .attr("cy", 150);

                    if (mover2) {
                        const pathDown2 = animGroup.append("path")
                            .attr("d", `M${scaleNumbers(op.num2)},0 Q${scaleNumbers(op.num2)},75 ${scaleLogs(op.log2)},150`)
                            .attr("stroke", "#3498db")
                            .attr("stroke-width", 2)
                            .attr("fill", "none")
                            .attr("class", "highlight-path");

                        const len2 = pathDown2.node().getTotalLength();
                        pathDown2.attr("stroke-dasharray", len2 + " " + len2)
                            .attr("stroke-dashoffset", len2)
                            .transition().delay(scaledDelay(500)).duration(scaledDuration(1000)).attr("stroke-dashoffset", 0);

                        mover2.transition().delay(scaledDelay(500)).duration(scaledDuration(1000))
                            .attr("cx", scaleLogs(op.log2))
                            .attr("cy", 150);
                    }

                    await new Promise(resolve => setTimeout(resolve, scaledDelay(1500)));
                }

                async function step3() {
                    await waitForResume();
                    // 显示对数公式
                    const formulaG = animGroup.append("g");
                    formulaG.append("rect")
                        .attr("x", innerWidth/2 - 180)
                        .attr("y", 200)
                        .attr("width", 360)
                        .attr("height", 40)
                        .attr("fill", "#e8f4f8")
                        .attr("stroke", "#2980b9")
                        .attr("stroke-width", 2)
                        .attr("rx", 8);

                    let latexFormula = (logFormula || "")
                        .replace(/×/g, "\\times")
                        .replace(/÷/g, "\\div")
                        .replace(/−/g, "-");

                    const formulaFO = formulaG.append("foreignObject")
                        .attr("x", innerWidth/2 - 180)
                        .attr("y", 200)
                        .attr("width", 360)
                        .attr("height", 40)
                        .style("opacity", 0);

                    formulaFO.html(`<div xmlns="http://www.w3.org/1999/xhtml" style="font-size:16px;font-weight:bold;color:#2980b9;text-align:center;line-height:40px;">$${latexFormula}$</div>`);

                    if (window.MathJax && window.MathJax.typesetPromise) {
                        try {
                            await window.MathJax.typesetPromise([formulaFO.node()]);
                        } catch (error) {
                            console.warn('MathJax rendering failed:', error);
                        }
                    }

                    formulaFO.transition().duration(scaledDuration(1000)).style("opacity", 1);
                    await new Promise(resolve => setTimeout(resolve, scaledDelay(1500)));
                }

                async function step4() {
                    await waitForResume();
                    // 移动到结果位置
                    const mover1 = animGroup.select("circle");
                    mover1.transition().duration(scaledDuration(1000))
                        .attr("cx", scaleLogs(logResult))
                        .attr("fill", "#2ecc71");

                    const mover2 = animGroup.selectAll("circle").filter((d, i) => i === 1);
                    if (!mover2.empty()) {
                        mover2.transition().duration(scaledDuration(1000))
                            .attr("cx", scaleLogs(logResult))
                            .style("opacity", 0);
                    }

                    await new Promise(resolve => setTimeout(resolve, scaledDelay(1500)));
                }

                async function step5() {
                    await waitForResume();
                    // 上移动画
                    const pathUp = animGroup.append("path")
                        .attr("d", `M${scaleLogs(logResult)},150 Q${scaleLogs(logResult)},75 ${scaleNumbers(numResult)},0`)
                        .attr("stroke", "#2ecc71")
                        .attr("stroke-width", 2)
                        .attr("fill", "none")
                        .attr("class", "highlight-path");

                    const lenUp = pathUp.node().getTotalLength();
                    pathUp.attr("stroke-dasharray", lenUp + " " + lenUp)
                        .attr("stroke-dashoffset", lenUp)
                        .transition().duration(scaledDuration(1000)).attr("stroke-dashoffset", 0);

                    const mover1 = animGroup.select("circle");
                    mover1.transition().duration(scaledDuration(1000))
                        .attr("cy", 0)
                        .attr("cx", scaleNumbers(numResult));

                    await new Promise(resolve => setTimeout(resolve, scaledDelay(1000)));
                }

                async function step6() {
                    await waitForResume();
                    // 显示最终结果
                    const resultBox = animGroup.append("g");
                    resultBox.append("rect")
                        .attr("x", innerWidth/2 + 300)
                        .attr("y", -130)
                        .attr("width", 200)
                        .attr("height", 50)
                        .attr("class", "result-box")
                        .style("opacity", 0)
                        .transition().duration(scaledDuration(1000)).style("opacity", 1);

                    resultBox.append("text")
                        .attr("x", innerWidth/2 + 400)
                        .attr("y", -100)
                        .attr("text-anchor", "middle")
                        .style("font-size", "26px")
                        .style("font-weight", "bold")
                        .style("fill", "white")
                        .text(`答案: ${numResult}`)
                        .style("opacity", 0)
                        .transition().duration(scaledDuration(1000)).style("opacity", 1);

                    await new Promise(resolve => setTimeout(resolve, scaledDelay(2000)));
                    resolve();
                }

                // 依次执行所有步骤
                (async () => {
                    await step1();
                    await step2();
                    await step3();
                    await step4();
                    await step5();
                    await step6();
                })();
            });
        }

        async function cycleAnimations() {
            animationState.cycleActive = true;
            currentAnimation = {
                interrupt: () => {
                    animationState.cycleActive = false;
                    svg.selectAll("*").interrupt();
                }
            };

            while (animationState.cycleActive) {
                for (let i = 0; i < operations.length; i++) {
                    if (!animationState.cycleActive) break;
                    animationState.currentOperationIndex = i;
                    await animateOperation(operations[i]);
                    if (!animationState.cycleActive) break;
                    await new Promise(resolve => setTimeout(resolve, scaledDelay(2000)));
                }
            }
        }

        cycleAnimations();

        // 确保SVG中的公式正确渲染
        const ensureSVGMathRendering = () => {
            if (window.MathJax && window.MathJax.typesetPromise) {
                setTimeout(async () => {
                    try {
                        await renderMathJaxInSVG(svg.node());
                    } catch (error) {
                        console.warn('SVG Math rendering failed:', error);
                    }
                }, 500);
            }
        };

        // 监听SVG内容变化，自动重新渲染公式
        const observer = new MutationObserver(() => {
            ensureSVGMathRendering();
        });

        observer.observe(svg.node(), {
            childList: true,
            subtree: true
        });
    }

    /**
     * 第10页：对数性质可视化
     * 功能：展示对数运算性质的具体应用
     * 内容：乘积、商、幂的对数性质及换底公式
     * 动画：公式展示和计算验证
     * 教学目标：深入理解对数运算性质
     */
    function visualizeLogProperties(containerId) {
        const container = d3.select(`#${containerId}`);
        if(container.empty()) return;

        // 清除之前的内容
        container.html('');

        // 创建SVG并整体上移
        const svg = container.append('svg')
            .attr('width', '100%')
            .attr('height', '100%')
            .style('margin-top', '-60px');

        const bounds = container.node().getBoundingClientRect();
        const width = bounds.width, height = bounds.height;
        const centerX = width / 2;

        const properties = [
            { title: "乘法在对数世界变成加法", formula: "\\log(x \\cdot y) = \\log(x) + \\log(y)", y: height*0.2, color1: "#3498db", color2: "#e74c3c", operator: "+", animation: "merge" },
            { title: "除法在对数世界变成减法", formula: "\\log\\left(\\frac{x}{y}\\right) = \\log(x) - \\log(y)", y: height*0.5, color1: "#27ae60", color2: "#f39c12", operator: "-", animation: "separate" },
            { title: "幂在对数世界变成乘法", formula: "\\log(x^n) = n \\cdot \\log(x)", y: height*0.8, color1: "#9b59b6", color2: "#e67e22", operator: "×", animation: "multiply" }
        ];

        properties.forEach((prop, index) => {
            const propGroup = svg.append("g").attr("transform", `translate(${centerX}, ${prop.y})`);

            // 增加透明度和添加边框以提高可见性
            const circle1 = propGroup.append("circle")
                .attr("cx", -80)
                .attr("r", 35)
                .attr("fill", prop.color1)
                .attr("opacity", 1)
                .attr("stroke", "#2c3e50")
                .attr("stroke-width", 3);
            const circle2 = propGroup.append("circle")
                .attr("cx", 80)
                .attr("r", 35)
                .attr("fill", prop.color2)
                .attr("opacity", 1)
                .attr("stroke", "#2c3e50")
                .attr("stroke-width", 3);
            // 增大操作符字体
            const operatorText = propGroup.append("text")
                .attr("y", 5)
                .attr("text-anchor", "middle")
                .style("font-size", "40px")
                .style("font-weight", "bold")
                .style("fill", "#2c3e50")
                .text(prop.operator);
            propGroup.append("text").attr("x", -80).attr("y", 8).attr("text-anchor", "middle").style("fill", "#2c3e50").style("font-weight", "bold").style("font-size", "16px").text(index === 2 ? "log(x)" : "log(x)");
            propGroup.append("text").attr("x", 80).attr("y", 8).attr("text-anchor", "middle").style("fill", "#2c3e50").style("font-weight", "bold").style("font-size", "16px").text(index === 2 ? "n" : "log(y)");
            // 使用foreignObject来显示标题，放在左侧
            const titleFO = propGroup.append("foreignObject")
                .attr("x", -290)
                .attr("y", -15)
                .attr("width", 250)
                .attr("height", 30)
                .style("opacity", 0);

            const titleDiv = titleFO.append("xhtml:div")
                .style("font-size", "14px")
                .style("text-align", "left")
                .style("color", "#2c3e50")
                .style("font-weight", "bold")
                .text(prop.title);

            titleFO.transition().delay(index * 500).duration(500).style("opacity", 1);

            // 使用foreignObject来正确渲染MathJax公式
            const formulaFO = propGroup.append("foreignObject")
                .attr("x", -250)
                .attr("y", 30)
                .attr("width", 300)
                .attr("height", 80)
                .style("color", "#8B0000")

                .style("opacity", 0);

            const formulaDiv = formulaFO.append("xhtml:div")
                .style("text-align", "center")
                .html(`$$${prop.formula}$$`);

            formulaFO.transition().delay(index * 500 + 300).duration(500).style("opacity", 1);

            function animateProperty() {
                 if (prop.animation === "merge") {
                    circle1.transition().duration(2000).attr("cx", 0).transition().duration(1000).attr("r", 40).transition().duration(2000).attr("cx", -80).attr("r", 30);
                    circle2.transition().duration(2000).attr("cx", 0).transition().duration(1000).attr("r", 40).transition().duration(2000).attr("cx", 80).attr("r", 30);
                 } else if (prop.animation === "separate") {
                    circle1.transition().duration(2000).attr("cx", -100).transition().duration(1000).attr("cx", -80);
                    circle2.transition().duration(2000).attr("cx", 100).attr("opacity", 0.3).transition().duration(1000).attr("cx", 80).attr("opacity", 0.7);
                 } else if (prop.animation === "multiply") {
                    circle1.transition().duration(1000).attr("r", 40).transition().duration(1000).attr("r", 30).transition().duration(1000).attr("r", 40).transition().duration(1000).attr("r", 30);
                    circle2.transition().duration(1000).attr("r", 25).transition().duration(1000).attr("r", 35).transition().duration(1000).attr("r", 25).transition().duration(1000).attr("r", 30);
                 }
            }
            setTimeout(() => { animateProperty(); setInterval(animateProperty, 6000); }, index * 1000);
        });

        // 渲染数学公式
        setTimeout(async () => {
            try {
                // 先渲染容器
                await renderMathJaxInContainer(containerId);
                // 再专门渲染SVG中的公式
                if (window.MathJax && window.MathJax.typesetPromise) {
                    const container = document.getElementById(containerId);
                    if (container) {
                        const foreignObjects = container.querySelectorAll('foreignObject');
                        if (foreignObjects.length > 0) {
                            // 确保foreignObject有正确的尺寸
                            foreignObjects.forEach(fo => {
                                if (!fo.getAttribute('width') || fo.getAttribute('width') === 'NaN') {
                                    fo.setAttribute('width', '300');
                                }
                                if (!fo.getAttribute('height') || fo.getAttribute('height') === 'NaN') {
                                    fo.setAttribute('height', '40');
                                }
                            });
                            // 强制重新渲染MathJax
                            await window.MathJax.typesetPromise(Array.from(foreignObjects));
                            console.log('MathJax rendering completed for log properties');
                        }
                    }
                }
            } catch (error) {
                console.warn('SVG MathJax rendering failed:', error);
            }
        }, 1500);
    }

    /**
     * 第11页：常用对数系统可视化
     * 功能：比较常用对数(lg)和自然对数(ln)
     * 内容：以10为底和以e为底的对数系统
     * 动画：对数值的计算和比较
     * 教学目标：了解两种重要的对数系统
     */
    function visualizeCommonLogs(containerId) {
        const svg = d3.select("#animation5");
        if(svg.empty()) return;
        svg.selectAll("*").remove();
        const bounds = svg.node().getBoundingClientRect();
        const width = bounds.width, height = bounds.height;
        const centerX = width / 2;

        svg.append("text").attr("x", centerX).attr("y", 40).attr("text-anchor", "middle").style("font-size", "18px").style("font-weight", "bold").text("常用对数与自然对数对比");

        const lgGroup = svg.append("g").attr("transform", `translate(${width*0.1}, 80)`);
        lgGroup.append("text").text("常用对数 (lg)").style("font-size", "16px").style("font-weight", "bold").style("fill", "#e74c3c");
        [{input: "10", output: "1"}, {input: "100", output: "2"}, {input: "1000", output: "3"}].forEach((ex, i) => {
            const y = 30 + i * 40;
            const g = lgGroup.append("g").style("opacity", 0);
            g.append("rect").attr("y", y).attr("width", 150).attr("height", 30).attr("fill", "#ffebee").attr("stroke", "#e74c3c").attr("rx", 5);
            g.append("text").text(`lg(${ex.input}) = ${ex.output}`).attr("x", 75).attr("y", y + 20).attr("text-anchor", "middle").style("font-size", "14px");
            g.transition().delay(500 + i * 300).duration(500).style("opacity", 1);
        });

        const lnGroup = svg.append("g").attr("transform", `translate(${width*0.9 - 150}, 80)`);
        lnGroup.append("text").text("自然对数 (ln)").style("font-size", "16px").style("font-weight", "bold").style("fill", "#27ae60");
        [{input: "e", output: "1"}, {input: "e²", output: "2"}, {input: "1", output: "0"}].forEach((ex, i) => {
            const y = 30 + i * 40;
            const g = lnGroup.append("g").style("opacity", 0);
            g.append("rect").attr("y", y).attr("width", 150).attr("height", 30).attr("fill", "#e8f5e8").attr("stroke", "#27ae60").attr("rx", 5);
            g.append("text").text(`ln(${ex.input}) = ${ex.output}`).attr("x", 75).attr("y", y + 20).attr("text-anchor", "middle").style("font-size", "14px");
            g.transition().delay(1500 + i * 300).duration(500).style("opacity", 1);
        });

        const curveGroup = svg.append("g").attr("transform", `translate(50, ${height-150})`);
        const xScale = d3.scaleLinear().domain([0.1, 10]).range([0, width - 100]);
        const yScale = d3.scaleLinear().domain([-2, 3]).range([120, 0]);

        curveGroup.append("line").attr("x1", 0).attr("y1", yScale(0)).attr("x2", width-100).attr("y2", yScale(0)).attr("stroke", "#333");
        curveGroup.append("line").attr("x1", xScale(1)).attr("y1", 0).attr("x2", xScale(1)).attr("y2", 120).attr("stroke", "#333");

        // 绘制lg(x)函数曲线
        const lgLine = d3.line().x(d => xScale(d)).y(d => yScale(Math.log10(d))).curve(d3.curveMonotoneX);
        const lgData = d3.range(0.1, 10, 0.1);
        curveGroup.append("path").datum(lgData).attr("fill", "none").attr("stroke", "#e74c3c").attr("stroke-width", 3).attr("d", lgLine).style("opacity", 0).transition().delay(3000).duration(1000).style("opacity", 1);

        // 绘制ln(x)函数曲线
        const lnLine = d3.line().x(d => xScale(d)).y(d => yScale(Math.log(d))).curve(d3.curveMonotoneX);
        const lnData = d3.range(0.1, 10, 0.1);
        curveGroup.append("path").datum(lnData).attr("fill", "none").attr("stroke", "#27ae60").attr("stroke-width", 3).attr("d", lnLine).style("opacity", 0).transition().delay(3500).duration(1000).style("opacity", 1);

        // 添加函数标签
        curveGroup.append("text").text("y = lg(x)").attr("x", xScale(8)).attr("y", yScale(0.9)).style("fill", "#e74c3c").style("font-weight", "bold").style("font-size", "14px");
        curveGroup.append("text").text("y = ln(x)").attr("x", xScale(6)).attr("y", yScale(1.8)).style("fill", "#27ae60").style("font-weight", "bold").style("font-size", "14px");

        // 标记重要点
        setTimeout(() => {
            // lg(x)的重要点
            [[1, 0], [10, 1]].forEach(([x, y], i) => {
                const point = curveGroup.append("g");
                point.append("circle")
                    .attr("cx", xScale(x))
                    .attr("cy", yScale(y))
                    .attr("r", 0)
                    .attr("fill", "#e74c3c")
                    .attr("stroke", "#c0392b")
                    .attr("stroke-width", 2)
                    .transition()
                    .delay(i * 300)
                    .duration(500)
                    .attr("r", 4);

                point.append("text")
                    .attr("x", xScale(x))
                    .attr("y", yScale(y) - 10)
                    .attr("text-anchor", "middle")
                    .style("font-size", "10px")
                    .style("fill", "#e74c3c")
                    .style("font-weight", "bold")
                    .style("opacity", 0)
                    .text(`(${x}, ${y})`)
                    .transition()
                    .delay(i * 300 + 200)
                    .duration(500)
                    .style("opacity", 1);
            });

            // ln(x)的重要点
            [[1, 0], [Math.E, 1]].forEach(([x, y], i) => {
                const point = curveGroup.append("g");
                point.append("circle")
                    .attr("cx", xScale(x))
                    .attr("cy", yScale(y))
                    .attr("r", 0)
                    .attr("fill", "#27ae60")
                    .attr("stroke", "#1e8449")
                    .attr("stroke-width", 2)
                    .transition()
                    .delay(500 + i * 300)
                    .duration(500)
                    .attr("r", 4);

                const label = i === 0 ? "(1, 0)" : "(e, 1)";
                point.append("text")
                    .attr("x", xScale(x))
                    .attr("y", yScale(y) + (i === 0 ? 15 : -10))
                    .attr("text-anchor", "middle")
                    .style("font-size", "10px")
                    .style("fill", "#27ae60")
                    .style("font-weight", "bold")
                    .style("opacity", 0)
                    .text(label)
                    .transition()
                    .delay(500 + i * 300 + 200)
                    .duration(500)
                    .style("opacity", 1);
            });
        }, 4500);

        // 渲染数学公式
        setTimeout(() => {
            renderMathJaxInContainer(containerId);
        }, 4000);
    }

    function createPlot(containerId, func, xDomain, yDomain, title) {
        const setup = setupD3(containerId);
        if (!setup) return null;
        const { svg, g, width, height } = setup;

        if(title) {
            g.append("text").attr("x", width/2).attr("y", -15).html(title).attr("text-anchor", "middle").attr("font-size", "1.2em").attr("fill", "var(--text-color)");
        }

        const xScale = d3.scaleLinear().domain(xDomain).range([0, width]);
        const yScale = d3.scaleLinear().domain(yDomain).range([height, 0]);
        drawAxes(g, xScale, yScale, width, height);

        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y))
            .defined(d => isFinite(d.y));

        const data = d3.range(xDomain[0], xDomain[1], (xDomain[1] - xDomain[0]) / 200)
            .map(x => ({x: x, y: func(x)}));

        const path = g.append("path")
            .datum(data)
            .attr("fill", "none")
            .attr("stroke", "var(--primary-color)")
            .attr("stroke-width", 2.5)
            .attr("d", line);

        animatePath(path);
        return { g, xScale, yScale, width, height };
    }




    /**
     * 第12页：常量与变量可视化
     * 功能：动态展示常量和变量的概念
     * 内容：π、e等常量，x、y等变量的区别
     * 动画：数值变化演示
     * 教学目标：理解常量和变量的基本概念
     */
    function visualizeVariables(containerId) {
        const setup = setupD3(containerId);
        if (!setup) return;
        const { g, width, height } = setup;

        g.append("circle").attr("cx", width * 0.25).attr("cy", height * 0.5).attr("r", 10).attr("fill", "var(--danger-color)");
        g.append("text").attr("x", width * 0.25).attr("y", height * 0.5 + 40).text("常量 π").attr("text-anchor", "middle").attr("font-size", "1.2em");

        g.append("line").attr("x1", width * 0.6).attr("y1", height * 0.5).attr("x2", width * 0.9).attr("y2", height * 0.5).attr("stroke", "#ccc").attr("stroke-width", 2);
        const variablePoint = g.append("circle").attr("cy", height * 0.5).attr("r", 10).attr("fill", "var(--primary-color)");
        g.append("text").attr("x", width * 0.75).attr("y", height * 0.5 + 40).text("变量 x").attr("text-anchor", "middle").attr("font-size", "1.2em");

        function movePoint() {
            variablePoint.attr("cx", width * 0.6)
                .transition().duration(2000).attr("cx", width * 0.9)
                .transition().duration(2000).attr("cx", width * 0.6)
                .on("end", movePoint);
        }
        movePoint();

        // 渲染数学公式
        setTimeout(() => {
            renderMathJaxInContainer(containerId);
        }, 1000);
    }

    /**
     * 绘制ln(x)函数图像
     * 教学目标：理解自然对数函数的图像特征和性质
     */
    function visualizeLnFunction(containerId) {
        const setup = setupD3(containerId);
        if (!setup) return;
        const { g, width, height } = setup;

        // 设置坐标轴范围
        const xScale = d3.scaleLinear().domain([0, 5]).range([0, width]);
        const yScale = d3.scaleLinear().domain([-3, 2]).range([height, 0]);

        // 绘制坐标轴
        drawAxes(g, xScale, yScale, width, height);

        // 添加坐标轴标签
        g.append("text")
            .attr("x", width / 2)
            .attr("y", height + 35)
            .attr("text-anchor", "middle")
            .style("font-size", "14px")
            .text("x");

        g.append("text")
            .attr("x", -35)
            .attr("y", height / 2)
            .attr("text-anchor", "middle")
            .attr("transform", `rotate(-90, -35, ${height / 2})`)
            .style("font-size", "14px")
            .text("y");

        // 添加函数标题
        g.append("text")
            .attr("x", width / 2)
            .attr("y", -10)
            .attr("text-anchor", "middle")
            .style("font-size", "18px")
            .style("font-weight", "bold")
            .style("fill", "#2c3e50")
            .text("对数函数对比：ln(x) vs lg(x)");

        // 生成ln(x)函数的数据点
        const lnData = [];
        for (let x = 0.1; x <= 5; x += 0.05) {
            lnData.push({
                x: x,
                y: Math.log(x)  // 自然对数
            });
        }

        // 生成lg(x)函数的数据点
        const lgData = [];
        for (let x = 0.1; x <= 5; x += 0.05) {
            lgData.push({
                x: x,
                y: Math.log10(x)  // 常用对数
            });
        }

        // 创建线条生成器
        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y))
            .curve(d3.curveCardinal);

        // 绘制ln(x)函数曲线（红色）
        const lnPath = g.append("path")
            .datum(lnData)
            .attr("fill", "none")
            .attr("stroke", "#e74c3c")
            .attr("stroke-width", 3)
            .attr("d", line);

        // 绘制lg(x)函数曲线（蓝色）
        const lgPath = g.append("path")
            .datum(lgData)
            .attr("fill", "none")
            .attr("stroke", "#3498db")
            .attr("stroke-width", 3)
            .attr("d", line);

        // 动画绘制曲线
        animatePath(lnPath);
        setTimeout(() => animatePath(lgPath), 1000);

        // 标记重要点
        const importantPoints = [
            // ln(x)的重要点（红色）
            { x: 1, y: 0, label: "(1, 0)", color: "#e74c3c", func: "ln" },
            { x: Math.E, y: 1, label: "(e, 1)", color: "#e74c3c", func: "ln" },
            // lg(x)的重要点（蓝色）
            { x: 1, y: 0, label: "(1, 0)", color: "#3498db", func: "lg" },
            { x: 10, y: 1, label: "(10, 1)", color: "#3498db", func: "lg" },
            { x: 100, y: 2, label: "(100, 2)", color: "#3498db", func: "lg" }
        ];

        setTimeout(() => {
            importantPoints.forEach((point, i) => {
                setTimeout(() => {
                    const pointGroup = g.append("g");

                    // 绘制点
                    pointGroup.append("circle")
                        .attr("cx", xScale(point.x))
                        .attr("cy", yScale(point.y))
                        .attr("r", 0)
                        .attr("fill", point.color)
                        .attr("stroke", point.color)
                        .attr("stroke-width", 2)
                        .transition()
                        .duration(500)
                        .attr("r", 6);

                    // 添加标签
                    pointGroup.append("text")
                        .attr("x", xScale(point.x))
                        .attr("y", yScale(point.y) - 15)
                        .attr("text-anchor", "middle")
                        .style("font-size", "12px")
                        .style("font-weight", "bold")
                        .style("fill", "#2c3e50")
                        .style("opacity", 0)
                        .text(point.label)
                        .transition()
                        .delay(300)
                        .duration(500)
                        .style("opacity", 1);
                }, i * 800);
            });
        }, 2000);

        // 添加函数图例和性质说明
        setTimeout(() => {
            const legendGroup = g.append("g");

            // 图例
            legendGroup.append("line")
                .attr("x1", width - 180)
                .attr("y1", 25)
                .attr("x2", width - 160)
                .attr("y2", 25)
                .attr("stroke", "#e74c3c")
                .attr("stroke-width", 3);

            legendGroup.append("text")
                .attr("x", width - 155)
                .attr("y", 30)
                .style("font-size", "12px")
                .style("fill", "#e74c3c")
                .style("font-weight", "bold")
                .text("y = ln(x)");

            legendGroup.append("line")
                .attr("x1", width - 180)
                .attr("y1", 45)
                .attr("x2", width - 160)
                .attr("y2", 45)
                .attr("stroke", "#3498db")
                .attr("stroke-width", 3);

            legendGroup.append("text")
                .attr("x", width - 155)
                .attr("y", 50)
                .style("font-size", "12px")
                .style("fill", "#3498db")
                .style("font-weight", "bold")
                .text("y = lg(x)");

            // 共同性质
            const properties = [
                "共同性质:",
                "• 定义域: (0, +∞)",
                "• 值域: (-∞, +∞)",
                "• 都过点 (1, 0)",
                "• 都单调递增",
                "",
                "区别:",
                "• ln(x) 增长更快",
                "• lg(x) 增长更慢"
            ];

            properties.forEach((prop, i) => {
                legendGroup.append("text")
                    .attr("x", width - 180)
                    .attr("y", 80 + i * 16)
                    .style("font-size", "10px")
                    .style("fill", "#34495e")
                    .style("font-weight", prop.includes(":") ? "bold" : "normal")
                    .style("opacity", 0)
                    .text(prop)
                    .transition()
                    .delay(i * 200)
                    .duration(500)
                    .style("opacity", 1);
            });
        }, 4000);

        // 渲染数学公式
        setTimeout(() => {
            renderMathJaxInContainer(containerId);
        }, 1000);
    }

    /**
     * 第13页：区间表示法可视化
     * 功能：展示各种区间的数轴表示
     * 内容：闭区间[a,b]、开区间(a,b)、半开半闭区间
     * 动画：数轴上的区间标记和端点表示
     * 教学目标：掌握区间的数学表示方法
     */
    function visualizeIntervals(containerId) {
        const setup = setupD3(containerId);
        if (!setup) return;
        const { g, width, height } = setup;
        const axisY = height * 0.2;

        g.append("line").attr("x1", 0).attr("y1", axisY).attr("x2", width).attr("y2", axisY).attr("stroke", "black");
        g.append("line").attr("x1", width*0.1).attr("y1", axisY).attr("x2", width*0.4).attr("y2", axisY).attr("stroke", "var(--success-color)").attr("stroke-width", 5);
        g.append("circle").attr("cx", width*0.1).attr("cy", axisY).attr("r", 5).attr("fill", "var(--success-color)");
        g.append("circle").attr("cx", width*0.4).attr("cy", axisY).attr("r", 5).attr("fill", "var(--success-color)");
        g.append("text").attr("x", width*0.25).attr("y", axisY + 40).text("闭区间 [a, b]").attr("text-anchor", "middle");

        const axisY2 = height * 0.5;
        g.append("line").attr("x1", 0).attr("y1", axisY2).attr("x2", width).attr("y2", axisY2).attr("stroke", "black");
        g.append("line").attr("x1", width*0.1).attr("y1", axisY2).attr("x2", width*0.4).attr("y2", axisY2).attr("stroke", "var(--warning-color)").attr("stroke-width", 5);
        g.append("circle").attr("cx", width*0.1).attr("cy", axisY2).attr("r", 5).attr("fill", "white").attr("stroke", "var(--warning-color)").attr("stroke-width", 2);
        g.append("circle").attr("cx", width*0.4).attr("cy", axisY2).attr("r", 5).attr("fill", "white").attr("stroke", "var(--warning-color)").attr("stroke-width", 2);
        g.append("text").attr("x", width*0.25).attr("y", axisY2 + 40).text("开区间 (a, b)").attr("text-anchor", "middle");

        const axisY3 = height * 0.8;
        g.append("line").attr("x1", 0).attr("y1", axisY3).attr("x2", width).attr("y2", axisY3).attr("stroke", "black");
        g.append("line").attr("x1", width*0.1).attr("y1", axisY3).attr("x2", width*0.4).attr("y2", axisY3).attr("stroke", "var(--info-color)").attr("stroke-width", 5);
        g.append("circle").attr("cx", width*0.1).attr("cy", axisY3).attr("r", 5).attr("fill", "var(--info-color)");
        g.append("circle").attr("cx", width*0.4).attr("cy", axisY3).attr("r", 5).attr("fill", "white").attr("stroke", "var(--info-color)").attr("stroke-width", 2);
        g.append("text").attr("x", width*0.25).attr("y", axisY3 + 40).text("半开区间 [a, b)").attr("text-anchor", "middle");

        // 渲染数学公式
        setTimeout(() => {
            renderMathJaxInContainer(containerId);
        }, 1000);
    }

    /**
     * 第14页：函数机器可视化
     * 功能：展示四种基本函数的交互式图像，包含自动播放功能
     * 包含：x^2, √x, sin(x), 1/x 四个函数的动态切换
     * 特色：鼠标悬停显示坐标，定义域值域高亮，自动播放循环
     */
    function visualizeFunctionMachine(containerId) {
        const container = d3.select(`#${containerId}`);
        container.html("");
        const width = container.node().clientWidth;
        const height = container.node().clientHeight;
        const margin = { top: 40, right: 40, bottom: 40, left: 40 };
        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;

        const svg = container.append("svg")
            .attr("width", width)
            .attr("height", height)
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

        const functions = {
            'x^2': {
                func: x => x * x,
                domain: [-5, 5],
                range: [0, 25],
                display: 'x^2'
            },
            '\\sqrt{x}': {
                func: x => Math.sqrt(x),
                domain: [0, 25],
                range: [0, 5],
                display: '\\sqrt{x}'
            },
            '\\sin(x)': {
                func: x => Math.sin(x) * 5,
                domain: [-Math.PI * 2, Math.PI * 2],
                range: [-5, 5],
                display: '\\sin(x)'
            },
            '\\frac{1}{x}': {
                func: x => 10 / x,
                domain: [-10, 10],
                range: [-Infinity, Infinity],
                display: '\\frac{1}{x}'
            }
        };

        // Control panel
        const controlPanel = container.append('div')
            .style('position', 'absolute')
            .style('top', '10px')
            .style('left', '10px')
            .style('display', 'flex')
            .style('gap', '10px')
            .style('z-index', '10');

        Object.keys(functions).forEach((name, index) => {
            const button = controlPanel.append('div')
                .style('padding', '8px 12px')
                .style('border', '1px solid #ccc')
                .style('border-radius', '4px')
                .style('background', index === 0 ? '#4a90e2' : '#fff')
                .style('color', index === 0 ? '#fff' : '#333')
                .style('cursor', 'pointer')
                .style('display', 'inline-block')
                .attr('class', index === 0 ? 'active' : '')
                .html(`$f(x) = ${functions[name].display}$`)
                .on('click', function() {
                    controlPanel.selectAll('div')
                        .style('background', '#fff')
                        .style('color', '#333')
                        .attr('class', '');
                    d3.select(this)
                        .style('background', '#4a90e2')
                        .style('color', '#fff')
                        .attr('class', 'active');
                    currentFunction = name;
                    draw(name);
                });
        });

        let x, y;
        let line = d3.line().x(d => x(d.x)).y(d => y(d.y));
        let currentFunction = 'x^2';

        const clipPath = svg.append("clipPath")
            .attr("id", "clip")
            .append("rect")
            .attr("width", innerWidth)
            .attr("height", innerHeight);

        const chartArea = svg.append("g").attr("clip-path", "url(#clip)");
        const xAxis = svg.append("g").attr("class", "x-axis").attr("transform", `translate(0,${innerHeight})`);
        const yAxis = svg.append("g").attr("class", "y-axis");

        const domainShadow = svg.append("rect").attr("fill", "#4a90e2").attr("opacity", 0.3);
        const rangeShadow = svg.append("rect").attr("fill", "#f5a623").attr("opacity", 0.3);

        const path = chartArea.append("path").attr("fill", "none").attr("stroke", "#e74c3c").attr("stroke-width", 3);

        // Function title
        const functionTitle = svg.append("text")
            .attr("x", innerWidth / 2)
            .attr("y", -10)
            .attr("text-anchor", "middle")
            .attr("font-size", "18px")
            .attr("font-weight", "bold")
            .attr("fill", "#2c3e50");

        const focus = svg.append("g").style("display", "none");
        focus.append("circle").attr("r", 5).attr("fill", "#333");
        focus.append("line").attr("class", "x-line").attr("stroke", "#4a90e2").attr("stroke-dasharray", "3,3");
        focus.append("line").attr("class", "y-line").attr("stroke", "#f5a623").attr("stroke-dasharray", "3,3");

        function draw(name) {
            const F = functions[name];
            const data = [];
            for (let i = F.domain[0]; i <= F.domain[1]; i += 0.1) {
                if (name === '\\frac{1}{x}' && Math.abs(i) < 0.1) continue;
                data.push({ x: i, y: F.func(i) });
            }

            const yDomain = name === '\\frac{1}{x}' ? [-10, 10] : d3.extent(data, d => d.y);

            x = d3.scaleLinear().domain(F.domain).range([0, innerWidth]);
            y = d3.scaleLinear().domain(yDomain).range([innerHeight, 0]);

            xAxis.call(d3.axisBottom(x));
            yAxis.call(d3.axisLeft(y));

            // Add axis labels
            svg.selectAll('.axis-label').remove();
            svg.append("text")
                .attr("class", "axis-label")
                .attr("x", innerWidth)
                .attr("y", innerHeight + 35)
                .attr("text-anchor", "end")
                .text("x")
                .attr("font-size", "14px")
                .attr("fill", "#4a90e2");

            svg.append("text")
                .attr("class", "axis-label")
                .attr("x", -5)
                .attr("y", 5)
                .attr("text-anchor", "end")
                .text("y")
                .attr("font-size", "14px")
                .attr("fill", "#f5a623");

            // Add grid lines
            svg.selectAll('.grid').remove();
            svg.append("g").attr('class', 'grid')
                .attr("transform", `translate(0,${innerHeight})`)
                .call(d3.axisBottom(x).ticks(10).tickSize(-innerHeight).tickFormat(""))
                .selectAll("line").attr("stroke", "#eee");
            svg.append("g").attr('class', 'grid')
                .call(d3.axisLeft(y).ticks(10).tickSize(-innerWidth).tickFormat(""))
                .selectAll("line").attr("stroke", "#eee");

            path.datum(data).transition().duration(500).attr("d", line);

            // Update function title
            functionTitle.html(`$f(x) = ${F.display}$`);

            // Render MathJax for the title
            setTimeout(() => {
                if (window.MathJax && window.MathJax.typesetPromise) {
                    window.MathJax.typesetPromise([functionTitle.node()]);
                }
            }, 50);

            // Update shadows
            const domainRange = (name === '\\frac{1}{x}') ? F.domain : d3.extent(data, d=>d.x);
            const rangeRange = d3.extent(data, d=>d.y);

            domainShadow.transition().duration(500)
                .attr("x", x(domainRange[0]))
                .attr("y", innerHeight)
                .attr("width", x(domainRange[1]) - x(domainRange[0]))
                .attr("height", 10);

            rangeShadow.transition().duration(500)
                .attr("x", -10)
                .attr("y", y(rangeRange[1]))
                .attr("width", 10)
                .attr("height", y(rangeRange[0]) - y(rangeRange[1]));

            // Add domain and range labels
            svg.selectAll('.domain-range-label').remove();
            svg.append("text")
                .attr("class", "domain-range-label")
                .attr("x", x((domainRange[0] + domainRange[1]) / 2))
                .attr("y", innerHeight + 25)
                .attr("text-anchor", "middle")
                .text("定义域")
                .attr("font-size", "12px")
                .attr("fill", "#4a90e2");

            svg.append("text")
                .attr("class", "domain-range-label")
                .attr("x", -25)
                .attr("y", y((rangeRange[0] + rangeRange[1]) / 2))
                .attr("text-anchor", "middle")
                .attr("transform", `rotate(-90, -25, ${y((rangeRange[0] + rangeRange[1]) / 2)})`)
                .text("值域")
                .attr("font-size", "12px")
                .attr("fill", "#f5a623");
        }

        svg.append("rect")
            .attr("width", innerWidth)
            .attr("height", innerHeight)
            .style("fill", "none")
            .style("pointer-events", "all")
            .on("mouseover", () => focus.style("display", null))
            .on("mouseout", () => focus.style("display", "none"))
            .on("mousemove", mousemove);

        function mousemove(event) {
            const [mx, my] = d3.pointer(event);
            const x0 = x.invert(mx);
            const F = functions[currentFunction];
            const y0 = F.func(x0);

            if (isNaN(y0) || y0 === Infinity || y0 === -Infinity) {
                focus.style("display", "none");
                return;
            }
            focus.style("display", null);

            focus.attr("transform", `translate(${x(x0)},${y(y0)})`);
            focus.select(".x-line")
                .attr("x1", 0)
                .attr("y1", 0)
                .attr("x2", -x(x0))
                .attr("y2", 0);
            focus.select(".y-line")
                .attr("x1", 0)
                .attr("y1", 0)
                .attr("x2", 0)
                .attr("y2", innerHeight - y(y0));
        }

        // Auto-play functionality
        let autoPlayIndex = 0;
        const functionNames = Object.keys(functions);

        function autoPlay() {
            const name = functionNames[autoPlayIndex];

            // Update button appearance
            controlPanel.selectAll('div')
                .style('background', '#fff')
                .style('color', '#333')
                .attr('class', '');
            controlPanel.select(`div:nth-child(${autoPlayIndex + 1})`)
                .style('background', '#4a90e2')
                .style('color', '#fff')
                .attr('class', 'active');

            currentFunction = name;
            draw(name);

            // Re-render MathJax for control panel after auto-play update
            setTimeout(() => {
                renderMathJaxInContainer(containerId);
            }, 100);

            autoPlayIndex = (autoPlayIndex + 1) % functionNames.length;
        }

        // Start with initial function
        draw('x^2');

        // Render MathJax for control panel
        setTimeout(() => {
            renderMathJaxInContainer(containerId);
        }, 100);

        // Auto-play every 3 seconds
        const autoPlayInterval = setInterval(autoPlay, 3000);

        // Store cleanup function
        container.node().cleanup = () => clearInterval(autoPlayInterval);
    }

    /**
     * 第15页：定义域可视化
     * 功能：通过函数机器和粒子动画演示定义域概念
     * 函数：f(x) = √(x-2)，要求 x ≥ 2
     * 动画：有效输入通过机器，无效输入被弹开
     * 教学目标：理解定义域是函数有意义的自变量取值范围
     */
    function visualizeDomain(containerId) {
        const container = d3.select(`#${containerId}`);
        container.html(""); // Clear previous content
        const width = container.node().clientWidth;
        const height = container.node().clientHeight;
        const svg = container.append("svg").attr("width", width).attr("height", height);

        const machine = { x: width / 2, y: height / 2, width: 150, height: 100 };

        // Function machine body
        svg.append("rect")
            .attr("x", machine.x - machine.width / 2)
            .attr("y", machine.y - machine.height / 2)
            .attr("width", machine.width)
            .attr("height", machine.height)
            .attr("rx", 10)
            .attr("fill", "#4a90e2")
            .attr("stroke", "#357ABD")
            .attr("stroke-width", 3);

        // Function label
        svg.append("text").text("f(x) = √(x-2)")
            .attr("x", machine.x)
            .attr("y", machine.y)
            .attr("text-anchor", "middle")
            .attr("dy", ".3em")
            .attr("fill", "black")
            .style("font-size", "18px")
            .style("font-weight", "bold");

        // Input funnel
        svg.append("path")
            .attr("d", `M ${machine.x - 50} ${machine.y - machine.height/2 - 50} L ${machine.x - 25} ${machine.y - machine.height/2} H ${machine.x + 25} L ${machine.x + 50} ${machine.y - machine.height/2 - 50} Z`)
            .attr("fill", "#a2cffe");

        // Number line for domain
        const numLineY = height - 50;
        const scaleX = d3.scaleLinear().domain([-2, 10]).range([50, width - 50]);
        svg.append("line")
            .attr("x1", scaleX.range()[0])
            .attr("y1", numLineY)
            .attr("x2", scaleX.range()[1])
            .attr("y2", numLineY)
            .attr("stroke", "#333");

        // Ticks and labels for number line
        scaleX.ticks(13).forEach(tick => {
            svg.append("line")
                .attr("x1", scaleX(tick)).attr("y1", numLineY - 5)
                .attr("x2", scaleX(tick)).attr("y2", numLineY + 5)
                .attr("stroke", "#333");
            svg.append("text").text(tick)
                .attr("x", scaleX(tick)).attr("y", numLineY + 20)
                .attr("text-anchor", "middle").style("font-size", "12px");
        });

        // Highlight domain on number line
        svg.append("rect")
            .attr("x", scaleX(2))
            .attr("y", numLineY - 10)
            .attr("width", scaleX(20) - scaleX(2))
            .attr("height", 20)
            .attr("fill", "#50e3c2")
            .attr("opacity", 0.5);

        svg.append("text").text("定义域: x ≥ 2")
            .attr("x", scaleX(6))
            .attr("y", numLineY - 25)
            .attr("text-anchor", "middle")
            .style("font-weight", "bold")
            .style("fill", "#2c3e50");

        function generateParticle() {
            const value = Math.floor(Math.random() * 12) - 1; // from -1 to 10
            const isValid = value >= 2;
            const particle = svg.append("g")
                .attr("transform", `translate(${width * 0.2}, ${height * 0.2 + (Math.random() - 0.5) * 50})`);

            particle.append("circle").attr("r", 15).attr("fill", isValid ? "#50e3c2" : "#e74c3c");
            particle.append("text").text(value)
                .attr("text-anchor", "middle")
                .attr("dy", ".3em")
                .attr("fill", "black")
                .style("font-size", "14px");

            let transition = particle.transition()
                .duration(2000)
                .ease(d3.easeQuadIn)
                .attr("transform", `translate(${machine.x}, ${machine.y - machine.height/2 - 20})`);

            if (isValid) {
                transition.transition()
                    .duration(1000)
                    .attr("transform", `translate(${machine.x}, ${machine.y + machine.height/2 + 20})`)
                    .style("opacity", 0)
                    .remove();
            } else {
                transition.transition()
                    .duration(1000)
                    .ease(d3.easeBounceOut)
                    .attr("transform", `translate(${machine.x + (Math.random() - 0.5) * 200}, ${machine.y - machine.height - 100})`)
                    .style("opacity", 0)
                    .remove();
            }
        }

        const interval = setInterval(generateParticle, 1000);

        // Store cleanup function
        container.node().cleanup = () => clearInterval(interval);
    }

    /**
     * 第16页：值域可视化
     * 功能：通过输入输出动画演示值域概念
     * 函数：f(x) = x²，值域为 y ≥ 0
     * 动画：输入值经过平方运算后显示在值域轴上
     * 教学目标：理解值域是函数所有可能输出值的集合
     */
    function visualizeRange(containerId) {
        const container = d3.select(`#${containerId}`);
        container.html("");
        const width = container.node().clientWidth;
        const height = container.node().clientHeight;
        const svg = container.append("svg").attr("width", width).attr("height", height);

        const machine = { x: width / 2, y: height / 2, width: 150, height: 100 };

        svg.append("rect")
            .attr("x", machine.x - machine.width / 2)
            .attr("y", machine.y - machine.height / 2)
            .attr("width", machine.width)
            .attr("height", machine.height)
            .attr("rx", 10)
            .attr("fill", "#4a90e2");

        svg.append("text").text("f(x) = x²")
            .attr("x", machine.x)
            .attr("y", machine.y)
            .attr("text-anchor", "middle")
            .attr("dy", ".3em")
            .attr("fill", "black")
            .style("font-size", "20px");

        // Number line for range
        const numLineX = width - 100;
        const scaleY = d3.scaleLinear().domain([-2, 10]).range([height - 50, 50]);
        svg.append("line")
            .attr("x1", numLineX).attr("y1", scaleY.range()[0])
            .attr("x2", numLineX).attr("y2", scaleY.range()[1])
            .attr("stroke", "#333");

        scaleY.ticks(13).forEach(tick => {
            svg.append("line")
                .attr("x1", numLineX - 5).attr("y1", scaleY(tick))
                .attr("x2", numLineX + 5).attr("y2", scaleY(tick))
                .attr("stroke", "#333");
            svg.append("text").text(tick)
                .attr("x", numLineX + 10).attr("y", scaleY(tick) + 4)
                .style("font-size", "12px");
        });

        const rangeHighlight = svg.append("rect")
            .attr("x", numLineX - 10)
            .attr("y", scaleY(10))
            .attr("width", 20)
            .attr("height", scaleY(0) - scaleY(10))
            .attr("fill", "#f5a623")
            .attr("opacity", 0.5);

        svg.append("text").text("值域: y ≥ 0")
            .attr("x", numLineX)
            .attr("y", scaleY(10) - 10)
            .attr("text-anchor", "middle")
            .style("font-weight", "bold")
            .style("fill", "#2c3e50");

        function generateParticle() {
            const value = (Math.random() * 6) - 3; // from -3 to 3
            const outputValue = value * value;

            const particle = svg.append("g")
                .attr("transform", `translate(${50}, ${machine.y + (Math.random() - 0.5) * 100})`);

            particle.append("circle").attr("r", 15).attr("fill", "#50e3c2");
            particle.append("text").text(value.toFixed(1))
                .attr("text-anchor", "middle").attr("dy", ".3em").attr("fill", "black");

            particle.transition()
                .duration(1500)
                .ease(d3.easeCubicIn)
                .attr("transform", `translate(${machine.x - machine.width/2 - 20}, ${machine.y})`)
                .transition()
                .duration(500)
                .style("opacity", 0)
                .remove()
                .on("end", () => {
                    const outputParticle = svg.append("g")
                        .attr("transform", `translate(${machine.x + machine.width/2 + 20}, ${machine.y})`);
                    outputParticle.append("circle").attr("r", 15).attr("fill", "#f5a623");
                    outputParticle.append("text").text(outputValue.toFixed(1))
                        .attr("text-anchor", "middle").attr("dy", ".3em").attr("fill", "white");

                    outputParticle.transition()
                        .duration(1500)
                        .ease(d3.easeCubicOut)
                        .attr("transform", `translate(${numLineX}, ${scaleY(outputValue)})`)
                        .transition()
                        .duration(500)
                        .attr("r", 5)
                        .style("opacity", 0.7);
                });
        }

        const interval = setInterval(generateParticle, 1200);

        // Store cleanup function
        container.node().cleanup = () => clearInterval(interval);
    }

    /**
     * 第17页：函数性质介绍可视化
     * 功能：概述函数的四个基本性质
     * 内容：单调性、奇偶性、周期性、有界性的图形化展示
     * 动画：四个象限分别展示典型函数图像，依次出现动画
     * 教学目标：全面了解函数的基本性质分类
     */
    function visualizePropertiesIntro(containerId) {
        const setup = setupD3(containerId);
        if (!setup) return;
        const { g, width, height } = setup;

        // 创建四个象限来展示四个性质
        const quadrantWidth = width / 2;
        const quadrantHeight = height / 2;

        // 1. 单调性 (左上)
        const mono = g.append("g").attr("transform", `translate(0, 0)`);
        mono.append("rect").attr("width", quadrantWidth - 10).attr("height", quadrantHeight - 10)
            .attr("fill", "none").attr("stroke", "#3498db").attr("stroke-width", 2).attr("rx", 5);
        mono.append("text").attr("x", quadrantWidth/2).attr("y", 25).text("单调性").attr("text-anchor", "middle")
            .attr("font-size", "16px").attr("font-weight", "bold").attr("fill", "#3498db");

        // 绘制递增函数
        const monoData = d3.range(0, quadrantWidth - 20, 5).map(x => ({
            x: x + 10,
            y: quadrantHeight - 40 - (x / (quadrantWidth - 20)) * (quadrantHeight - 80)
        }));
        const monoLine = d3.line().x(d => d.x).y(d => d.y).curve(d3.curveCardinal);
        mono.append("path").datum(monoData).attr("d", monoLine)
            .attr("fill", "none").attr("stroke", "#3498db").attr("stroke-width", 3);
        mono.append("text").attr("x", quadrantWidth/2).attr("y", quadrantHeight - 15)
            .text("递增函数").attr("text-anchor", "middle").attr("font-size", "12px").attr("fill", "#3498db");

        // 2. 奇偶性 (右上)
        const parity = g.append("g").attr("transform", `translate(${quadrantWidth + 10}, 0)`);
        parity.append("rect").attr("width", quadrantWidth - 10).attr("height", quadrantHeight - 10)
            .attr("fill", "none").attr("stroke", "#e74c3c").attr("stroke-width", 2).attr("rx", 5);
        parity.append("text").attr("x", quadrantWidth/2).attr("y", 25).text("奇偶性").attr("text-anchor", "middle")
            .attr("font-size", "16px").attr("font-weight", "bold").attr("fill", "#e74c3c");

        // 绘制偶函数 (抛物线)
        const parityData = d3.range(10, quadrantWidth - 10, 3).map(x => {
            const centerX = quadrantWidth / 2;
            const normalizedX = (x - centerX) / (quadrantWidth / 4);
            return {
                x: x,
                y: quadrantHeight - 40 - Math.pow(normalizedX, 2) * 30
            };
        });
        const parityLine = d3.line().x(d => d.x).y(d => d.y).curve(d3.curveCardinal);
        parity.append("path").datum(parityData).attr("d", parityLine)
            .attr("fill", "none").attr("stroke", "#e74c3c").attr("stroke-width", 3);
        parity.append("text").attr("x", quadrantWidth/2).attr("y", quadrantHeight - 15)
            .text("偶函数 f(-x)=f(x)").attr("text-anchor", "middle").attr("font-size", "12px").attr("fill", "#e74c3c");

        // 3. 周期性 (左下)
        const period = g.append("g").attr("transform", `translate(0, ${quadrantHeight + 10})`);
        period.append("rect").attr("width", quadrantWidth - 10).attr("height", quadrantHeight - 10)
            .attr("fill", "none").attr("stroke", "#27ae60").attr("stroke-width", 2).attr("rx", 5);
        period.append("text").attr("x", quadrantWidth/2).attr("y", 25).text("周期性").attr("text-anchor", "middle")
            .attr("font-size", "16px").attr("font-weight", "bold").attr("fill", "#27ae60");

        // 绘制正弦函数
        const periodData = d3.range(10, quadrantWidth - 10, 2).map(x => ({
            x: x,
            y: quadrantHeight/2 - Math.sin((x - 10) / (quadrantWidth - 20) * 4 * Math.PI) * 30
        }));
        const periodLine = d3.line().x(d => d.x).y(d => d.y).curve(d3.curveCardinal);
        period.append("path").datum(periodData).attr("d", periodLine)
            .attr("fill", "none").attr("stroke", "#27ae60").attr("stroke-width", 3);
        period.append("text").attr("x", quadrantWidth/2).attr("y", quadrantHeight - 15)
            .text("sin(x) 周期函数").attr("text-anchor", "middle").attr("font-size", "12px").attr("fill", "#27ae60");

        // 4. 有界性 (右下)
        const bounded = g.append("g").attr("transform", `translate(${quadrantWidth + 10}, ${quadrantHeight + 10})`);
        bounded.append("rect").attr("width", quadrantWidth - 10).attr("height", quadrantHeight - 10)
            .attr("fill", "none").attr("stroke", "#f39c12").attr("stroke-width", 2).attr("rx", 5);
        bounded.append("text").attr("x", quadrantWidth/2).attr("y", 25).text("有界性").attr("text-anchor", "middle")
            .attr("font-size", "16px").attr("font-weight", "bold").attr("fill", "#f39c12");

        // 绘制有界函数 (反正切函数)
        const boundedData = d3.range(10, quadrantWidth - 10, 3).map(x => {
            const normalizedX = (x - quadrantWidth/2) / (quadrantWidth/4) * 3;
            return {
                x: x,
                y: quadrantHeight/2 - Math.atan(normalizedX) * 40
            };
        });
        const boundedLine = d3.line().x(d => d.x).y(d => d.y).curve(d3.curveCardinal);
        bounded.append("path").datum(boundedData).attr("d", boundedLine)
            .attr("fill", "none").attr("stroke", "#f39c12").attr("stroke-width", 3);

        // 绘制上下界线
        bounded.append("line").attr("x1", 10).attr("y1", quadrantHeight/2 - 50).attr("x2", quadrantWidth - 10).attr("y2", quadrantHeight/2 - 50)
            .attr("stroke", "#f39c12").attr("stroke-dasharray", "3,3").attr("stroke-width", 2);
        bounded.append("line").attr("x1", 10).attr("y1", quadrantHeight/2 + 50).attr("x2", quadrantWidth - 10).attr("y2", quadrantHeight/2 + 50)
            .attr("stroke", "#f39c12").attr("stroke-dasharray", "3,3").attr("stroke-width", 2);
        bounded.append("text").attr("x", quadrantWidth/2).attr("y", quadrantHeight - 15)
            .text("有界函数").attr("text-anchor", "middle").attr("font-size", "12px").attr("fill", "#f39c12");

        // 添加动画效果
        setTimeout(() => {
            [mono, parity, period, bounded].forEach((group, i) => {
                group.style("opacity", 0)
                    .transition()
                    .delay(i * 500)
                    .duration(800)
                    .style("opacity", 1);
            });
        }, 500);

        // 渲染数学公式
        setTimeout(() => {
            renderMathJaxInContainer(containerId);
        }, 1000);
    }

    /**
     * 第18页：单调递增可视化
     * 功能：演示单调递增函数的特征
     * 内容：f(x)=x³的单调递增性质
     * 动画：函数图像和递增趋势展示
     * 教学目标：理解单调递增的定义和判断
     */
    function visualizeMonotonicityInc(containerId) {
        const setup = setupD3(containerId);
        if (!setup) return;
        const { container, g, width, height } = setup;

        const xScale = d3.scaleLinear().domain([-5, 5]).range([0, width]);
        const yScale = d3.scaleLinear().domain([-5, 5]).range([height, 0]);
        drawAxes(g, xScale, yScale, width, height);

        // 创建数值显示面板
        const valueDisplay = container.append('div').attr('class', 'value-display');
        valueDisplay.html(`
            <div class="value-item">
                <span class="value-label">x 值：</span>
                <span class="value-number" id="x-value">-5.00</span>
            </div>
            <div class="value-item">
                <span class="value-label">y 值：</span>
                <span class="value-number" id="y-value">-1.50</span>
            </div>
            <div class="value-item">
                <span class="value-label">变化：</span>
                <span class="value-number">x↑ y↑</span>
            </div>
        `);

        // 函数数据
        const data = d3.range(-5, 5.1, 0.1).map(x => ({x: x, y: 0.5 * x + 1}));
        const line = d3.line().x(d => xScale(d.x)).y(d => yScale(d.y));

        // 绘制函数曲线（渐进绘制）
        const path = g.append("path")
            .datum(data)
            .attr("fill", "none")
            .attr("stroke", "var(--success-color)")
            .attr("stroke-width", 3)
            .attr("d", line);

        const totalLength = path.node().getTotalLength();
        path.attr("stroke-dasharray", totalLength + " " + totalLength)
            .attr("stroke-dashoffset", totalLength)
            .transition()
            .duration(2000)
            .attr("stroke-dashoffset", 0);

        // 函数标签 - 使用MathJax
        const formulaLabel = g.append("foreignObject")
            .attr("x", xScale(1.5))
            .attr("y", yScale(4.8))
            .attr("width", 200)
            .attr("height", 50)
            .style("opacity", 0);

        formulaLabel.append("xhtml:div")
            .style("color", "var(--success-color)")
            .style("font-size", "18px")
            .style("font-weight", "bold")
            .html("增函数 $y = 0.5x + 1$");

        formulaLabel.transition()
            .delay(2000)
            .duration(500)
            .style("opacity", 1);

        // 创建移动的小球
        const circle = g.append("circle")
            .attr("r", 0)
            .attr("fill", "var(--success-color)")
            .style("filter", "drop-shadow(0 0 10px rgba(46, 204, 113, 0.8))")
            .attr("cx", xScale(-5))
            .attr("cy", yScale(-1.5))
            .transition()
            .delay(2500)
            .duration(500)
            .attr("r", 8);

        // 创建轨迹组
        const traceGroup = g.append("g");

        // 连续动画
        let animationFrame;
        function continuousAnimation() {
            let t = 0;
            let lastTraceTime = 0;

            function animate() {
                t += 0.003;
                if (t > 1) t = 0;

                const currentData = data[Math.floor(t * data.length)];
                if (!currentData) return;

                const currentX = currentData.x;
                const currentY = currentData.y;

                circle.attr("cx", xScale(currentX))
                    .attr("cy", yScale(currentY));

                // 更新数值显示
                container.select('#x-value').text(currentX.toFixed(2));
                container.select('#y-value').text(currentY.toFixed(2));

                // 添加轨迹点（每隔一定时间）
                if (t - lastTraceTime > 0.02) {
                    lastTraceTime = t;
                    traceGroup.append("circle")
                        .attr("cx", xScale(currentX))
                        .attr("cy", yScale(currentY))
                        .attr("r", 3)
                        .attr("fill", "var(--success-color)")
                        .attr("opacity", 0.6)
                        .transition()
                        .duration(3000)
                        .attr("opacity", 0)
                        .attr("r", 1)
                        .remove();
                }

                animationFrame = requestAnimationFrame(animate);
            }

            setTimeout(() => animate(), 3000);
        }

        continuousAnimation();

        // 添加停止函数
        container.node().cleanup = () => {
            if (animationFrame) cancelAnimationFrame(animationFrame);
        };

        // 渲染数学公式
        setTimeout(() => {
            renderMathJaxInContainer(containerId);
        }, 1000);
    }

    /**
     * 第19页：单调递减可视化
     * 功能：演示单调递减函数的特征
     * 内容：f(x)=-x的单调递减性质
     * 动画：函数图像和递减趋势展示
     * 教学目标：理解单调递减的定义和判断
     */
    function visualizeMonotonicityDec(containerId) {
        const setup = setupD3(containerId);
        if (!setup) return;
        const { container, g, width, height } = setup;

        const xScale = d3.scaleLinear().domain([-5, 5]).range([0, width]);
        const yScale = d3.scaleLinear().domain([-5, 5]).range([height, 0]);
        drawAxes(g, xScale, yScale, width, height);

        // 创建数值显示面板
        const valueDisplay = container.append('div').attr('class', 'value-display');
        valueDisplay.html(`
            <div class="value-item">
                <span class="value-label">x 值：</span>
                <span class="value-number" id="x-value">-5.00</span>
            </div>
            <div class="value-item">
                <span class="value-label">y 值：</span>
                <span class="value-number" id="y-value">1.50</span>
            </div>
            <div class="value-item">
                <span class="value-label">变化：</span>
                <span class="value-number">x↑ y↓</span>
            </div>
        `);

        // 函数数据
        const data = d3.range(-5, 5.1, 0.1).map(x => ({x: x, y: -0.5 * x - 1}));
        const line = d3.line().x(d => xScale(d.x)).y(d => yScale(d.y));

        // 绘制函数曲线
        const path = g.append("path")
            .datum(data)
            .attr("fill", "none")
            .attr("stroke", "var(--danger-color)")
            .attr("stroke-width", 3)
            .attr("d", line);

        const totalLength = path.node().getTotalLength();
        path.attr("stroke-dasharray", totalLength + " " + totalLength)
            .attr("stroke-dashoffset", totalLength)
            .transition()
            .duration(2000)
            .attr("stroke-dashoffset", 0);

        // 函数标签 - 使用MathJax
        const formulaLabel = g.append("foreignObject")
            .attr("x", xScale(-4.8))
            .attr("y", yScale(3.3))
            .attr("width", 200)
            .attr("height", 50)
            .style("opacity", 0);

        formulaLabel.append("xhtml:div")
            .style("color", "var(--danger-color)")
            .style("font-size", "18px")
            .style("font-weight", "bold")
            .html("减函数 $y = -0.5x - 1$");

        formulaLabel.transition()
            .delay(2000)
            .duration(500)
            .style("opacity", 1);

        // 创建移动的小球
        const circle = g.append("circle")
            .attr("r", 0)
            .attr("fill", "var(--danger-color)")
            .style("filter", "drop-shadow(0 0 10px rgba(231, 76, 60, 0.8))")
            .attr("cx", xScale(-5))
            .attr("cy", yScale(1.5))
            .transition()
            .delay(2500)
            .duration(500)
            .attr("r", 8);

        // 创建轨迹组
        const traceGroup = g.append("g");

        // 创建箭头标记
        const arrow = g.append("g").style("opacity", 0);
        arrow.append("path")
            .attr("d", "M 0 0 L 20 10 L 15 10 L 15 20 L 5 20 L 5 10 L 0 10 Z")
            .attr("fill", "var(--danger-color)")
            .attr("transform", "rotate(135)");

        arrow.transition().delay(3000).duration(500).style("opacity", 0.5);

        // 连续动画
        let animationFrame;
        function continuousAnimation() {
            let t = 0;
            let lastTraceTime = 0;

            function animate() {
                t += 0.003;
                if (t > 1) t = 0;

                const currentData = data[Math.floor(t * data.length)];
                if (!currentData) return;

                const currentX = currentData.x;
                const currentY = currentData.y;

                circle.attr("cx", xScale(currentX))
                    .attr("cy", yScale(currentY));

                // 更新数值显示
                container.select('#x-value').text(currentX.toFixed(2));
                container.select('#y-value').text(currentY.toFixed(2));

                // 更新箭头位置
                arrow.attr("transform", `translate(${xScale(currentX) + 20}, ${yScale(currentY) - 20}) rotate(135)`);

                // 添加轨迹点
                if (t - lastTraceTime > 0.02) {
                    lastTraceTime = t;
                    traceGroup.append("circle")
                        .attr("cx", xScale(currentX))
                        .attr("cy", yScale(currentY))
                        .attr("r", 3)
                        .attr("fill", "var(--danger-color)")
                        .attr("opacity", 0.6)
                        .transition()
                        .duration(3000)
                        .attr("opacity", 0)
                        .attr("r", 1)
                        .remove();
                }

                animationFrame = requestAnimationFrame(animate);
            }

            setTimeout(() => animate(), 3000);
        }

        continuousAnimation();

        container.node().cleanup = () => {
            if (animationFrame) cancelAnimationFrame(animationFrame);
        };

        // 渲染数学公式
        setTimeout(() => {
            renderMathJaxInContainer(containerId);
        }, 1000);
    }

    /**
     * 第20页：单调区间可视化
     * 功能：展示函数在不同区间的单调性
     * 内容：f(x)=x²在不同区间的单调性分析
     * 动画：区间划分和单调性标注
     * 教学目标：学会分析函数的单调区间
     */
    function visualizeMonotonicityIntervals(containerId) {
        const plot = createPlot(containerId, x => x*x, [-3, 3], [-1, 9], "$f(x)=x^2$ 的单调区间");
        if (!plot) return;
        const { g, xScale, yScale, width } = plot;

        g.insert("rect", ":first-child").attr("x", 0).attr("y", 0).attr("width", width/2).attr("height", "100%").attr("fill", "var(--danger-color)").attr("opacity", 0.2);
        g.insert("rect", ":first-child").attr("x", width/2).attr("y", 0).attr("width", width/2).attr("height", "100%").attr("fill", "var(--success-color)").attr("opacity", 0.2);

        g.append("text").attr("x", xScale(-1.5)).attr("y", yScale(8)).text("递减区间").attr("text-anchor", "middle");
        g.append("text").attr("x", xScale(1.5)).attr("y", yScale(8)).text("递增区间").attr("text-anchor", "middle");

        // 渲染数学公式
        setTimeout(() => {
            renderMathJaxInContainer(containerId);
        }, 1000);
    }

    /**
     * 第21页：奇偶性介绍可视化
     * 功能：介绍函数奇偶性的概念
     * 内容：奇偶性的对称性特征
     * 动画：对称性概念的图形展示
     * 教学目标：理解奇偶性的几何意义
     */
    function visualizeParityIntro(containerId) {
        const setup = setupD3(containerId);
        if (!setup) return;
        const { g, width, height } = setup;

        // 创建左右两个区域
        const leftWidth = width / 2 - 10;
        const rightWidth = width / 2 - 10;

        // 左侧：偶函数演示
        const evenGroup = g.append("g").attr("transform", "translate(0, 0)");

        // 偶函数标题 - 使用MathJax
        const evenTitle = evenGroup.append("foreignObject")
            .attr("x", leftWidth / 2 - 80)
            .attr("y", 5)
            .attr("width", 160)
            .attr("height", 30);

        evenTitle.append("xhtml:div")
            .style("text-align", "center")
            .style("font-size", "16px")
            .style("font-weight", "bold")
            .style("color", "#e74c3c")
            .html("偶函数：$f(-x) = f(x)$");

        // 偶函数坐标系
        const evenXScale = d3.scaleLinear().domain([-4, 4]).range([20, leftWidth - 20]);
        const evenYScale = d3.scaleLinear().domain([-2, 16]).range([height - 40, 40]);

        // 绘制偶函数坐标轴
        evenGroup.append("line")
            .attr("x1", evenXScale(-4)).attr("y1", evenYScale(0))
            .attr("x2", evenXScale(4)).attr("y2", evenYScale(0))
            .attr("stroke", "#ccc").attr("stroke-width", 1);
        evenGroup.append("line")
            .attr("x1", evenXScale(0)).attr("y1", evenYScale(-2))
            .attr("x2", evenXScale(0)).attr("y2", evenYScale(16))
            .attr("stroke", "#ccc").attr("stroke-width", 1);

        // 偶函数数据
        const evenData = d3.range(-4, 4.1, 0.1).map(x => ({x: x, y: x * x}));
        const evenLine = d3.line().x(d => evenXScale(d.x)).y(d => evenYScale(d.y));

        // 绘制完整的偶函数
        evenGroup.append("path").datum(evenData)
            .attr("fill", "none").attr("stroke", "#ccc").attr("stroke-width", 2)
            .attr("d", evenLine);

        // 左半部分（蓝色）
        evenGroup.append("path").datum(evenData.filter(d => d.x <= 0))
            .attr("fill", "none").attr("stroke", "#3498db").attr("stroke-width", 3)
            .attr("d", evenLine);

        // 右半部分（橙色，用于动画）
        const evenRightPath = evenGroup.append("path").datum(evenData.filter(d => d.x >= 0))
            .attr("fill", "none").attr("stroke", "#e67e22").attr("stroke-width", 3)
            .attr("d", evenLine);

        // 右侧：奇函数演示
        const oddGroup = g.append("g").attr("transform", `translate(${width / 2 + 10}, 0)`);

        // 奇函数标题 - 使用MathJax
        const oddTitle = oddGroup.append("foreignObject")
            .attr("x", rightWidth / 2 - 80)
            .attr("y", 5)
            .attr("width", 160)
            .attr("height", 30);

        oddTitle.append("xhtml:div")
            .style("text-align", "center")
            .style("font-size", "16px")
            .style("font-weight", "bold")
            .style("color", "#27ae60")
            .html("奇函数：$f(-x) = -f(x)$");

        // 奇函数坐标系
        const oddXScale = d3.scaleLinear().domain([-4, 4]).range([20, rightWidth - 20]);
        const oddYScale = d3.scaleLinear().domain([-10, 10]).range([height - 40, 40]);

        // 绘制奇函数坐标轴
        oddGroup.append("line")
            .attr("x1", oddXScale(-4)).attr("y1", oddYScale(0))
            .attr("x2", oddXScale(4)).attr("y2", oddYScale(0))
            .attr("stroke", "#ccc").attr("stroke-width", 1);
        oddGroup.append("line")
            .attr("x1", oddXScale(0)).attr("y1", oddYScale(-10))
            .attr("x2", oddXScale(0)).attr("y2", oddYScale(10))
            .attr("stroke", "#ccc").attr("stroke-width", 1);

        // 奇函数数据
        const oddData = d3.range(-4, 4.1, 0.1).map(x => ({x: x, y: (x * x * x) / 3}));
        const oddLine = d3.line().x(d => oddXScale(d.x)).y(d => oddYScale(d.y));

        // 绘制完整的奇函数
        oddGroup.append("path").datum(oddData)
            .attr("fill", "none").attr("stroke", "#ccc").attr("stroke-width", 2)
            .attr("d", oddLine);

        // 左半部分（绿色）
        oddGroup.append("path").datum(oddData.filter(d => d.x <= 0))
            .attr("fill", "none").attr("stroke", "#27ae60").attr("stroke-width", 3)
            .attr("d", oddLine);

        // 右半部分（紫色，用于动画）
        const oddRightPath = oddGroup.append("path").datum(oddData.filter(d => d.x >= 0))
            .attr("fill", "none").attr("stroke", "#9b59b6").attr("stroke-width", 3)
            .attr("d", oddLine);

        // 偶函数动画
        function playEvenAnimation() {
            const originX = evenXScale(0);
            evenRightPath.style('transform-origin', `${originX}px center`);

            evenRightPath.transition().delay(1000).duration(1500).ease(d3.easeCubicInOut)
                .style("transform", "scaleX(-1)")
                .attr("stroke", "#3498db")
                .transition().delay(1000).duration(1500).ease(d3.easeCubicInOut)
                .style("transform", "scaleX(1)")
                .attr("stroke", "#e67e22")
                .on("end", playEvenAnimation);
        }

        // 奇函数动画
        function playOddAnimation() {
            const originX = oddXScale(0);
            const originY = oddYScale(0);
            oddRightPath.style('transform-origin', `${originX}px ${originY}px`);

            oddRightPath.transition().delay(1000).duration(1500).ease(d3.easeCubicInOut)
                .style("transform", "scaleX(-1)")
                .transition().duration(1500).ease(d3.easeCubicInOut)
                .style("transform", "scale(-1, -1)")
                .attr("stroke", "#27ae60")
                .transition().delay(1000).duration(1500).ease(d3.easeCubicInOut)
                .style("transform", "scale(1, 1)")
                .attr("stroke", "#9b59b6")
                .on("end", playOddAnimation);
        }

        // 启动动画
        setTimeout(() => {
            playEvenAnimation();
            playOddAnimation();
        }, 500);

        // 渲染数学公式
        setTimeout(() => {
            renderMathJaxInContainer(containerId);
        }, 1000);
    }

    /**
     * 第22页：偶函数可视化
     * 功能：演示偶函数的对称性
     * 内容：通过动态演示展示偶函数关于y轴对称的性质
     * 动画：自动选择对称点并验证f(-x)=f(x)
     * 教学目标：理解偶函数的几何特征和代数性质
     */
    function visualizeEvenFunction(containerId) {
        const setup = setupD3(containerId);
        if (!setup) return;
        const { container, g, width, height } = setup;

        const xScale = d3.scaleLinear().domain([-4, 4]).range([0, width]);
        const yScale = d3.scaleLinear().domain([-2, 16]).range([height, 0]);
        drawAxes(g, xScale, yScale, width, height);

        // 创建步骤指示器
        const stepIndicator = container.append('div')
            .style('position', 'absolute')
            .style('top', '10px')
            .style('left', '10px')
            .style('background', 'rgba(0,0,0,0.8)')
            .style('color', 'white')
            .style('padding', '8px 12px')
            .style('border-radius', '4px')
            .style('font-size', '14px')
            .style('opacity', 0)
            .text('选择对称点');

        // 函数数据 - 直接显示
        const data = d3.range(-4, 4.1, 0.1).map(x => ({x: x, y: x * x}));
        const line = d3.line().x(d => xScale(d.x)).y(d => yScale(d.y));

        // 绘制函数曲线（直接显示）
        const curve = g.append("path")
            .datum(data)
            .attr("fill", "none")
            .attr("stroke", "var(--info-color)")
            .attr("stroke-width", 3)
            .attr("d", line);

        // 函数标签 - 使用MathJax
        const formulaLabel = g.append("foreignObject")
            .attr("x", xScale(2))
            .attr("y", yScale(15))
            .attr("width", 150)
            .attr("height", 40);

        formulaLabel.append("xhtml:div")
            .style("color", "var(--info-color)")
            .style("font-size", "18px")
            .style("font-weight", "bold")
            .html("偶函数: $y = x^2$");

        // Y轴对称线
        const yAxisLine = g.append("line")
            .attr("x1", xScale(0))
            .attr("y1", 0)
            .attr("x2", xScale(0))
            .attr("y2", height)
            .attr("stroke", "var(--warning-color)")
            .attr("stroke-width", 3)
            .attr("opacity", 0);

        // 自动演示序列
        function autoDemo() {
            // 延迟1秒后开始
            setTimeout(() => {
                stepIndicator.transition().duration(500).style('opacity', 1);

                const pairs = [
                    {x: 2, y: 4, delay: 0},
                    {x: -2, y: 4, delay: 500},
                    {x: 3, y: 9, delay: 1500},
                    {x: -3, y: 9, delay: 2000}
                ];

                pairs.forEach(point => {
                    const circle = g.append("circle")
                        .attr("cx", xScale(point.x))
                        .attr("cy", yScale(point.y))
                        .attr("r", 0)
                        .attr("fill", point.x > 0 ? "#e74c3c" : "#3498db")
                        .transition()
                        .delay(1000 + point.delay)
                        .duration(300)
                        .attr("r", 6);

                    // 添加坐标标签
                    g.append("text")
                        .attr("x", xScale(point.x) + (point.x > 0 ? 10 : -35))
                        .attr("y", yScale(point.y) - 10)
                        .text(`(${point.x}, ${point.y})`)
                        .attr("fill", point.x > 0 ? "#e74c3c" : "#3498db")
                        .style("font-size", "12px")
                        .style("opacity", 0)
                        .transition()
                        .delay(1000 + point.delay)
                        .duration(500)
                        .style("opacity", 1);
                });
            }, 1000);

            // 显示对称轴和连线
            setTimeout(() => {
                stepIndicator.text('验证y轴对称');

                yAxisLine.transition()
                    .duration(1000)
                    .attr("opacity", 0.5)
                    .transition()
                    .duration(500)
                    .attr("opacity", 0.2);

                // 连接对称点
                const lines = [
                    {x1: 2, x2: -2, y: 4},
                    {x1: 3, x2: -3, y: 9}
                ];

                lines.forEach((line, i) => {
                    g.append("line")
                        .attr("x1", xScale(line.x1))
                        .attr("y1", yScale(line.y))
                        .attr("x2", xScale(line.x1))
                        .attr("y2", yScale(line.y))
                        .attr("stroke", "#95a5a6")
                        .attr("stroke-width", 2)
                        .attr("stroke-dasharray", "5,5")
                        .transition()
                        .delay(i * 500)
                        .duration(1000)
                        .attr("x2", xScale(line.x2));
                });

                // 显示对称性公式
                g.append("text")
                    .attr("x", xScale(0))
                    .attr("y", yScale(6))
                    .text("f(-x) = f(x)")
                    .attr("text-anchor", "middle")
                    .attr("fill", "black")
                    .style("font-size", "20px")
                    .style("font-weight", "bold")
                    .style("opacity", 0)
                    .transition()
                    .delay(1500)
                    .duration(1000)
                    .style("opacity", 1)
                    .transition()
                    .duration(1000)
                    .style("opacity", 0.5);
            }, 4500);

            // 循环重启
            setTimeout(() => {
                g.selectAll("*").transition().duration(1000).style("opacity", 0)
                    .on("end", function() {
                        d3.select(this).remove();
                    });
                stepIndicator.transition().duration(1000).style("opacity", 0);
                setTimeout(() => autoDemo(), 1500);
            }, 10000);
        }

        autoDemo();

        // 渲染数学公式
        setTimeout(() => {
            renderMathJaxInContainer(containerId);
        }, 1000);
    }

    /**
     * 第23页：奇函数可视化
     * 功能：演示奇函数的对称性
     * 内容：f(x)=x³关于原点对称
     * 动画：原点对称的点对连线
     * 教学目标：理解奇函数f(-x)=-f(x)的性质
     */
    function visualizeOddFunction(containerId) {
        const setup = setupD3(containerId);
        if (!setup) return;
        const { container, g, width, height } = setup;

        const xScale = d3.scaleLinear().domain([-4, 4]).range([0, width]);
        const yScale = d3.scaleLinear().domain([-10, 10]).range([height, 0]);
        drawAxes(g, xScale, yScale, width, height);

        // 创建步骤指示器
        const stepIndicator = container.append('div')
            .style('position', 'absolute')
            .style('top', '10px')
            .style('left', '10px')
            .style('background', 'rgba(0,0,0,0.8)')
            .style('color', 'white')
            .style('padding', '8px 12px')
            .style('border-radius', '4px')
            .style('font-size', '14px')
            .style('opacity', 0)
            .text('标记原点');

        // 函数数据 - 直接显示
        const data = d3.range(-4, 4.1, 0.1).map(x => ({x: x, y: (x * x * x) / 3}));
        const line = d3.line().x(d => xScale(d.x)).y(d => yScale(d.y));

        // 绘制函数曲线（直接显示）
        const curve = g.append("path")
            .datum(data)
            .attr("fill", "none")
            .attr("stroke", "var(--accent-color)")
            .attr("stroke-width", 3)
            .attr("d", line);

        // 函数标签 - 使用MathJax
        const formulaLabel = g.append("foreignObject")
            .attr("x", xScale(-3.8))
            .attr("y", yScale(9))
            .attr("width", 150)
            .attr("height", 40);

        formulaLabel.append("xhtml:div")
            .style("color", "var(--accent-color)")
            .style("font-size", "18px")
            .style("font-weight", "bold")
            .html("奇函数: $y = \\frac{x^3}{3}$");

        // 原点标记
        const origin = g.append("circle")
            .attr("cx", xScale(0))
            .attr("cy", yScale(0))
            .attr("r", 0)
            .attr("fill", "var(--warning-color)");

        // 自动演示序列
        function autoDemo() {
            // 标记原点
            setTimeout(() => {
                stepIndicator.transition().duration(500).style('opacity', 1);

                origin.transition()
                    .duration(500)
                    .attr("r", 10)
                    .transition()
                    .duration(500)
                    .attr("r", 8)
                    .style("filter", "drop-shadow(0 0 10px rgba(243, 156, 18, 0.8))");

                g.append("text")
                    .attr("x", xScale(0) + 15)
                    .attr("y", yScale(0) - 15)
                    .text("原点 (0,0)")
                    .attr("fill", "var(--warning-color)")
                    .style("font-size", "14px")
                    .style("opacity", 0)
                    .transition()
                    .duration(500)
                    .style("opacity", 1);
            }, 1000);

            // 选择对称点对
            setTimeout(() => {
                stepIndicator.text('选择对称点');

                const pairs = [
                    {x: 2, y: 8/3},
                    {x: -2, y: -8/3},
                    {x: 3, y: 9},
                    {x: -3, y: -9}
                ];

                pairs.forEach((point, i) => {
                    const circle = g.append("circle")
                        .attr("cx", xScale(point.x))
                        .attr("cy", yScale(point.y))
                        .attr("r", 0)
                        .attr("fill", point.x > 0 ? "#e74c3c" : "#3498db")
                        .transition()
                        .delay(500 * i)
                        .duration(300)
                        .attr("r", 6);

                    // 添加坐标标签
                    const yDisplay = Math.abs(point.y) > 5 ? point.y.toFixed(1) : point.y.toFixed(2);
                    g.append("text")
                        .attr("x", xScale(point.x) + (point.x > 0 ? 10 : -50))
                        .attr("y", yScale(point.y) + (point.y > 0 ? -10 : 10))
                        .text(`(${point.x}, ${yDisplay})`)
                        .attr("fill", point.x > 0 ? "#e74c3c" : "#3498db")
                        .style("font-size", "11px")
                        .style("opacity", 0)
                        .transition()
                        .delay(500 * i)
                        .duration(500)
                        .style("opacity", 1);

                    // 连接对称点到原点
                    if (i % 2 === 0) {
                        g.append("line")
                            .attr("x1", xScale(point.x))
                            .attr("y1", yScale(point.y))
                            .attr("x2", xScale(point.x))
                            .attr("y2", yScale(point.y))
                            .attr("stroke", "#95a5a6")
                            .attr("stroke-width", 1)
                            .attr("stroke-dasharray", "3,3")
                            .transition()
                            .delay(500 * i + 300)
                            .duration(1000)
                            .attr("x2", xScale(pairs[i+1].x))
                            .attr("y2", yScale(pairs[i+1].y));
                    }
                });
            }, 3000);

            // 显示对称性公式
            setTimeout(() => {
                stepIndicator.text('验证原点对称');

                g.append("text")
                    .attr("x", xScale(0))
                    .attr("y", yScale(-8))
                    .text("f(-x) = -f(x)")
                    .attr("text-anchor", "middle")
                    .attr("fill", "black")
                    .style("font-size", "20px")
                    .style("font-weight", "bold")
                    .style("opacity", 0)
                    .transition()
                    .duration(1000)
                    .style("opacity", 1)
                    .transition()
                    .duration(1000)
                    .style("opacity", 0.5);
            }, 6000);

            // 循环重启
            setTimeout(() => {
                g.selectAll("*").transition().duration(1000).style("opacity", 0)
                    .on("end", function() {
                        d3.select(this).remove();
                    });
                stepIndicator.transition().duration(1000).style("opacity", 0);
                setTimeout(() => autoDemo(), 1500);
            }, 10000);
        }

        autoDemo();

        // 渲染数学公式
        setTimeout(() => {
            renderMathJaxInContainer(containerId);
        }, 1000);
    }

    /**
     * 第24页：反函数机器可视化
     * 功能：演示反函数的概念和作用
     * 内容：函数机器的逆向操作过程
     * 动画：输入输出的逆向变换
     * 教学目标：理解反函数是原函数的逆操作
     */
    function visualizeInverseMachine(containerId) {
        const setup = setupD3(containerId, { top: 20, right: 20, bottom: 20, left: 20 });
        if (!setup) return;
        const { g, width, height, svg } = setup;

        // --- 表格部分 ---
        const tableGroup = g.append('g').attr('class', 'table-group');
        const tableData = [ { x: 1, y: 4 }, { x: 2, y: 5 }, { x: 3, y: 6 } ];
        const tableWidth = 300, cellHeight = 50, headerHeight = 60, cellWidth = tableWidth/2;
        const tableX = (width - tableWidth) / 2; // Center in the whole visualization area
        const tableY = (height - (tableData.length + 1) * cellHeight) / 2;
        const table = tableGroup.append('g').attr('transform', `translate(${tableX}, ${tableY})`);

        const headerX = table.append('g');
        headerX.append('rect').attr('width', cellWidth).attr('height', headerHeight).attr('fill', 'var(--primary-color)');
        headerX.append('text').text('输入 x').attr('x', cellWidth/2).attr('y', headerHeight/2).attr('text-anchor', 'middle').attr('dy', '.3em').attr('fill', 'white').style('font-size', '24px');

        const headerY = table.append('g').attr('transform', `translate(${cellWidth}, 0)`);
        headerY.append('rect').attr('width', cellWidth).attr('height', headerHeight).attr('fill', 'var(--accent-color)');
        headerY.append('text').text('输出 y').attr('x', cellWidth/2).attr('y', headerHeight/2).attr('text-anchor', 'middle').attr('dy', '.3em').attr('fill', 'white').style('font-size', '24px');

        const rows = table.selectAll('.row').data(tableData).enter().append('g').attr('transform', (d, i) => `translate(0, ${(i+1) * cellHeight})`);
        const cellsX = rows.append('g');
        cellsX.append('rect').attr('width', cellWidth).attr('height', cellHeight).attr('fill', '#f0f0f0').attr('stroke', '#ccc');
        cellsX.append('text').attr('x', cellWidth/2).attr('y', cellHeight/2).attr('text-anchor', 'middle').attr('dy', '.3em').text(d => d.x);

        const cellsY = rows.append('g').attr('transform', `translate(${cellWidth}, 0)`);
        cellsY.append('rect').attr('width', cellWidth).attr('height', cellHeight).attr('fill', '#f0f0f0').attr('stroke', '#ccc');
        cellsY.append('text').attr('x', cellWidth/2).attr('y', cellHeight/2).attr('text-anchor', 'middle').attr('dy', '.3em').text(d => d.y);

        const title = svg.append('text').attr('x', width / 2).attr('y', tableY - 40).attr('text-anchor', 'middle').style('font-size', '24px');

        // --- 动画循环 ---
        function playAnimation() {
            title.text('函数');

            // Reset positions
            headerX.attr('transform', 'translate(0, 0)');
            headerY.attr('transform', `translate(${cellWidth}, 0)`);
            cellsX.attr('transform', 'translate(0, 0)');
            cellsY.attr('transform', `translate(${cellWidth}, 0)`);

            g.transition("swap-anim").delay(2000).duration(1500)
                .on('start', () => {
                    title.text('反函数 (交换 x 和 y)');
                })
                .tween('swap', () => t => {
                    headerX.attr('transform', `translate(${t * cellWidth}, 0)`);
                    headerY.attr('transform', `translate(${(1-t) * cellWidth}, 0)`);
                    cellsX.attr('transform', `translate(${t * cellWidth}, 0)`);
                    cellsY.attr('transform', `translate(${(1-t) * cellWidth}, 0)`);
                })
                .on('end', () => {
                    setTimeout(playAnimation, 2500);
                });
        }
        playAnimation();

        // 渲染数学公式
        setTimeout(() => {
            renderMathJaxInContainer(containerId);
        }, 1000);
    }

    /**
     * 第25页：反函数图像可视化
     * 功能：展示反函数与原函数的图像关系
     * 内容：函数与其反函数关于y=x对称
     * 动画：对称关系的动态展示
     * 教学目标：理解反函数的几何性质
     */
    function visualizeInverseGraph(containerId) {
        const setup = setupD3(containerId);
        if (!setup) {
            console.error("D3 setup failed for:", containerId);
            return;
        }
        const { g, width, height } = setup;

        const domainRange = [-5, 5];
        const xScale = d3.scaleLinear().domain(domainRange).range([0, width]);
        const yScale = d3.scaleLinear().domain(domainRange).range([height, 0]);
        drawAxes(g, xScale, yScale, width, height);

        // 1. Draw static elements
        g.append("line").attr("x1", xScale(domainRange[0])).attr("y1", yScale(domainRange[0]))
            .attr("x2", xScale(domainRange[1])).attr("y2", yScale(domainRange[1]))
            .attr("stroke", "grey").attr("stroke-width", 2).attr("stroke-dasharray", "5,5");
        // 镜子线标签 - 使用MathJax
        const mirrorLabel = g.append("foreignObject")
            .attr("x", xScale(3.5))
            .attr("y", yScale(4.2))
            .attr("width", 120)
            .attr("height", 30);

        mirrorLabel.append("xhtml:div")
            .style("color", "grey")
            .style("font-size", "16px")
            .style("text-align", "right")
            .html("$y = x$ (镜子)");

        const originalFunc = x => 0.5 * x + 1;
        const dataPoints = d3.range(-5, 5.1, 0.2);
        const originalData = dataPoints.map(x => ({x: x, y: originalFunc(x)})).filter(d => d.y >= domainRange[0] && d.y <= domainRange[1]);
        const reflectedData = originalData.map(d => ({x: d.y, y: d.x}));
        const line = d3.line().x(d => xScale(d.x)).y(d => yScale(d.y));

        const samplePoints = [
            {x: -4, y: originalFunc(-4)},
            {x: -1, y: originalFunc(-1)},
            {x: 2, y: originalFunc(2)},
            {x: 4, y: originalFunc(4)},
        ];

        // 2. Draw the original function and its labels
        g.append("path").datum(originalData).attr("fill", "none").attr("stroke-width", 4)
            .attr("stroke", "var(--primary-color)")
            .attr("d", line);

        // 原函数标签 - 使用MathJax
        const originalLabel = g.append("foreignObject")
            .attr("x", xScale(-4.5))
            .attr("y", yScale(-1))
            .attr("width", 200)
            .attr("height", 40);

        originalLabel.append("xhtml:div")
            .style("color", "var(--primary-color)")
            .style("font-size", "16px")
            .style("font-weight", "bold")
            .html("原函数: $y = 0.5x + 1$");

        // Prepare the inverse path but keep it hidden/dashed initially
        const inversePath = g.append("path").datum(reflectedData).attr("fill", "none").attr("stroke-width", 4)
            .attr("stroke", "var(--accent-color)")
            .attr("d", line);

        const pointsGroup = g.append('g');

        function playAnimation() {
            pointsGroup.selectAll('*').remove();

            // Set inverse path to be dashed and transparent for the start of the animation
            inversePath
                .style('opacity', 0.3)
                .attr('stroke-dasharray', '8, 8');

            let totalDelay = 500;

            samplePoints.forEach((d, i) => {
                const originalPos = { x: xScale(d.x), y: yScale(d.y) };
                const reflectedPos = { x: xScale(d.y), y: yScale(d.x) };

                // Point on original function
                const p1 = pointsGroup.append('circle')
                    .attr('r', 8).attr('fill', 'var(--primary-color)')
                    .attr('cx', originalPos.x).attr('cy', originalPos.y)
                    .style('opacity', 0);

                // Point that will move to inverse function
                const p2 = pointsGroup.append('circle')
                    .attr('r', 8).attr('fill', 'var(--accent-color)')
                    .attr('cx', originalPos.x).attr('cy', originalPos.y)
                    .style('opacity', 0);

                // Animate appearance of point on original function
                p1.transition(`appear-${i}`).delay(totalDelay).duration(500).style('opacity', 1);
                totalDelay += 1500;

                // Animate flip: fade out original point, move the second point
                p1.transition(`fadeout-${i}`).delay(totalDelay).duration(500).style('opacity', 0);
                p2.transition(`flip-${i}`).delay(totalDelay).duration(1000)
                    .style('opacity', 1)
                    .attr('cx', reflectedPos.x)
                    .attr('cy', reflectedPos.y);

                totalDelay += 1000;
            });

            // After all points have flipped, animate the inverse path to become solid
            const pathNode = inversePath.node();
            const totalLength = pathNode.getTotalLength();

            inversePath
                .attr("stroke-dasharray", totalLength + " " + totalLength)
                .attr("stroke-dashoffset", totalLength)
                .style('opacity', 1)
                .transition('draw-line')
                .delay(totalDelay)
                .duration(1500)
                .ease(d3.easeLinear)
                .attr("stroke-dashoffset", 0);

            totalDelay += 3000;
            setTimeout(playAnimation, totalDelay);
        }
        playAnimation();

        // 渲染数学公式
        setTimeout(() => {
            renderMathJaxInContainer(containerId);
        }, 1000);
    }

    /**
     * 第26页：基本初等函数星系可视化
     * 功能：动态展示六大基本初等函数，如行星绕日运行
     * 内容：常数、幂、指数、对数、三角、反三角函数
     * 动画：行星沿轨道自动运行，一个高亮光标会依次扫过并展示每个函数的详情
     * 教学目标：建立对基本初等函数大家族的宏观和趣味性认识
     */
    function visualizeElementaryIntro(containerId) {
        const setup = setupD3(containerId, { top: 0, right: 0, bottom: 0, left: 0 });
        if (!setup) return;
        const { container, svg, g, width, height } = setup;

        // 设置星空背景
        svg.style('background', 'radial-gradient(ellipse at center, #1a1a2e 0%, #16213e 50%, #0f0f23 100%)');

        const centerX = width / 2;
        const centerY = height / 2;
        let animationFrame; // 用于控制动画循环

        // 创建星空背景 - 性能优化版
        function createStarField() {
            const starCount = 50; // 减少星星数量
            const stars = [];

            for (let i = 0; i < starCount; i++) {
                stars.push({
                    x: Math.random() * width,
                    y: Math.random() * height,
                    radius: Math.random() * 1.5 + 0.5,
                    opacity: Math.random() * 0.6 + 0.4
                });
            }

            const starGroup = g.append('g').attr('class', 'star-field');

            starGroup.selectAll('.star')
                .data(stars)
                .enter()
                .append('circle')
                .attr('class', 'star')
                .attr('cx', d => d.x)
                .attr('cy', d => d.y)
                .attr('r', d => d.radius)
                .attr('fill', 'white')
                .attr('opacity', d => d.opacity);

            // 简化的闪烁动画 - 降低频率
            function twinkleStars() {
                starGroup.selectAll('.star')
                    .transition()
                    .duration(4000) // 增加持续时间
                    .attr('opacity', function(d) {
                        return Math.random() * 0.6 + 0.4;
                    })
                    .on('end', twinkleStars);
            }
            twinkleStars();
        }

        createStarField();





        // 添加标题
        const title = svg.append('text')
            .attr('x', width / 2)
            .attr('y', 60)
            .attr('text-anchor', 'middle')
            .attr('fill', 'white')
            .style('font-size', '48px')
            .style('font-weight', 'bold')
            .style('font-family', 'var(--handwriting-font)')
            .style('text-shadow', '0 0 20px rgba(255, 255, 255, 0.5)')
            .text('基本初等函数星系');

        // 添加副标题
        const subtitle = svg.append('text')
            .attr('x', width / 2)
            .attr('y', 100)
            .attr('text-anchor', 'middle')
            .attr('fill', 'rgba(255, 255, 255, 0.8)')
            .style('font-size', '20px')
            .style('font-family', 'var(--heading-font)')
            .style('text-shadow', '0 0 10px rgba(255, 255, 255, 0.3)')
            .text('初等函数是由基本初等函数经过有限次初等运算和复合构成的函数类');

        // 1. 定义行星数据 - 更精美的渐变色彩
        const planetsData = [
            { name: "幂函数", color: "#e74c3c", radius: 22, orbitRadius: 100, speed: 0.002, formula: "y = x^a", graphFunc: x => Math.pow(x, 2), domain: [-2, 2], gradientColors: ["#ff6b6b", "#e74c3c"] },
            { name: "指数函数", color: "#3498db", radius: 25, orbitRadius: 160, speed: 0.0015, formula: "y = a^x", graphFunc: x => Math.exp(x), domain: [-2, 2], gradientColors: ["#74b9ff", "#3498db"] },
            { name: "对数函数", color: "#2ecc71", radius: 25, orbitRadius: 220, speed: 0.0012, formula: "y = \\log_a x", graphFunc: x => Math.log(x), domain: [0.1, 4], gradientColors: ["#55efc4", "#2ecc71"] },
            { name: "三角函数", color: "#f1c40f", radius: 28, orbitRadius: 280, speed: 0.001, formula: "y = \\sin x", graphFunc: x => Math.sin(x), domain: [-Math.PI, Math.PI], gradientColors: ["#fdcb6e", "#f1c40f"] },
            { name: "反三角函数", color: "#9b59b6", radius: 20, orbitRadius: 340, speed: 0.0008, formula: "y = \\arcsin x", graphFunc: x => Math.asin(x), domain: [-1, 1], gradientColors: ["#a29bfe", "#9b59b6"] },
            { name: "常数函数", color: "#bdc3c7", radius: 18, orbitRadius: 60, speed: 0.0025, formula: "y = c", graphFunc: x => 2, domain: [-2, 2], gradientColors: ["#ddd", "#bdc3c7"] }
        ];

        // 2. 创建渐变效果
        const defs = svg.append("defs");
        planetsData.forEach((planet, i) => {
            const gradient = defs.append("radialGradient")
                .attr("id", `planet-gradient-${i}`);

            gradient.append("stop")
                .attr("offset", "0%")
                .attr("stop-color", planet.gradientColors[0])
                .attr("stop-opacity", 1);

            gradient.append("stop")
                .attr("offset", "100%")
                .attr("stop-color", planet.gradientColors[1])
                .attr("stop-opacity", 0.8);
        });

        // 发光滤镜
        const glowFilter = defs.append("filter")
            .attr("id", "glow")
            .attr("x", "-50%")
            .attr("y", "-50%")
            .attr("width", "200%")
            .attr("height", "200%");

        glowFilter.append("feGaussianBlur")
            .attr("stdDeviation", "4")
            .attr("result", "coloredBlur");

        const feMerge = glowFilter.append("feMerge");
        feMerge.append("feMergeNode").attr("in", "coloredBlur");
        feMerge.append("feMergeNode").attr("in", "SourceGraphic");

        // 太阳发光滤镜
        const sunGlowFilter = defs.append("filter")
            .attr("id", "sun-glow")
            .attr("x", "-100%")
            .attr("y", "-100%")
            .attr("width", "300%")
            .attr("height", "300%");

        sunGlowFilter.append("feGaussianBlur")
            .attr("stdDeviation", "8")
            .attr("result", "coloredBlur");

        const sunFeMerge = sunGlowFilter.append("feMerge");
        sunFeMerge.append("feMergeNode").attr("in", "coloredBlur");
        sunFeMerge.append("feMergeNode").attr("in", "SourceGraphic");

        // 3. 绘制轨道
        const orbits = g.selectAll(".orbit")
            .data(planetsData)
            .enter().append("circle")
            .attr("class", "orbit")
            .attr("cx", centerX)
            .attr("cy", centerY)
            .attr("r", d => d.orbitRadius)
            .attr("fill", "none")
            .attr("stroke", "rgba(255, 255, 255, 0.3)")
            .attr("stroke-width", 1)
            .attr("stroke-dasharray", "5, 5")
            .style("transform-origin", `${centerX}px ${centerY}px`);

        // 4. 绘制中央太阳
        const sun = g.append("g")
            .attr("class", "sun-group")
            .attr("transform", `translate(${centerX}, ${centerY})`);

        // 太阳光晕
        for (let i = 3; i > 0; i--) {
            sun.append("circle")
                .attr("r", 30 + i * 15)
                .attr("fill", "none")
                .attr("stroke", "#f1c40f")
                .attr("stroke-width", 1)
                .attr("opacity", 0.2 * i);
        }

        // 太阳主体
        const sunGradient = defs.append("radialGradient")
            .attr("id", "sun-gradient");

        sunGradient.append("stop")
            .attr("offset", "0%")
            .attr("stop-color", "#fff5b4")
            .attr("stop-opacity", 1);

        sunGradient.append("stop")
            .attr("offset", "50%")
            .attr("stop-color", "#f1c40f")
            .attr("stop-opacity", 1);

        sunGradient.append("stop")
            .attr("offset", "100%")
            .attr("stop-color", "#f39c12")
            .attr("stop-opacity", 0.9);

        sun.append("circle")
            .attr("r", 45)
            .attr("fill", "url(#sun-gradient)")
            .style("filter", "url(#sun-glow)");

        sun.append("text")
            .attr("text-anchor", "middle")
            .attr("dy", "0.35em")
            .attr("fill", "#333")
            .style("font-size", "14px")
            .style("font-weight", "bold")
            .style("font-family", "var(--handwriting-font)")
            .text("初等函数");

        // 5. 创建行星组
        const planets = g.selectAll(".planet")
            .data(planetsData)
            .enter().append("g")
            .attr("class", "planet");

        // 行星光环（动画效果）
        planets.append("circle")
            .attr("class", "planet-ring")
            .attr("r", d => d.radius + 5)
            .attr("stroke", d => d.color)
            .attr("stroke-width", 2)
            .attr("fill", "none")
            .attr("opacity", 0);

        // 行星主体
        planets.append("circle")
            .attr("r", d => d.radius)
            .attr("fill", (d, i) => `url(#planet-gradient-${i})`)
            .attr("stroke", d => d.color)
            .attr("stroke-width", 1)
            .attr("stroke-opacity", 0.5);

        // 行星标签
        planets.append("text")
            .attr("dy", d => d.radius + 15)
            .attr("text-anchor", "middle")
            .attr("fill", "#fff")
            .style("font-size", "12px")
            .style("font-weight", "bold")
            .style("text-shadow", "1px 1px 2px rgba(0,0,0,0.8)")
            .text(d => d.name);

        // 6. 信息展示面板
        const infoPanel = svg.append("foreignObject")
            .attr("x", 50)
            .attr("y", 140)
            .attr("width", 350)
            .attr("height", 400)
            .style("opacity", 0);

        const infoPanelDiv = infoPanel.append("xhtml:div")
            .attr("class", "info-panel")
            .style("background", "rgba(0, 0, 0, 0)")
            .style("padding", "25px")
            .style("border-radius", "15px")
            .style("color", "white")
            .style("border", "2px solid rgba(255, 255, 255, 0.3)")
            .style("box-shadow", "0 8px 32px rgba(0, 0, 0, 0.3)");

        infoPanelDiv.html(`
            <h3 id="info-name" style="margin: 0 0 15px 0; color: #f1c40f; font-size: 24px; text-align: center;"></h3>
            <div id="info-formula" style="font-size: 1.4em; margin-bottom: 15px; color: #74b9ff; text-align: center;"></div>
            <div id="info-description" style="font-size: 14px; margin-bottom: 15px; color: #ddd; line-height: 1.5;"></div>
            <div id="info-graph" style="width: 100%; height: 150px; background: rgba(255, 255, 255, 0.1); border-radius: 8px;"></div>
        `);



        // 7. 行星运行动画
        let angle = 0;
        function animate() {
            angle += 0.00003;
            planets.attr("transform", d => {
                const planetAngle = angle / d.speed;
                const x = centerX + d.orbitRadius * Math.cos(planetAngle);
                const y = centerY + d.orbitRadius * Math.sin(planetAngle);
                return `translate(${x}, ${y})`;
            });
            animationFrame = requestAnimationFrame(animate);
        }
        animate();

        // 8. 自动高亮播放
        let currentIndex = 0;
        function highlightPlanet() {
            // 恢复所有行星状态
            planets.transition().duration(500)
                .style("opacity", 0.6)
                .select("circle:nth-child(2)")
                .style("filter", null)
                .attr("r", d => d.radius);

            // 隐藏所有光环
            planets.select(".planet-ring")
                .transition().duration(500)
                .attr("opacity", 0);

            // 高亮当前行星
            const activePlanet = planets.filter((d, i) => i === currentIndex);
            activePlanet.transition().duration(500)
                .style("opacity", 1)
                .select("circle:nth-child(2)")
                .style("filter", "url(#glow)")
                .attr("r", d => d.radius * 1.3);

            // 显示光环动画
            activePlanet.select(".planet-ring")
                .transition().duration(500)
                .attr("opacity", 0.8)
                .transition().duration(1000)
                .attr("r", d => d.radius + 15)
                .attr("opacity", 0);

            // 更新并显示信息面板
            const data = activePlanet.datum();
            container.select("#info-name").text(data.name);
            container.select("#info-formula").html(`$$${data.formula}$$`);

            // 添加描述文字
            const descriptions = {
                "常数函数": "最简单的函数，图像为水平直线",
                "幂函数": "形如 y = x^a 的函数，包含多种形态",
                "指数函数": "底数为常数，指数为变量的函数",
                "对数函数": "指数函数的反函数，增长缓慢",
                "三角函数": "周期性函数，描述圆周运动",
                "反三角函数": "三角函数的反函数，定义域有限"
            };
            container.select("#info-description").text(descriptions[data.name] || "");

            infoPanel.transition().duration(500).style("opacity", 1);

            drawMiniGraph("info-graph", data.graphFunc, data.domain, data.color);
            renderMathJaxInContainer(containerId); // 重新渲染MathJax

            currentIndex = (currentIndex + 1) % planetsData.length;
        }
        // 立即触发第一次高亮，然后设置定时器
        highlightPlanet();
        const autoPlayInterval = setInterval(highlightPlanet, 3000); // 调整为更慢的5秒切换一次

        // 9. 迷你图绘制函数
        function drawMiniGraph(graphContainerId, func, domain, color) {
            const graphSetup = setupD3(graphContainerId, { top: 10, right: 10, bottom: 20, left: 25 });
            if(!graphSetup) return;

            const { g: gMini, width: wMini, height: hMini } = graphSetup;

            const yDomain = d3.extent(d3.range(domain[0], domain[1], 0.1), x => func(x));
            if(yDomain[0] === yDomain[1]) { yDomain[0] -=1; yDomain[1] +=1; } // for constant function
            if(Math.abs(yDomain[1] - yDomain[0]) < 0.1) { yDomain[1] += 1; }

            const xScale = d3.scaleLinear().domain(domain).range([0, wMini]);
            const yScale = d3.scaleLinear().domain(yDomain).range([hMini, 0]);

            gMini.append("g").attr("transform", `translate(0, ${yScale(0) || hMini})`).call(d3.axisBottom(xScale).ticks(3));
            gMini.append("g").call(d3.axisLeft(yScale).ticks(3));

            const line = d3.line()
                .x(d => xScale(d))
                .y(d => yScale(func(d)))
                .defined(d => isFinite(func(d)));

            const data = d3.range(domain[0], domain[1], (domain[1] - domain[0])/100);

            const path = gMini.append("path")
                .datum(data)
                .attr("fill", "none")
                .attr("stroke", color)
                .attr("stroke-width", 2.5)
                .attr("d", line);

            animatePath(path);
        }

        // 10. 清理函数
        // 当切换到其他幻灯片时，清除定时器和动画，避免性能问题
        container.node().cleanup = () => {
            clearInterval(autoPlayInterval);
            cancelAnimationFrame(animationFrame);
        };

        // 渲染数学公式
        setTimeout(() => {
            renderMathJaxInContainer(containerId);
        }, 1000);
    }

    function visualizeGallery(containerId, funcs, xDomain, yDomain) {
        const setup = setupD3(containerId);
        if (!setup) return;
        const { g, width, height } = setup;
        const xScale = d3.scaleLinear().domain(xDomain).range([0, width]);
        const yScale = d3.scaleLinear().domain(yDomain).range([height, 0]);
        drawAxes(g, xScale, yScale, width, height);

        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y))
            .defined(d => isFinite(d.y) && d.y < yDomain[1] && d.y > yDomain[0]);

        const colors = d3.scaleOrdinal(d3.schemeCategory10);

        funcs.forEach((f_obj, i) => {
            const data = d3.range(xDomain[0], xDomain[1] + 0.01, (xDomain[1] - xDomain[0]) / 300)
                .map(x => ({x: x, y: f_obj.func(x)}));

            const path = g.append("path").datum(data).attr("fill", "none")
                .attr("stroke", colors(i)).attr("stroke-width", 2).attr("d", line);

            animatePath(path);

            g.append("text").attr("x", 20).attr("y", 20 + i*20).text(f_obj.name).attr("fill", colors(i));
        });
    }

    /**
     * 第27页：常数与幂函数"形态进化"可视化
     * 功能：通过平滑动画展示y=x^a函数随着指数a的变化而变化的形态
     * 内容：从a=0(常数) -> a=1(直线) -> a=2(抛物线) -> a=0.5(根函数) -> a=-1(反比例)
     * 动画：使用d3.interpolate和tween函数，实现函数曲线的平滑"变形"
     * 教学目标：直观展示常数函数是幂函数的特例，并理解指数a对函数形态的决定性作用
     */
    function visualizeGalleryPower(containerId) {
        const setup = setupD3(containerId, { top: 40, right: 40, bottom: 40, left: 40 });
        if (!setup) return;
        const { svg, g, width, height, container } = setup;

        // 1. 设置坐标系
        const xScale = d3.scaleLinear().domain([-4, 4]).range([0, width]);
        const yScale = d3.scaleLinear().domain([-5, 10]).range([height, 0]);
        drawAxes(g, xScale, yScale, width, height);

        // 2. 创建动态更新的元素
        // 公式 y = x^a
        const formulaText = g.append("text")
            .attr("x", xScale(0.5))
            .attr("y", yScale(9))
            .attr("font-size", "24px")
            .attr("fill", "var(--text-color)");

        formulaText.append("tspan").text("y = x");
        const exponentTspan = formulaText.append("tspan")
            .attr("baseline-shift", "super")
            .attr("font-size", "18px")
            .text("0.00");

        // a的值的指示器
        const aValueIndicator = g.append("text")
            .attr("x", xScale(3.8))
            .attr("y", yScale(-4))
            .attr("text-anchor", "end")
            .attr("font-size", "22px")
            .attr("font-weight", "bold")
            .attr("fill", "var(--accent-color)")
            .text("a = 0.00");

        // 3. 准备绘图路径
        const lineGenerator = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y))
            .defined(d => isFinite(d.y) && d.y > -100 && d.y < 100); // 避免无穷大和无效值

        const xValues = d3.range(-4, 4.05, 0.05).map(x => x.toFixed(2)/1); // 生成x坐标点

        const path = g.append("path")
            .attr("fill", "none")
            .attr("stroke", "var(--primary-color)")
            .attr("stroke-width", 4)
            .attr("stroke-linecap", "round");

        // 4. 定义动画序列
        const animationSequence = [
            { targetA: 1.0, duration: 2000, delay: 500, name: "直线" },
            { targetA: 2.0, duration: 2000, delay: 500, name: "抛物线" },
            { targetA: 3.0, duration: 1500, delay: 500, name: "三次曲线" },
            { targetA: 0.5, duration: 2000, delay: 500, name: "根号函数" },
            { targetA: -1.0, duration: 2500, delay: 500, name: "反比例函数" },
            { targetA: 0.0, duration: 2500, delay: 1000, name: "常数函数" }
        ];

        let currentA = 0;
        let sequenceIndex = 0;
        let transition; // 用于存储当前动画，以便可以中断它

        function runAnimationStep() {
            const step = animationSequence[sequenceIndex];

            transition = svg.transition()
                .delay(step.delay)
                .duration(step.duration)
                .ease(d3.easeCubicInOut)
                .tween("exponent", () => {
                    const interpolator = d3.interpolate(currentA, step.targetA);
                    return t => {
                        const animatedA = interpolator(t);

                        // 更新数据
                        const data = xValues.map(x => ({
                            x: x,
                            y: (x < 0 && Math.abs(animatedA % 1) !== 0) ? NaN : Math.pow(x, animatedA)
                        }));

                        // 更新路径
                        path.attr("d", lineGenerator(data));

                        // 更新文本
                        exponentTspan.text(animatedA.toFixed(2));
                        aValueIndicator.text(`a = ${animatedA.toFixed(2)}`);
                    };
                })
                .on("end", () => {
                    currentA = step.targetA;
                    sequenceIndex = (sequenceIndex + 1) % animationSequence.length;
                    runAnimationStep(); // 循环播放
                });
        }

        // 5. 添加滚轮控制器
        const controlPanel = container.append('div')
            .style('position', 'absolute')
            .style('bottom', '20px')
            .style('left', '50%')
            .style('transform', 'translateX(-50%)')
            .style('background', 'rgba(0, 0, 0, 0)')
            .style('padding', '15px 25px')
            .style('border-radius', '25px')
            .style('left', '250px')
            .style('color', 'white')
            .style('font-family', 'Arial, sans-serif')
            .style('box-shadow', '0 4px 12px rgba(0, 0, 0, 0.3)')
            .style('z-index', '1000');

        // 控制标签
        controlPanel.append('div')
            .style('text-align', 'center')
            .style('margin-bottom', '10px')
            .style('font-size', '14px')
            .style('color', 'black')
            .text('手动调节指数 a');

        // 滚轮输入
        const slider = controlPanel.append('input')
            .attr('type', 'range')
            .attr('min', '-10')
            .attr('max', '10')
            .attr('step', '0.1')
            .attr('value', '0')
            .style('width', '300px')
            .style('margin', '0 15px')
            .style('color', 'black')

            .style('cursor', 'pointer');

        // 数值显示
        const valueDisplay = controlPanel.append('span')
            .style('font-size', '16px')
            .style('font-weight', 'bold')
            .style('color', 'black')

            .style('margin-left', '15px')
            .style('min-width', '60px')
            .style('display', 'inline-block')
            .text('0.0');

        // 自动/手动切换按钮
        const toggleButton = controlPanel.append('button')
            .style('margin-left', '20px')
            .style('padding', '8px 16px')
            .style('background', '#3498db')
            .style('color', 'black')

            .style('border', 'none')
            .style('border-radius', '15px')
            .style('cursor', 'pointer')
            .style('font-size', '12px')
            .text('暂停自动');

        let isAutoMode = true;

        // 更新函数图像的通用函数
        function updateGraph(aValue) {
            const data = xValues.map(x => ({
                x: x,
                y: (x < 0 && Math.abs(aValue % 1) !== 0) ? NaN : Math.pow(x, aValue)
            }));

            path.attr("d", lineGenerator(data));
            exponentTspan.text(aValue.toFixed(1));
            aValueIndicator.text(`a = ${aValue.toFixed(1)}`);
            valueDisplay.text(aValue.toFixed(1));
        }

        // 滚轮事件处理
        slider.on('input', function() {
            if (!isAutoMode) {
                const aValue = parseFloat(this.value);
                updateGraph(aValue);
            }
        });

        // 切换按钮事件处理
        toggleButton.on('click', function() {
            isAutoMode = !isAutoMode;
            if (isAutoMode) {
                this.textContent = '暂停自动';
                this.style.background = '#3498db';
                runAnimationStep(); // 重新启动自动动画
            } else {
                this.textContent = '启动自动';
                this.style.background = '#e74c3c';
                if (transition && transition.interrupt) {
                    transition.interrupt(); // 停止自动动画
                }
                // 强制停止所有D3动画
                svg.selectAll('*').interrupt();
            }
        });

        // 修改动画函数，只在自动模式下运行
        function runAnimationStep() {
            if (!isAutoMode) return; // 如果不是自动模式，不运行动画

            const step = animationSequence[sequenceIndex];

            transition = svg.transition()
                .delay(step.delay)
                .duration(step.duration)
                .ease(d3.easeCubicInOut)
                .tween("exponent", () => {
                    const interpolator = d3.interpolate(currentA, step.targetA);
                    return t => {
                        if (!isAutoMode) return; // 检查是否仍在自动模式

                        const animatedA = interpolator(t);
                        updateGraph(animatedA);
                        slider.property('value', animatedA); // 同步滚轮位置
                    };
                })
                .on("end", () => {
                    if (isAutoMode) { // 只在自动模式下继续
                        currentA = step.targetA;
                        sequenceIndex = (sequenceIndex + 1) % animationSequence.length;
                        runAnimationStep(); // 循环播放
                    }
                });
        }

        // 启动自动动画
        runAnimationStep();

        // 6. 清理函数
        container.node().cleanup = () => {
            if (transition) {
                transition.interrupt(); // 中断正在进行的动画
            }
        };

        // 渲染数学公式
        setTimeout(() => {
            renderMathJaxInContainer(containerId);
        }, 1000);
    }

    /**
     * 第28页：指数函数"形态之舞"可视化
     * 功能：全屏科技风格的指数函数动态展示
     * 内容：y=a^x的动态变化，展示增长和衰减特性
     * 动画：科技感的曲线变形和能量效果
     * 教学目标：理解指数函数的性质差异和变化规律
     */
    function visualizeGalleryExp(containerId) {
        // 全局变量
        let currentA = 1;
        let animationId;
        let autoMode = true;
        let phase = 1;
        let svg, g, xScale, yScale, width, height;
        let energyCore, curve, glowGroup;
        let trails = [];

        // 初始化
        initializeExpVisualization();
        startExpAnimation();

        // 添加必要的动画样式
        const style = document.createElement('style');
        style.textContent = `
            @keyframes expCorePulse {
                0%, 100% { transform: scale(1); opacity: 1; }
                50% { transform: scale(1.2); opacity: 0.8; }
            }
            @keyframes expExplode {
                0% { width: 0; height: 0; opacity: 1; }
                100% { width: 300px; height: 300px; opacity: 0; }
            }
            @keyframes expWarningFlash {
                0%, 100% { opacity: 0; }
                50% { opacity: 1; }
            }
            .exp-explosion-ring {
                position: absolute;
                border: 2px solid #ff0000;
                border-radius: 50%;
                box-shadow: 0 0 20px #ff0000;
            }
        `;
        document.head.appendChild(style);

        // 初始化可视化
        function initializeExpVisualization() {
            const container = d3.select('#exp-main-svg');
            const bounds = container.node().getBoundingClientRect();

            svg = container;
            width = bounds.width;
            height = bounds.height;

            // 清空SVG
            svg.selectAll("*").remove();

            // 添加标题 - 使用MathJax
            const titleFO = svg.append('foreignObject')
                .attr('x', width / 2 - 150)
                .attr('y', 30)
                .attr('width', 300)
                .attr('height', 60);

            titleFO.append('xhtml:div')
                .style('text-align', 'center')
                .style('color', '#00ffff')
                .style('font-size', '48px')
                .style('font-weight', 'bold')
                .style('font-family', 'Orbitron, monospace')
                .style('text-shadow', '0 0 20px #00ffff')
                .html('$y = a^x$');

            // 添加副标题
            const subtitleFO = svg.append('foreignObject')
                .attr('x', width / 2 - 200)
                .attr('y', 90)
                .attr('width', 400)
                .attr('height', 30);

            subtitleFO.append('xhtml:div')
                .style('text-align', 'center')
                .style('color', 'rgba(255, 255, 255, 0.8)')
                .style('font-size', '20px')
                .style('font-family', 'Orbitron, monospace')
                .text('指数函数的形态变化');

            // 创建定义区
            const defs = svg.append('defs');

            // 创建发光滤镜
            const glowFilter = defs.append('filter')
                .attr('id', 'exp-glow')
                .attr('x', '-500%')
                .attr('y', '-500%')
                .attr('width', '1000%')
                .attr('height', '1000%');

            glowFilter.append('feGaussianBlur')
                .attr('stdDeviation', '4')
                .attr('result', 'coloredBlur');

            const feMerge = glowFilter.append('feMerge');
            feMerge.append('feMergeNode').attr('in', 'coloredBlur');
            feMerge.append('feMergeNode').attr('in', 'SourceGraphic');

            // 创建强发光滤镜
            const strongGlowFilter = defs.append('filter')
                .attr('id', 'exp-strong-glow')
                .attr('x', '-500%')
                .attr('y', '-500%')
                .attr('width', '1000%')
                .attr('height', '1000%');

            strongGlowFilter.append('feGaussianBlur')
                .attr('stdDeviation', '8')
                .attr('result', 'coloredBlur');

            const strongFeMerge = strongGlowFilter.append('feMerge');
            strongFeMerge.append('feMergeNode').attr('in', 'coloredBlur');
            strongFeMerge.append('feMergeNode').attr('in', 'coloredBlur');
            strongFeMerge.append('feMergeNode').attr('in', 'SourceGraphic');

            // 主绘图组
            g = svg.append('g')
                .attr('transform', `translate(${width/2}, ${height/2})`);

            // 设置坐标轴范围
            const xRange = 5;
            const yRange = 8;

            xScale = d3.scaleLinear()
                .domain([-xRange, xRange])
                .range([-width/2 + 50, width/2 - 50]);

            yScale = d3.scaleLinear()
                .domain([-yRange, yRange])
                .range([height/2 - 50, -height/2 + 50]);

            // 绘制坐标轴（科技风格）
            drawExpTechAxes();

            // 创建曲线组
            glowGroup = g.append('g').attr('class', 'glow-group');

            // 绘制初始曲线
            updateExpCurve(currentA);

            // 创建能量核心
            createExpEnergyCore();

            // 创建合并的信息面板
            createExpCombinedPanel();
        }

        // 绘制科技风格坐标轴
        function drawExpTechAxes() {
            // X轴
            const xAxis = g.append('g').attr('class', 'x-axis');
            xAxis.append('line')
                .attr('x1', xScale(-5))
                .attr('x2', xScale(5))
                .attr('y1', yScale(0))
                .attr('y2', yScale(0))
                .attr('stroke', 'rgba(0, 255, 255, 0.3)')
                .attr('stroke-width', 1);

            // Y轴
            const yAxis = g.append('g').attr('class', 'y-axis');
            yAxis.append('line')
                .attr('x1', xScale(0))
                .attr('x2', xScale(0))
                .attr('y1', yScale(-8))
                .attr('y2', yScale(8))
                .attr('stroke', 'rgba(0, 255, 255, 0.3)')
                .attr('stroke-width', 1);

            // 添加刻度
            for (let i = -4; i <= 4; i++) {
                if (i !== 0) {
                    xAxis.append('line')
                        .attr('x1', xScale(i))
                        .attr('x2', xScale(i))
                        .attr('y1', yScale(0) - 5)
                        .attr('y2', yScale(0) + 5)
                        .attr('stroke', 'rgba(0, 255, 255, 0.2)')
                        .attr('stroke-width', 1);

                    xAxis.append('text')
                        .attr('x', xScale(i))
                        .attr('y', yScale(0) + 20)
                        .attr('text-anchor', 'middle')
                        .attr('fill', 'rgba(255, 255, 255, 0.5)')
                        .attr('font-family', 'Orbitron')
                        .attr('font-size', '10px')
                        .text(i);
                }
            }

            for (let i = -7; i <= 7; i++) {
                if (i !== 0) {
                    yAxis.append('line')
                        .attr('x1', xScale(0) - 5)
                        .attr('x2', xScale(0) + 5)
                        .attr('y1', yScale(i))
                        .attr('y2', yScale(i))
                        .attr('stroke', 'rgba(0, 255, 255, 0.2)')
                        .attr('stroke-width', 1);

                    if (i % 2 === 0) {
                        yAxis.append('text')
                            .attr('x', xScale(0) - 20)
                            .attr('y', yScale(i) + 3)
                            .attr('text-anchor', 'end')
                            .attr('fill', 'rgba(255, 255, 255, 0.5)')
                            .attr('font-family', 'Orbitron')
                            .attr('font-size', '10px')
                            .text(i);
                    }
                }
            }
        }

        // 创建能量核心
        function createExpEnergyCore() {
            const coreGroup = g.append('g')
                .attr('transform', `translate(${xScale(0)}, ${yScale(1)})`);

            // 外层光晕
            for (let i = 3; i > 0; i--) {
                coreGroup.append('circle')
                    .attr('r', 10 + i * 10)
                    .attr('fill', 'none')
                    .attr('stroke', '#00ffff')
                    .attr('stroke-width', 0.5)
                    .attr('opacity', 0.2 * i)
                    .style('animation', `expCorePulse ${2 + i * 0.5}s ease-in-out infinite`);
            }

            // 核心
            energyCore = coreGroup.append('circle')
                .attr('r', 8)
                .attr('fill', '#00ffff')
                .attr('stroke', '#ffffff')
                .attr('stroke-width', 2)
                .style('filter', 'url(#exp-strong-glow)')
                .style('animation', 'expCorePulse 1.5s ease-in-out infinite');
        }

        // 更新曲线
        function updateExpCurve(a) {
            // 移除旧曲线
            glowGroup.selectAll('.curve-path').remove();

            // 生成数据点
            const data = [];
            for (let x = -5; x <= 5; x += 0.05) {
                const y = Math.pow(a, x);
                if (y <= 20 && y >= -20) {
                    data.push({x: x, y: y});
                }
            }

            // 创建曲线生成器
            const line = d3.line()
                .x(d => xScale(d.x))
                .y(d => yScale(d.y))
                .curve(d3.curveMonotoneX)
                .defined(d => isFinite(d.y) && !isNaN(d.y));

            // 根据a值确定颜色 - 增强版
            let curveColor = '#00ffff';
            if (a > 3) {
                const t = Math.min((a - 3) / 2, 1);
                curveColor = d3.interpolateRgb('#ffd700', '#ff4500')(t); // 金色到橙红色
            } else if (a > 2) {
                const t = (a - 2) / 1;
                curveColor = d3.interpolateRgb('#00ff00', '#ffd700')(t); // 绿色到金色
            } else if (a > 1) {
                const t = (a - 1) / 1;
                curveColor = d3.interpolateRgb('#00ffff', '#00ff00')(t); // 青色到绿色
            } else if (a > 0.5) {
                const t = (a - 0.5) / 0.5;
                curveColor = d3.interpolateRgb('#ff00ff', '#00ffff')(t); // 品红到青色
            } else {
                const t = Math.max((0.5 - a) / 0.3, 0);
                curveColor = d3.interpolateRgb('#ff0080', '#ff00ff')(t); // 深粉到品红
            }

            // 添加轨迹
            if (trails.length > 5) {
                trails.shift().remove();
            }

            const trail = glowGroup.append('path')
                .datum(data)
                .attr('class', 'trail')
                .attr('d', line)
                .attr('fill', 'none')
                .attr('stroke', curveColor)
                .attr('stroke-width', 2)
                .attr('opacity', 0.4)
                .attr('stroke-linecap', 'round')
                .attr('stroke-linejoin', 'round')
                .style('filter', 'url(#exp-glow)');

            trails.push(trail);

            // 绘制主曲线
            curve = glowGroup.append('path')
                .datum(data)
                .attr('class', 'curve-path')
                .attr('d', line)
                .attr('fill', 'none')
                .attr('stroke', curveColor)
                .attr('stroke-width', 3)
                .attr('stroke-linecap', 'round')
                .attr('stroke-linejoin', 'round')
                .style('filter', 'url(#exp-glow)');

            // 添加动画效果
            const totalLength = curve.node().getTotalLength();
            curve
                .attr('stroke-dasharray', totalLength + ' ' + totalLength)
                .attr('stroke-dashoffset', totalLength)
                .transition()
                .duration(500)
                .attr('stroke-dashoffset', 0);
        }

        // 触发爆发效果
        function triggerExplosion() {
            const container = document.getElementById('exp-explosion-container');

            // 创建多个爆发环
            for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                    const ring = document.createElement('div');
                    ring.className = 'exp-explosion-ring';
                    ring.style.left = '50%';
                    ring.style.top = '50%';
                    ring.style.transform = 'translate(-50%, -50%)';
                    ring.style.animation = `expExplode ${1.5 - i * 0.2}s ease-out`;
                    container.appendChild(ring);

                    setTimeout(() => ring.remove(), 1500);
                }, i * 100);
            }

            // 显示临界点警告
            const warning = document.getElementById('exp-critical-warning');
            warning.style.opacity = '1';
            warning.style.animation = 'expWarningFlash 0.5s ease-in-out 3';

            setTimeout(() => {
                warning.style.opacity = '0';
                warning.style.animation = '';
            }, 1500);
        }

        // 创建炫酷仪表盘面板
        function createExpCombinedPanel() {
            const container = d3.select('#exp-main-container');

            // 创建仪表盘样式
            const dashboard = container.append('div')
                .attr('class', 'exp-dashboard')
                .style('font-family', 'Rajdhani, sans-serif')
                .style('margin', '0')
                .style('box-sizing', 'border-box')
                .style('position', 'absolute')
                .style('top', '30px')
                .style('right', '30px')
                .style('background', 'linear-gradient(135deg, rgba(0, 20, 40, 0.9), rgba(0, 40, 80, 0.7))')
                .style('border', '1px solid rgba(0, 255, 255, 0.3)')
                .style('border-radius', '10px')
                .style('padding', '20px')
                .style('box-shadow', '0 0 30px rgba(0, 255, 255, 0.2), inset 0 0 20px rgba(0, 255, 255, 0.1)')
                .style('z-index', '100')
                .style('backdrop-filter', 'blur(10px)')
                .style('min-width', '200px');

            // 标题
            dashboard.append('div')
                .attr('class', 'dashboard-title')
                .style('color', '#00ffff')
                .style('font-size', '16px')
                .style('font-weight', 'bold')
                .style('text-align', 'center')
                .style('margin-bottom', '15px')
                .style('text-transform', 'uppercase')
                .style('letter-spacing', '2px')
                .text('Parameter α');

            // 参数显示
            dashboard.append('div')
                .attr('class', 'parameter-display')
                .attr('id', 'exp-param-value')
                .style('color', '#00ffff')
                .style('font-size', '36px')
                .style('font-weight', 'bold')
                .style('text-align', 'center')
                .style('margin-bottom', '15px')
                .style('text-shadow', '0 0 10px #00ffff')
                .text('1.00');

            // 公式显示
            const formulaDiv = dashboard.append('div')
                .attr('class', 'formula-display')
                .style('text-align', 'center')
                .style('margin-bottom', '15px');

            formulaDiv.append('span')
                .style('font-size', '24px')
                .style('color', '#ffffff')
                .text('y = ');

            formulaDiv.append('span')
                .attr('id', 'exp-base-value')
                .style('font-size', '24px')
                .style('color', '#00ffff')
                .style('font-weight', 'bold')
                .text('1.00');

            formulaDiv.append('span')
                .style('font-size', '24px')
                .style('color', '#ffffff')
                .text('ˣ');

            // 阶段显示
            dashboard.append('div')
                .attr('id', 'exp-phase-name')
                .style('color', '#ff6b6b')
                .style('font-size', '14px')
                .style('font-weight', 'bold')
                .style('text-align', 'center')
                .style('margin-bottom', '5px')
                .style('text-transform', 'uppercase')
                .style('letter-spacing', '1px')
                .text('衰减阶段');

            dashboard.append('div')
                .attr('id', 'exp-phase-subtitle')
                .style('color', 'rgba(255, 255, 255, 0.7)')
                .style('font-size', '12px')
                .style('text-align', 'center')
                .style('margin-bottom', '15px')
                .text('能量耗散模式');

            // 函数特性
            dashboard.append('div')
                .style('color', '#ffd700')
                .style('font-size', '12px')
                .style('font-weight', 'bold')
                .style('margin-bottom', '8px')
                .style('border-top', '1px solid rgba(255, 255, 255, 0.2)')
                .style('padding-top', '10px')
                .text('函数特性');

            dashboard.append('div')
                .attr('id', 'exp-properties')
                .style('color', 'rgba(255, 255, 255, 0.8)')
                .style('font-size', '11px')
                .style('line-height', '1.4');

            // 初始化信息
            updateExpInfo(currentA);
        }

        // 更新信息面板
        function updateExpInfo(a) {
            const properties = d3.select('#exp-properties');
            const values = d3.select('#exp-values');

            let description = '';
            let valueInfo = '';

            if (a > 1) {
                description = `• 增长型指数函数<br>• 单调递增<br>• 图像过点(0,1)<br>• 当x→∞时，y→∞<br>• 当x→-∞时，y→0`;
                valueInfo = `f(0) = 1<br>f(1) = ${a.toFixed(2)}<br>f(2) = ${Math.pow(a, 2).toFixed(2)}<br>f(-1) = ${(1/a).toFixed(3)}`;
            } else if (a === 1) {
                description = `• 常数函数<br>• y = 1 (水平线)<br>• 既不增也不减<br>• 所有点的函数值都是1`;
                valueInfo = `f(x) = 1 (对所有x)`;
            } else if (a > 0 && a < 1) {
                description = `• 衰减型指数函数<br>• 单调递减<br>• 图像过点(0,1)<br>• 当x→∞时，y→0<br>• 当x→-∞时，y→∞`;
                valueInfo = `f(0) = 1<br>f(1) = ${a.toFixed(3)}<br>f(2) = ${Math.pow(a, 2).toFixed(3)}<br>f(-1) = ${(1/a).toFixed(2)}`;
            }

            properties.html(description);
            values.html(valueInfo);
        }

        // 主动画循环 - 加快4倍节奏
        function animateExp() {
            if (!autoMode) return;

            // 第一幕：衰减之舞 (1 -> 0.2) - 加快4倍
            if (phase === 1) {
                currentA = Math.max(0.2, currentA - 0.05);
                if (currentA <= 0.2) {
                    phase = 2;
                    updateExpPhaseDisplay('临界接近', '接近奇点...');
                }
            }
            // 第二幕：临界时刻 (0.2 -> 1) - 加快4倍
            else if (phase === 2) {
                currentA = Math.min(1, currentA + 0.03);
                if (Math.abs(currentA - 1) < 0.02) {
                    triggerExplosion();
                    currentA = 1;
                    phase = 3;
                    updateExpPhaseDisplay('增长爆发', '指数扩张启动');
                }
            }
            // 第三幕：增长之舞 (1 -> 5) - 加快4倍
            else if (phase === 3) {
                currentA = Math.min(5, currentA + 0.1);

                if (currentA >= 5) {
                    phase = 1;
                    updateExpPhaseDisplay('衰减阶段', '能量耗散模式');
                }
            }

            // 更新显示
            updateExpDisplay(currentA);
            updateExpCurve(currentA);
            updateExpInfo(currentA);

            animationId = requestAnimationFrame(animateExp);
        }

        // 开始动画
        function startExpAnimation() {
            updateExpPhaseDisplay('DECAY PHASE', 'Energy dissipation mode');
            animateExp();
        }

        // 更新显示
        function updateExpDisplay(a) {
            d3.select('#exp-param-value').text(a.toFixed(2));
            d3.select('#exp-base-value').text(a.toFixed(2));
        }

        // 更新阶段显示
        function updateExpPhaseDisplay(name, subtitle) {
            d3.select('#exp-phase-name').text(name);
            d3.select('#exp-phase-subtitle').text(subtitle);
        }



    }

    /**
     * 第29页：对数函数"镜像之舞"可视化
     * 功能：全屏科技风格的对数函数动态展示
     * 内容：y=log_a(x)的动态变化，展示对数函数的镜像特性
     * 动画：科技感的曲线变形和镜像效果
     * 教学目标：理解对数函数与指数函数的反函数关系
     */
    function visualizeGalleryLog(containerId) {
        // 全局变量
        let currentA = 2;
        let animationId;
        let autoMode = true;
        let phase = 1;
        let svg, g, xScale, yScale, width, height;
        let energyCore, curve, glowGroup, mirrorGroup;
        let trails = [];

        // 初始化
        initializeLogVisualization();
        startLogAnimation();

        // 添加必要的动画样式
        const style = document.createElement('style');
        style.textContent = `
            @keyframes logCorePulse {
                0%, 100% { transform: scale(1); opacity: 1; }
                50% { transform: scale(1.2); opacity: 0.8; }
            }
            @keyframes logMirrorFlash {
                0% { opacity: 0.3; }
                100% { opacity: 1; }
            }
            @keyframes logResonance {
                0%, 100% { opacity: 0; }
                50% { opacity: 1; }
            }
            .log-mirror-ring {
                position: absolute;
                border: 2px solid #ff1493;
                border-radius: 50%;
                box-shadow: 0 0 20px #ff1493;
            }
        `;
        document.head.appendChild(style);

        // 初始化可视化
        function initializeLogVisualization() {
            const container = d3.select('#log-main-svg');
            const bounds = container.node().getBoundingClientRect();

            svg = container;
            width = bounds.width;
            height = bounds.height;

            // 清空SVG
            svg.selectAll("*").remove();

            // 添加标题 - 使用MathJax
            const titleFO = svg.append('foreignObject')
                .attr('x', width / 2 - 150)
                .attr('y', 30)
                .attr('width', 300)
                .attr('height', 60);

            titleFO.append('xhtml:div')
                .style('text-align', 'center')
                .style('color', '#ff1493')
                .style('font-size', '48px')
                .style('font-weight', 'bold')
                .style('font-family', 'Orbitron, monospace')
                .style('text-shadow', '0 0 20px #ff1493')
                .html('$y = \\log_a x$');

            // 添加副标题
            const subtitleFO = svg.append('foreignObject')
                .attr('x', width / 2 - 250)
                .attr('y', 90)
                .attr('width', 500)
                .attr('height', 30);

            subtitleFO.append('xhtml:div')
                .style('text-align', 'center')
                .style('color', 'rgba(255, 255, 255, 0.8)')
                .style('font-size', '20px')
                .style('font-family', 'Orbitron, monospace')
                .text('对数函数与指数函数的镜像关系');

            // 创建定义区
            const defs = svg.append('defs');

            // 创建发光滤镜 - 品红/金色版本
            const glowFilter = defs.append('filter')
                .attr('id', 'log-glow')
                .attr('x', '-500%')
                .attr('y', '-500%')
                .attr('width', '1000%')
                .attr('height', '1000%');

            glowFilter.append('feGaussianBlur')
                .attr('stdDeviation', '4')
                .attr('result', 'coloredBlur');

            const feMerge = glowFilter.append('feMerge');
            feMerge.append('feMergeNode').attr('in', 'coloredBlur');
            feMerge.append('feMergeNode').attr('in', 'SourceGraphic');

            // 创建强发光滤镜
            const strongGlowFilter = defs.append('filter')
                .attr('id', 'log-strong-glow')
                .attr('x', '-500%')
                .attr('y', '-500%')
                .attr('width', '1000%')
                .attr('height', '1000%');

            strongGlowFilter.append('feGaussianBlur')
                .attr('stdDeviation', '8')
                .attr('result', 'coloredBlur');

            const strongFeMerge = strongGlowFilter.append('feMerge');
            strongFeMerge.append('feMergeNode').attr('in', 'coloredBlur');
            strongFeMerge.append('feMergeNode').attr('in', 'coloredBlur');
            strongFeMerge.append('feMergeNode').attr('in', 'SourceGraphic');

            // 主绘图组
            g = svg.append('g')
                .attr('transform', `translate(${width/2}, ${height/2})`);

            // 设置坐标轴范围
            const xRange = 5;
            const yRange = 5;

            xScale = d3.scaleLinear()
                .domain([-xRange, xRange])
                .range([-width/2 + 50, width/2 - 50]);

            yScale = d3.scaleLinear()
                .domain([-yRange, yRange])
                .range([height/2 - 50, -height/2 + 50]);

            // 绘制坐标轴（科技风格）
            drawLogTechAxes();

            // 绘制镜像线 y = x
            drawMirrorLine();

            // 创建镜像组
            mirrorGroup = g.append('g').attr('class', 'mirror-group');

            // 创建曲线组
            glowGroup = g.append('g').attr('class', 'glow-group');

            // 绘制初始曲线
            updateLogCurve(currentA);

            // 创建能量核心
            createLogEnergyCore();

            // 创建合并的信息面板
            createLogCombinedPanel();
        }

        // 绘制科技风格坐标轴
        function drawLogTechAxes() {
            // X轴
            const xAxis = g.append('g').attr('class', 'x-axis');
            xAxis.append('line')
                .attr('x1', xScale(-5))
                .attr('x2', xScale(5))
                .attr('y1', yScale(0))
                .attr('y2', yScale(0))
                .attr('stroke', 'rgba(255, 20, 147, 0.3)')
                .attr('stroke-width', 1);

            // Y轴
            const yAxis = g.append('g').attr('class', 'y-axis');
            yAxis.append('line')
                .attr('x1', xScale(0))
                .attr('x2', xScale(0))
                .attr('y1', yScale(-5))
                .attr('y2', yScale(5))
                .attr('stroke', 'rgba(255, 20, 147, 0.3)')
                .attr('stroke-width', 1);

            // 添加刻度
            for (let i = -4; i <= 4; i++) {
                if (i !== 0) {
                    xAxis.append('line')
                        .attr('x1', xScale(i))
                        .attr('x2', xScale(i))
                        .attr('y1', yScale(0) - 5)
                        .attr('y2', yScale(0) + 5)
                        .attr('stroke', 'rgba(255, 20, 147, 0.2)')
                        .attr('stroke-width', 1);

                    xAxis.append('text')
                        .attr('x', xScale(i))
                        .attr('y', yScale(0) + 20)
                        .attr('text-anchor', 'middle')
                        .attr('fill', 'rgba(255, 255, 255, 0.5)')
                        .attr('font-family', 'Orbitron')
                        .attr('font-size', '10px')
                        .text(i);
                }
            }

            for (let i = -4; i <= 4; i++) {
                if (i !== 0) {
                    yAxis.append('line')
                        .attr('x1', xScale(0) - 5)
                        .attr('x2', xScale(0) + 5)
                        .attr('y1', yScale(i))
                        .attr('y2', yScale(i))
                        .attr('stroke', 'rgba(255, 20, 147, 0.2)')
                        .attr('stroke-width', 1);

                    if (i % 2 === 0) {
                        yAxis.append('text')
                            .attr('x', xScale(0) - 20)
                            .attr('y', yScale(i) + 3)
                            .attr('text-anchor', 'end')
                            .attr('fill', 'rgba(255, 255, 255, 0.5)')
                            .attr('font-family', 'Orbitron')
                            .attr('font-size', '10px')
                            .text(i);
                    }
                }
            }
        }

        // 绘制镜像线 y = x
        function drawMirrorLine() {
            g.append('line')
                .attr('x1', xScale(-5))
                .attr('x2', xScale(5))
                .attr('y1', yScale(-5))
                .attr('y2', yScale(5))
                .attr('stroke', '#ffd700')
                .attr('stroke-width', 2)
                .attr('stroke-dasharray', '5,5')
                .attr('opacity', 0.6)
                .style('filter', 'url(#log-glow)');

            // 镜像线标签
            g.append('text')
                .attr('x', xScale(3))
                .attr('y', yScale(3.5))
                .attr('fill', '#ffd700')
                .attr('font-family', 'Orbitron')
                .attr('font-size', '14px')
                .text('y = x (镜像线)');
        }

        // 创建能量核心
        function createLogEnergyCore() {
            const coreGroup = g.append('g')
                .attr('transform', `translate(${xScale(1)}, ${yScale(0)})`);

            // 外层光晕
            for (let i = 3; i > 0; i--) {
                coreGroup.append('circle')
                    .attr('r', 10 + i * 10)
                    .attr('fill', 'none')
                    .attr('stroke', '#ff1493')
                    .attr('stroke-width', 0.5)
                    .attr('opacity', 0.2 * i)
                    .style('animation', `logCorePulse ${2 + i * 0.5}s ease-in-out infinite`);
            }

            // 核心
            energyCore = coreGroup.append('circle')
                .attr('r', 8)
                .attr('fill', '#ff1493')
                .attr('stroke', '#ffffff')
                .attr('stroke-width', 2)
                .style('filter', 'url(#log-strong-glow)')
                .style('animation', 'logCorePulse 1.5s ease-in-out infinite');
        }

        // 更新对数曲线
        function updateLogCurve(a) {
            // 移除旧曲线
            glowGroup.selectAll('.curve-path').remove();
            mirrorGroup.selectAll('.exp-curve').remove();

            // 生成对数函数数据点
            const logData = [];
            for (let x = 0.01; x <= 5; x += 0.01) {
                const y = Math.log(x) / Math.log(a);
                if (y >= -5 && y <= 5) {
                    logData.push({x: x, y: y});
                }
            }

            // 生成对应的指数函数数据点（镜像）
            const expData = [];
            for (let x = -5; x <= 5; x += 0.05) {
                const y = Math.pow(a, x);
                if (y >= 0.01 && y <= 5) {
                    expData.push({x: x, y: y});
                }
            }

            // 创建曲线生成器
            const line = d3.line()
                .x(d => xScale(d.x))
                .y(d => yScale(d.y))
                .curve(d3.curveMonotoneX)
                .defined(d => isFinite(d.y) && !isNaN(d.y) && isFinite(d.x) && !isNaN(d.x));

            // 根据a值确定颜色 - 增强版
            let logColor = '#ff1493';
            let expColor = '#00ffff';

            if (a > 4) {
                const t = Math.min((a - 4) / 1, 1);
                logColor = d3.interpolateRgb('#ffd700', '#ff4500')(t); // 金色到橙红色
                expColor = d3.interpolateRgb('#00ff00', '#ff4500')(t); // 绿色到橙红色
            } else if (a > 3) {
                const t = (a - 3) / 1;
                logColor = d3.interpolateRgb('#00ff80', '#ffd700')(t); // 青绿到金色
                expColor = d3.interpolateRgb('#80ff00', '#00ff00')(t); // 黄绿到绿色
            } else if (a > 2) {
                const t = (a - 2) / 1;
                logColor = d3.interpolateRgb('#ff1493', '#00ff80')(t); // 品红到青绿
                expColor = d3.interpolateRgb('#00ffff', '#80ff00')(t); // 青色到黄绿
            } else if (a > 1) {
                const t = (a - 1) / 1;
                logColor = d3.interpolateRgb('#ff6b9d', '#ff1493')(t); // 浅粉到品红
                expColor = d3.interpolateRgb('#6bb6ff', '#00ffff')(t); // 浅蓝到青色
            } else if (a > 0.5) {
                const t = (a - 0.5) / 0.5;
                logColor = d3.interpolateRgb('#ff00ff', '#ff6b9d')(t); // 紫色到浅粉
                expColor = d3.interpolateRgb('#8000ff', '#6bb6ff')(t); // 紫色到浅蓝
            } else {
                const t = Math.max((0.5 - a) / 0.3, 0);
                logColor = d3.interpolateRgb('#8000ff', '#ff00ff')(t); // 深紫到紫色
                expColor = d3.interpolateRgb('#4000ff', '#8000ff')(t); // 深蓝紫到深紫
            }

            // 添加轨迹
            if (trails.length > 3) {
                trails.shift().remove();
            }

            const logTrail = glowGroup.append('path')
                .datum(logData)
                .attr('class', 'trail')
                .attr('d', line)
                .attr('fill', 'none')
                .attr('stroke', logColor)
                .attr('stroke-width', 2)
                .attr('opacity', 0.4)
                .attr('stroke-linecap', 'round')
                .attr('stroke-linejoin', 'round')
                .style('filter', 'url(#log-glow)');

            trails.push(logTrail);

            // 绘制对数函数主曲线
            curve = glowGroup.append('path')
                .datum(logData)
                .attr('class', 'curve-path')
                .attr('d', line)
                .attr('fill', 'none')
                .attr('stroke', logColor)
                .attr('stroke-width', 3)
                .attr('stroke-linecap', 'round')
                .attr('stroke-linejoin', 'round')
                .style('filter', 'url(#log-glow)');

            // 绘制镜像的指数函数曲线
            const expCurve = mirrorGroup.append('path')
                .datum(expData)
                .attr('class', 'exp-curve')
                .attr('d', line)
                .attr('fill', 'none')
                .attr('stroke', expColor)
                .attr('stroke-width', 2)
                .attr('stroke-linecap', 'round')
                .attr('stroke-linejoin', 'round')
                .attr('opacity', 0.6)
                .style('filter', 'url(#log-glow)');

            // 添加动画效果
            const totalLength = curve.node().getTotalLength();
            curve
                .attr('stroke-dasharray', totalLength + ' ' + totalLength)
                .attr('stroke-dashoffset', totalLength)
                .transition()
                .duration(500)
                .attr('stroke-dashoffset', 0);

            const expTotalLength = expCurve.node().getTotalLength();
            expCurve
                .attr('stroke-dasharray', expTotalLength + ' ' + expTotalLength)
                .attr('stroke-dashoffset', expTotalLength)
                .transition()
                .duration(500)
                .delay(200)
                .attr('stroke-dashoffset', 0);
        }

        // 触发镜像共振效果
        function triggerMirrorResonance() {
            const container = document.getElementById('log-explosion-container');

            // 创建多个共振环
            for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                    const ring = document.createElement('div');
                    ring.className = 'log-mirror-ring';
                    ring.style.left = '50%';
                    ring.style.top = '50%';
                    ring.style.transform = 'translate(-50%, -50%)';
                    ring.style.animation = `logMirrorFlash ${1.5 - i * 0.2}s ease-out`;
                    container.appendChild(ring);

                    setTimeout(() => ring.remove(), 1500);
                }, i * 100);
            }

            // 显示镜像共振警告
            const warning = document.getElementById('log-critical-warning');
            warning.style.opacity = '1';
            warning.style.animation = 'logResonance 0.5s ease-in-out 3';

            setTimeout(() => {
                warning.style.opacity = '0';
                warning.style.animation = '';
            }, 1500);
        }

        // 创建炫酷仪表盘面板
        function createLogCombinedPanel() {
            const container = d3.select('#log-main-container');

            // 创建仪表盘样式
            const dashboard = container.append('div')
                .attr('class', 'log-dashboard')
                .style('font-family', 'Rajdhani, sans-serif')
                .style('margin', '0')
                .style('box-sizing', 'border-box')
                .style('position', 'absolute')
                .style('top', '30px')
                .style('right', '30px')
                .style('background', 'linear-gradient(135deg, rgba(40, 0, 20, 0.9), rgba(80, 0, 40, 0.7))')
                .style('border', '1px solid rgba(255, 20, 147, 0.3)')
                .style('border-radius', '10px')
                .style('padding', '20px')
                .style('box-shadow', '0 0 30px rgba(255, 20, 147, 0.2), inset 0 0 20px rgba(255, 20, 147, 0.1)')
                .style('z-index', '100')
                .style('backdrop-filter', 'blur(10px)')
                .style('min-width', '200px');

            // 标题
            dashboard.append('div')
                .attr('class', 'dashboard-title')
                .style('color', '#ff1493')
                .style('font-size', '16px')
                .style('font-weight', 'bold')
                .style('text-align', 'center')
                .style('margin-bottom', '15px')
                .style('text-transform', 'uppercase')
                .style('letter-spacing', '2px')
                .text('Parameter α');

            // 参数显示
            dashboard.append('div')
                .attr('class', 'parameter-display')
                .attr('id', 'log-param-value')
                .style('color', '#ff1493')
                .style('font-size', '36px')
                .style('font-weight', 'bold')
                .style('text-align', 'center')
                .style('margin-bottom', '15px')
                .style('text-shadow', '0 0 10px #ff1493')
                .text('2.00');

            // 公式显示
            const formulaDiv = dashboard.append('div')
                .attr('class', 'formula-display')
                .style('text-align', 'center')
                .style('margin-bottom', '15px');

            formulaDiv.append('span')
                .style('font-size', '20px')
                .style('color', '#ffffff')
                .text('y = log');

            formulaDiv.append('span')
                .attr('id', 'log-base-value')
                .style('font-size', '14px')
                .style('color', '#ff1493')
                .style('font-weight', 'bold')
                .style('vertical-align', 'sub')
                .text('2.00');

            formulaDiv.append('span')
                .style('font-size', '20px')
                .style('color', '#ffffff')
                .text('(x)');

            // 阶段显示
            dashboard.append('div')
                .attr('id', 'log-phase-name')
                .style('color', '#ff6b6b')
                .style('font-size', '14px')
                .style('font-weight', 'bold')
                .style('text-align', 'center')
                .style('margin-bottom', '5px')
                .style('text-transform', 'uppercase')
                .style('letter-spacing', '1px')
                .text('镜像同步');

            dashboard.append('div')
                .attr('id', 'log-phase-subtitle')
                .style('color', 'rgba(255, 255, 255, 0.7)')
                .style('font-size', '12px')
                .style('text-align', 'center')
                .style('margin-bottom', '15px')
                .text('对数反射模式');

            // 函数特性
            dashboard.append('div')
                .style('color', '#ffd700')
                .style('font-size', '12px')
                .style('font-weight', 'bold')
                .style('margin-bottom', '8px')
                .style('border-top', '1px solid rgba(255, 255, 255, 0.2)')
                .style('padding-top', '10px')
                .text('函数特性');

            dashboard.append('div')
                .attr('id', 'log-properties')
                .style('color', 'rgba(255, 255, 255, 0.8)')
                .style('font-size', '11px')
                .style('line-height', '1.4');

            // 初始化信息
            updateLogInfo(currentA);
        }

        // 更新信息面板
        function updateLogInfo(a) {
            const properties = d3.select('#log-properties');
            const values = d3.select('#log-values');
            const mirror = d3.select('#log-mirror');

            let description = '';
            let valueInfo = '';
            let mirrorInfo = '';

            if (a > 1) {
                description = `• 增长型对数函数<br>• 单调递增<br>• 图像过点(1,0)<br>• 定义域: x > 0<br>• 值域: 所有实数`;
                valueInfo = `f(1) = 0<br>f(${a.toFixed(1)}) = 1<br>f(${Math.pow(a, 2).toFixed(1)}) = 2<br>f(${(1/a).toFixed(2)}) = -1`;
                mirrorInfo = `镜像关系:<br>y = log_${a.toFixed(1)}(x) ↔ y = ${a.toFixed(1)}^x<br>关于直线 y = x 对称`;
            } else if (a > 0 && a < 1) {
                description = `• 衰减型对数函数<br>• 单调递减<br>• 图像过点(1,0)<br>• 定义域: x > 0<br>• 值域: 所有实数`;
                valueInfo = `f(1) = 0<br>f(${a.toFixed(2)}) = 1<br>f(${Math.pow(a, 2).toFixed(3)}) = 2<br>f(${(1/a).toFixed(1)}) = -1`;
                mirrorInfo = `镜像关系:<br>y = log_${a.toFixed(2)}(x) ↔ y = ${a.toFixed(2)}^x<br>关于直线 y = x 对称`;
            }

            properties.html(description);
            values.html(valueInfo);
            mirror.html(mirrorInfo);
        }

        // 主动画循环 - 加快4倍节奏

        function animateLog() {
            if (!autoMode) return;

            // 第一幕：收缩镜像 (2 -> 0.5) - 加快4倍
            if (phase === 1) {
                currentA = Math.max(0.5, currentA - 0.05);
                if (currentA <= 0.5) {
                    phase = 2;
                    updateLogPhaseDisplay('临界镜像', '接近反射点...');
                }
            }
            // 第二幕：镜像共振 (0.5 -> 2) - 加快4倍
            else if (phase === 2) {
                currentA = Math.min(2, currentA + 0.04);
                if (Math.abs(currentA - 1) < 0.04) {
                    triggerMirrorResonance();
                }
                if (currentA >= 2) {
                    phase = 3;
                    updateLogPhaseDisplay('扩展阶段', '对数增长启动');
                }
            }
            // 第三幕：扩展镜像 (2 -> 5) - 加快4倍
            else if (phase === 3) {
                currentA = Math.min(5, currentA + 0.08);

                if (currentA >= 5) {
                    phase = 1;
                    updateLogPhaseDisplay('镜像同步', '对数反射模式');
                }
            }

            // 更新显示
            updateLogDisplay(currentA);
            updateLogCurve(currentA);
            updateLogInfo(currentA);

            animationId = requestAnimationFrame(animateLog);
        }

        // 开始动画
        function startLogAnimation() {
            updateLogPhaseDisplay('MIRROR SYNC', 'Logarithmic reflection mode');
            animateLog();
        }

        // 更新显示
        function updateLogDisplay(a) {
            d3.select('#log-param-value').text(a.toFixed(2));
            d3.select('#log-base-value').text(a.toFixed(2));
        }

        // 更新阶段显示
        function updateLogPhaseDisplay(name, subtitle) {
            d3.select('#log-phase-name').text(name);
            d3.select('#log-phase-subtitle').text(subtitle);
        }


    }



    /**
     * 第33页：复合函数机器可视化
     * 功能：演示复合函数的嵌套结构
     * 内容：f(g(x))的层层计算过程
     * 动画：双重函数机器的串联操作
     * 教学目标：理解复合函数的计算顺序
     */
    function visualizeCompositeMachine(containerId) {
        const container = document.getElementById(containerId);
        if (!container) return;

        // 清空容器并设置样式
        container.innerHTML = '';
        container.style.cssText = `
            font-family: 'JetBrains Mono', 'Noto Sans TC', monospace;
            background-color: #f8fafc;
            color: #1f2937;
            background-image:
                linear-gradient(rgba(0,0,0,0.04) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0,0,0,0.04) 1px, transparent 1px);
            background-size: 20px 20px;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 2rem;
        `;

        // 创建HTML结构
        container.innerHTML = `
            <!-- 题目定义区 -->
            <div id="problem-definition" style="width: 100%; max-width: 32rem; text-align: center; margin-bottom: 2rem; animation: fadeIn 0.5s ease-in-out forwards; padding-top: 2rem;">
                <div style="font-size: 1.25rem; background: #f3f4f6; padding: 1rem; border-radius: 0.5rem; display: inline-block; border: 1px solid #d1d5db;">
                    <span style="margin-right: 1rem;">令: <span style="color: #dc2626;">f(x) = x²</span></span>
                    <span style="margin-right: 1rem;">且: <span style="color: #2563eb;">g(x) = x + 1</span></span>
                    <span>解析: <span style="color: #d97706;">f(g(2))</span></span>
                </div>
            </div>

            <!-- 主表达式动画区 -->
            <div id="main-expression-area" style="width: 100%; flex-grow: 1; display: flex; align-items: center; justify-content: center; font-size: 3rem; margin: 2rem 0;">
                <span id="f-scope" class="scope scope-f">
                    f(<span id="g-scope" class="scope scope-g">
                        g(<span id="g-param">2</span>)
                    </span>)
                </span>
            </div>

            <!-- 演算区 -->
            <div id="calculation-area" style="width: 100%; display: flex; justify-content: center; margin-top: auto;">
                <div style="border: 2px dashed #9ca3af; border-radius: 0.5rem; padding: 2rem; min-width: 320px;">
                    <h2 style="font-size: 1.5rem; color: #6b7280; margin-bottom: 1rem; text-align: center;">演算区</h2>
                    <div id="calc-content" style="font-size: 2.5rem; display: flex; flex-direction: column; align-items: center; gap: 0.75rem;"></div>
                </div>
            </div>
        `;

        // 启动动画
        setTimeout(() => {
            runCompositeAnimation(container);
        }, 500);
    }

    // 全局变量用于管理复合函数动画
    let compositeAnimationRunning = false;
    let compositeAnimationTimeouts = [];
    let compositeMovingElements = [];

    // 复合函数板书动画函数
    async function runCompositeAnimation(container) {
        // 检查容器是否还在当前页面中
        if (!container || !container.closest('.slide.active')) {
            return;
        }

        compositeAnimationRunning = true;
        const fScope = container.querySelector('#f-scope');
        const gScope = container.querySelector('#g-scope');
        const calcContent = container.querySelector('#calc-content');

        // 等待指定时间的辅助函数（支持全局速度控制和页面切换检测）
        const wait = (ms) => new Promise(resolve => {
            const adjustedTime = ms / globalAnimationSpeed;
            const checkPause = () => {
                // 检查动画是否应该停止
                if (!compositeAnimationRunning || !container.closest('.slide.active')) {
                    resolve();
                    return;
                }

                if (globalAnimationPlaying) {
                    const timeoutId = setTimeout(resolve, adjustedTime);
                    compositeAnimationTimeouts.push(timeoutId);
                } else {
                    const timeoutId = setTimeout(checkPause, 100);
                    compositeAnimationTimeouts.push(timeoutId);
                }
            };
            checkPause();
        });

        // 动态创建一个用于移动的元素（支持全局速度控制和清理）
        function createMovingElement(text, classNames) {
            const movingEl = document.createElement('span');
            const transitionDuration = (0.8 / globalAnimationSpeed).toFixed(2);
            movingEl.style.cssText = `
                position: absolute;
                transition: all ${transitionDuration}s cubic-bezier(0.4, 0, 0.2, 1);
                z-index: 100;
                font-family: 'JetBrains Mono', monospace;
            `;
            movingEl.innerText = text;
            movingEl.className = classNames;
            movingEl.setAttribute('data-composite-element', 'true');
            document.body.appendChild(movingEl);
            compositeMovingElements.push(movingEl);
            return movingEl;
        }

        // 在演算区新增一个步骤
        function addCalcStep(htmlContent, parentElement) {
            const step = document.createElement('div');
            step.innerHTML = htmlContent;
            step.style.animation = 'fadeIn 0.5s ease-in-out forwards';
            parentElement.appendChild(step);
            return step;
        }

        await wait(1000);

        // 步骤一: 内层隔离与聚焦
        gScope.classList.add('highlight-g');
        await wait(1000);

        const gScopeRect = gScope.getBoundingClientRect();
        const calcAreaRect = container.querySelector('#calculation-area').getBoundingClientRect();
        const movingGScope = createMovingElement(gScope.innerText, gScope.className);
        movingGScope.style.left = `${gScopeRect.left}px`;
        movingGScope.style.top = `${gScopeRect.top}px`;
        movingGScope.style.fontSize = '3rem';

        gScope.style.opacity = '0';
        await wait(100);

        // 移动到演算区
        const firstStepTargetTop = calcAreaRect.top + container.querySelector('#calculation-area h2').offsetHeight + 30;
        movingGScope.style.left = `${calcAreaRect.left + calcAreaRect.width / 2 - movingGScope.offsetWidth / 2}px`;
        movingGScope.style.top = `${firstStepTargetTop}px`;
        movingGScope.style.transform = 'scale(0.8)';
        await wait(1000);

        // 步骤二: 内层求值
        movingGScope.remove();

        const gLine = document.createElement('div');
        gLine.style.cssText = 'display: flex; align-items: center; justify-content: center; gap: 1rem; flex-wrap: wrap;';
        calcContent.appendChild(gLine);

        addCalcStep('<span class="scope scope-g">g(2)</span>', gLine);
        await wait(1000);

        addCalcStep(`<div style="display: flex; align-items: center;"><span style="color: #9ca3af; font-size: 2rem; margin: 0 0.5rem;">=</span><span style="color: #2563eb;">2 + 1</span></div>`, gLine);
        await wait(1000);

        const gResult = 3;
        const gResultStep = addCalcStep(`<div style="display: flex; align-items: center;"><span style="color: #9ca3af; font-size: 2rem; margin: 0 0.5rem;">=</span><span style="color: #16a34a; font-weight: bold;">${gResult}</span></div>`, gLine);
        await wait(1000);

        // 步骤三: 结果回代
        const gResultEl = gResultStep.querySelector('span:last-child');
        const result3Rect = gResultEl.getBoundingClientRect();
        const movingResult3 = createMovingElement(gResult, 'font-bold');
        movingResult3.style.left = `${result3Rect.left}px`;
        movingResult3.style.top = `${result3Rect.top}px`;
        movingResult3.style.color = '#16a34a';
        movingResult3.style.fontSize = '3rem';

        gResultEl.style.opacity = '0';
        await wait(100);

        gScope.style.animation = 'shrinkOut 0.8s cubic-bezier(0.4, 0, 0.2, 1) forwards';

        movingResult3.style.left = `${gScopeRect.left}px`;
        movingResult3.style.top = `${gScopeRect.top}px`;
        movingResult3.style.transform = 'scale(1)';
        await wait(800);

        // 步骤四: 结构简化与外层解析
        movingResult3.remove();
        fScope.innerHTML = `f(<span id="f-param" style="color: #16a34a; font-weight: bold; animation: fadeIn 0.5s ease-in-out forwards;">3</span>)`;
        gResultEl.style.opacity = '1';
        gScope.classList.remove('highlight-g');
        await wait(1500);

        await wait(500);

        fScope.classList.add('highlight-f');
        await wait(1000);

        const fScopeRect = fScope.getBoundingClientRect();
        const movingFScope = createMovingElement(fScope.innerText, fScope.className);
        movingFScope.style.left = `${fScopeRect.left}px`;
        movingFScope.style.top = `${fScopeRect.top}px`;
        movingFScope.style.fontSize = '3rem';
        fScope.style.opacity = '0';
        await wait(100);

        const lastStep = calcContent.lastChild;
        const secondStepTargetTop = lastStep.getBoundingClientRect().bottom + 30;
        movingFScope.style.left = `${calcAreaRect.left + calcAreaRect.width / 2 - movingFScope.offsetWidth / 2}px`;
        movingFScope.style.top = `${secondStepTargetTop}px`;
        movingFScope.style.transform = 'scale(0.8)';
        await wait(1000);

        // 求值 f(3)
        movingFScope.remove();

        const fLine = document.createElement('div');
        fLine.style.cssText = 'display: flex; align-items: center; justify-content: center; gap: 1rem; flex-wrap: wrap;';
        calcContent.appendChild(fLine);

        addCalcStep('<span class="scope scope-f">f(3)</span>', fLine);
        await wait(1000);

        addCalcStep(`<div style="display: flex; align-items: center;"><span style="color: #9ca3af; font-size: 2rem; margin: 0 0.5rem;">=</span><span style="color: #dc2626;">3²</span></div>`, fLine);
        await wait(1000);

        const fResult = 9;
        addCalcStep(`<div style="display: flex; align-items: center;"><span style="color: #9ca3af; font-size: 2rem; margin: 0 0.5rem;">=</span><span style="color: #16a34a; font-weight: bold;">${fResult}</span></div>`, fLine);
        await wait(1000);

        // 最终结果展示
        const mainExprArea = container.querySelector('#main-expression-area');
        mainExprArea.style.animation = 'fadeOut 0.8s ease-in-out forwards';
        await wait(800);

        mainExprArea.innerHTML = `<span style="font-size: 5rem; font-weight: bold; color: #16a34a;">${fResult}</span>`;
        mainExprArea.style.animation = 'fadeIn 0.5s ease-in-out forwards';

        // 3秒后重新开始（如果还在当前页面）
        const restartTimeoutId = setTimeout(() => {
            if (compositeAnimationRunning && container.closest('.slide.active')) {
                runCompositeAnimation(container);
            }
        }, 3000);
        compositeAnimationTimeouts.push(restartTimeoutId);
    }

    // 清理复合函数动画的函数
    function cleanupCompositeAnimation() {
        compositeAnimationRunning = false;

        // 清理所有定时器
        compositeAnimationTimeouts.forEach(timeoutId => {
            clearTimeout(timeoutId);
        });
        compositeAnimationTimeouts = [];

        // 清理所有动态创建的元素
        compositeMovingElements.forEach(element => {
            if (element && element.parentNode) {
                element.parentNode.removeChild(element);
            }
        });
        compositeMovingElements = [];

        // 清理所有带有data-composite-element属性的元素
        const allCompositeElements = document.querySelectorAll('[data-composite-element="true"]');
        allCompositeElements.forEach(element => {
            if (element && element.parentNode) {
                element.parentNode.removeChild(element);
            }
        });
    }


        /**
     * 运行当前幻灯片的可视化
     * @param {number} slideIndex - 当前幻灯片的索引
     */
    function runVisualization(slideIndex) {
        // 清理复合函数动画
        cleanupCompositeAnimation();

        // 清理上一张幻灯片的动画和定时器
        const lastSlideIndex = (slideIndex === 0) ? totalSlides - 1 : slideIndex - 1;
        const lastSlide = slides[lastSlideIndex];
        if (lastSlide) {
            const visContainer = lastSlide.querySelector('.visualization');
            if (visContainer && typeof visContainer.cleanup === 'function') {
                visContainer.cleanup();
                delete visContainer.cleanup;
            }
        }

        if (currentAnimation && typeof currentAnimation.interrupt === 'function') {
            currentAnimation.interrupt();
            currentAnimation = null;
        }

        switch (slideIndex) {
            case 1: visualizeExponents('vis-exponents'); break;
            case 2: visualizeExponentRules1New('vis-exponent-rules-1'); break;
            case 3: visualizeExponentRules2New('vis-exponent-rules-2'); break;
            case 4: visualizeSpecialExponentsNew('vis-special-exponents'); break;
            case 5: visualizeFractionalExponents('vis-fractional-exponents'); break;
            case 6: visualizeLogHistory('vis-log-history'); break;
            case 7: visualizeLogDefinition('vis-log-definition'); break;
            case 8: visualizeLogOperations('vis-log-operations'); break;
            case 9: visualizeLogProperties('vis-log-properties'); break;
            case 10: visualizeCommonLogs('vis-common-logs'); break;

            case 11: visualizeVariables('vis-variables'); break;
            case 12: visualizeIntervals('vis-intervals'); break;
            case 13: visualizeFunctionMachine('vis-function-machine'); break;
            case 14: visualizeDomain('vis-domain'); break;
            case 15: visualizeRange('vis-range'); break;
            case 16: visualizePropertiesIntro('vis-properties-intro'); break;
            case 17: visualizeMonotonicityInc('vis-monotonicity-inc'); break;
            case 18: visualizeMonotonicityDec('vis-monotonicity-dec'); break;
            case 19: visualizeMonotonicityIntervals('vis-monotonicity-intervals'); break;
            case 20: visualizeParityIntro('vis-parity-intro'); break;
            case 21: visualizeEvenFunction('vis-even-function'); break;
            case 22: visualizeOddFunction('vis-odd-function'); break;
            case 23: visualizeInverseMachine('vis-inverse-machine'); break;
            case 24: visualizeInverseGraph('vis-inverse-graph'); break;
            case 25: visualizeElementaryIntro('vis-elementary-intro'); break;
            case 26: visualizeGalleryPower('vis-gallery-power'); break;
            case 27: visualizeGalleryExp('vis-gallery-exp'); break;
            case 28: visualizeGalleryLog('vis-gallery-log'); break;
            case 29: visualizeExpLogInverse('vis-exp-log-inverse'); break;
            case 30: /* iframe页面，无需可视化 */ null; break;
            case 31: /* iframe页面，无需可视化 */ null; break;
            case 32: visualizeCompositeMachine('vis-composite-machine'); break;

        }
    }

    // 浮动菜单功能
    document.addEventListener('DOMContentLoaded', function() {
        const menuToggle = document.getElementById('menu-toggle');
        const menuContent = document.getElementById('menu-content');
        
        if (menuToggle && menuContent) {
            menuToggle.addEventListener('click', function(e) {
                e.stopPropagation();
                menuToggle.classList.toggle('active');
                menuContent.classList.toggle('active');
            });
            
            // 点击页面其他地方关闭菜单
            document.addEventListener('click', function(e) {
                if (!menuToggle.contains(e.target) && !menuContent.contains(e.target)) {
                    menuToggle.classList.remove('active');
                    menuContent.classList.remove('active');
                }
            });
            
            // 防止菜单内容点击时关闭菜单
            menuContent.addEventListener('click', function(e) {
                e.stopPropagation();
            });
        }

        // 章节目录菜单功能
        const chapterToggle = document.getElementById('chapter-toggle');
        const chapterContent = document.getElementById('chapter-content');
        
        if (chapterToggle && chapterContent) {
            chapterToggle.addEventListener('click', function(e) {
                e.stopPropagation();
                chapterToggle.classList.toggle('active');
                chapterContent.classList.toggle('active');
            });
            
            // 点击页面其他地方关闭菜单
            document.addEventListener('click', function(e) {
                if (!chapterToggle.contains(e.target) && !chapterContent.contains(e.target)) {
                    chapterToggle.classList.remove('active');
                    chapterContent.classList.remove('active');
                }
            });
            
            // 防止菜单内容点击时关闭菜单
            chapterContent.addEventListener('click', function(e) {
                e.stopPropagation();
            });
        }
    });

    // 章节目录菜单切换函数
    function toggleChapterMenu() {
        const chapterToggle = document.getElementById('chapter-toggle');
        const chapterContent = document.getElementById('chapter-content');
        
        if (chapterToggle && chapterContent) {
            chapterToggle.classList.toggle('active');
            chapterContent.classList.toggle('active');
        }
    }
</script>

<!-- 翻页器组件 -->

<!-- 浮动菜单按钮 -->
<div id="floating-menu">
    <div id="menu-toggle" class="menu-toggle">
        <span class="menu-icon">☰</span>
    </div>
    <div id="menu-content" class="menu-content">
        <a href="../网页资源/lab 
1-1.html" target="_blank" class="menu-item">
            <span class="menu-icon">LAB</span>
            <span class="menu-text">指数运算实验室</span>
        </a>
        <a href="../网页资源/lab 
1-2.html" target="_blank" class="menu-item">
            <span class="menu-icon">LAB</span>
            <span class="menu-text">对数运算实验室</span>
        </a>
        <a href="../网页资源/lab 
1-3.html" target="_blank" class="menu-item">
            <span class="menu-icon">LAB</span>
            <span class="menu-text">区间分类实验室</span>
        </a>
        <a href="../网页资源/lab 
1-4.html" target="_blank" class="menu-item">
            <span class="menu-icon">LAB</span>
            <span class="menu-text">函数概念实验室</span>
        </a>
        <a href="../网页资源/lab 
1-5.html" target="_blank" class="menu-item">
            <span class="menu-icon">LAB</span>
            <span class="menu-text">函数性质实验室</span>
        </a>
        <a href="../网页资源/lab 
1-6.html" target="_blank" class="menu-item">
            <span class="menu-icon">LAB</span>
            <span class="menu-text">基本初等函数实验室</span>
        </a>
        <a href="../网页资源/lab 
1-7.html" target="_blank" class="menu-item">
            <span class="menu-icon">LAB</span>
            <span class="menu-text">复合函数实验室</span>
        </a>
        <a href="../网页资源/lab 1-8.html" target="_blank" class="menu-item">
            <span class="menu-icon">GAME</span>
            <span class="menu-text">函数的运动</span>
        </a>
        <a href="../网页资源/lab 1-9.html" target="_blank" class="menu-item">
            <span class="menu-icon">GAME</span>
            <span class="menu-text">第一章游戏实验室</span>
        </a>
        <a href="../习题/assets/function.html" target="_blank" class="menu-item">
            <span class="menu-icon">EXER</span>
            <span class="menu-text">习题练习</span>
        </a>
    </div>
</div>

<!-- 章节目录菜单 -->
<div id="chapter-menu">
    <div id="chapter-toggle" class="menu-toggle">
        <span class="menu-icon">📚</span>
    </div>
    <div id="chapter-content" class="menu-content">
        <a href="#" class="menu-item" onclick="goToSlide(0); toggleChapterMenu();">
            <span class="menu-icon">🏠</span>
            <span class="menu-text">标题页</span>
        </a>
        <a href="#" class="menu-item" onclick="goToSlide(1); toggleChapterMenu();">
            <span class="menu-icon">📋</span>
            <span class="menu-text">目录</span>
        </a>
        <a href="#" class="menu-item" onclick="goToSlide(2); toggleChapterMenu();">
            <span class="menu-icon">1</span>
            <span class="menu-text">指数运算</span>
        </a>
        <a href="#" class="menu-item" onclick="goToSlide(8); toggleChapterMenu();">
            <span class="menu-icon">2</span>
            <span class="menu-text">对数运算</span>
        </a>
        <a href="#" class="menu-item" onclick="goToSlide(13); toggleChapterMenu();">
            <span class="menu-icon">3</span>
            <span class="menu-text">常量与变量</span>
        </a>
        <a href="#" class="menu-item" onclick="goToSlide(15); toggleChapterMenu();">
            <span class="menu-icon">4</span>
            <span class="menu-text">函数基础</span>
        </a>
    </div>
</div>

<script>
// ========== 延迟加载优化补丁 ==========
// 将此代码添加到文件末尾即可

(function() {
    // 保存原始的可视化函数
    const originalVisualizations = {
        visualizeExponents,
        visualizeExponentRules1New,
        visualizeExponentRules2New,
        visualizeSpecialExponentsNew,
        visualizeFractionalExponents,
        visualizeLogHistory,
        visualizeLogDefinition,
        visualizeLogOperations,
        visualizeLogProperties,
        visualizeCommonLogs,
        visualizeVariables,
        visualizeIntervals,
        visualizeFunctionMachine,
        visualizeDomain,
        visualizeRange,
        visualizePropertiesIntro,
        visualizeMonotonicityInc,
        visualizeMonotonicityDec,
        visualizeMonotonicityIntervals,
        visualizeParityIntro,
        visualizeEvenFunction,
        visualizeOddFunction,
        visualizeInverseMachine,
        visualizeInverseGraph,
        visualizeElementaryIntro,
        visualizeGalleryPower,
        visualizeGalleryExp,
        visualizeGalleryLog,
        visualizeCompositeMachine
    };

    // 创建延迟包装函数
    const lazyVisualizations = {};
    let currentRunningVisualization = null;

    // 包装每个函数为延迟执行版本
    Object.keys(originalVisualizations).forEach(funcName => {
        lazyVisualizations[funcName] = function(containerId) {
            // 停止之前的可视化
            if (currentRunningVisualization) {
                try {
                    const container = document.getElementById(currentRunningVisualization);
                    if (container && container.cleanup) {
                        container.cleanup();
                    }
                } catch(e) {
                    console.log('清理失败:', e);
                }
            }

            // 记录当前运行的可视化
            currentRunningVisualization = containerId;

            // 延迟执行原始函数
            return new Promise((resolve) => {
                requestAnimationFrame(() => {
                    try {
                        originalVisualizations[funcName](containerId);
                        resolve();
                    } catch(e) {
                        console.error(`可视化 ${funcName} 执行失败:`, e);
                        resolve();
                    }
                });
            });
        };
    });

    // 替换全局函数
    Object.assign(window, lazyVisualizations);

    // 重写 runVisualization 函数
    const originalRunVisualization = window.runVisualization;
    
    window.runVisualization = function(slideIndex) {
        // 清理之前的动画
        if (typeof stopAllAnimations === 'function') {
            stopAllAnimations();
        }

        // 检查当前页面是否还是活跃状态
        const currentSlideElement = slides[slideIndex];
        if (!currentSlideElement || !currentSlideElement.classList.contains('active')) {
            return;
        }

        // 延迟执行可视化
        setTimeout(() => {
            // 再次检查是否还在当前页
            if (currentSlide === slideIndex) {
                try {
                    // 调用原始的 runVisualization
                    switch (slideIndex) {
                        case 3: visualizeExponents('vis-exponents'); break;
                        case 4: visualizeExponentRules1New('vis-exponent-rules-1'); break;
                        case 5: visualizeExponentRules2New('vis-exponent-rules-2'); break;
                        case 6: visualizeSpecialExponentsNew('vis-special-exponents'); break;
                        case 7: visualizeFractionalExponents('vis-fractional-exponents'); break;
                        case 8: visualizeLogHistory('vis-log-history'); break;
                        case 9: visualizeLogDefinition('vis-log-definition'); break;
                        case 10: visualizeLogOperations('vis-log-operations'); break;
                        case 11: visualizeLogProperties('vis-log-properties'); break;
                        case 12: visualizeCommonLogs('vis-common-logs'); break;
                        case 13: visualizeVariables('vis-variables'); break;
                        case 14: visualizeIntervals('vis-intervals'); break;
                        case 15: visualizeFunctionMachine('vis-function-machine'); break;
                        case 16: visualizeDomain('vis-domain'); break;
                        case 17: visualizeRange('vis-range'); break;
                        case 18: visualizePropertiesIntro('vis-properties-intro'); break;
                        case 19: visualizeMonotonicityInc('vis-monotonicity-inc'); break;
                        case 20: visualizeMonotonicityDec('vis-monotonicity-dec'); break;
                        case 21: visualizeMonotonicityIntervals('vis-monotonicity-intervals'); break;
                        case 22: visualizeParityIntro('vis-parity-intro'); break;
                        case 23: visualizeEvenFunction('vis-even-function'); break;
                        case 24: visualizeOddFunction('vis-odd-function'); break;
                        case 25: visualizeInverseMachine('vis-inverse-machine'); break;
                        case 26: visualizeInverseGraph('vis-inverse-graph'); break;
                        case 27: visualizeElementaryIntro('vis-elementary-intro'); break;
                        case 28: visualizeGalleryPower('vis-gallery-power'); break;
                        case 29: visualizeGalleryExp('vis-gallery-exp'); break;
                        case 30: visualizeGalleryLog('vis-gallery-log'); break;
                        case 34: 
                            // 特殊处理复合函数页面
                            cleanupCompositeAnimation();
                            setTimeout(() => {
                                if (currentSlide === 34) {
                                    visualizeCompositeMachine('vis-composite-machine');
                                }
                            }, 300);
                            break;
                    }
                } catch(e) {
                    console.error('可视化执行错误:', e);
                }
            }
        }, 200); // 延迟200ms确保DOM准备好
    };

    // 添加全局停止动画函数
    if (!window.stopAllAnimations) {
        window.stopAllAnimations = function() {
            // 停止所有 requestAnimationFrame
            if (window.activeAnimations) {
                window.activeAnimations.forEach(id => cancelAnimationFrame(id));
                window.activeAnimations = [];
            }

            // 停止所有D3动画
            if (typeof d3 !== 'undefined') {
                d3.selectAll('*').interrupt();
            }

            // 停止所有CSS动画
            document.querySelectorAll('.slide:not(.active) *').forEach(el => {
                if (el.style) {
                    el.style.animationPlayState = 'paused';
                }
            });

            // 清理复合函数动画
            if (typeof cleanupCompositeAnimation === 'function') {
                cleanupCompositeAnimation();
            }

            // 清理定时器
            if (window.compositeAnimationTimeouts) {
                window.compositeAnimationTimeouts.forEach(id => clearTimeout(id));
                window.compositeAnimationTimeouts = [];
            }
        };
    }

    // 优化 showSlide 函数
    const originalShowSlide = window.showSlide;
    window.showSlide = function(index) {
        // 停止所有动画
        stopAllAnimations();
        
        // 清理当前页面
        if (currentSlide >= 0 && currentSlide < slides.length) {
            const currentVis = slides[currentSlide].querySelector('.visualization');
            if (currentVis && currentVis.cleanup) {
                currentVis.cleanup();
            }
        }

        // 调用原始函数
        originalShowSlide.call(this, index);
    };

    // 监听页面可见性变化
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            stopAllAnimations();
        }
    });

    // 监听页面切换，提前停止动画
    let isTransitioning = false;
    const transitionStart = () => {
        if (!isTransitioning) {
            isTransitioning = true;
            stopAllAnimations();
            setTimeout(() => { isTransitioning = false; }, 500);
        }
    };

    // 绑定所有可能触发页面切换的事件
    document.addEventListener('keydown', function(e) {
        if (e.key === 'ArrowRight' || e.key === 'ArrowLeft' || 
            e.key === 'PageUp' || e.key === 'PageDown') {
            transitionStart();
        }
    });

    document.addEventListener('wheel', transitionStart, { passive: true });

    console.log('延迟加载优化已启用');
})();

// ========== 性能监控（可选） ==========
(function() {
    let lastTime = performance.now();
    let frames = 0;
    
    function measureFPS() {
        frames++;
        const currentTime = performance.now();
        
        if (currentTime >= lastTime + 1000) {
            const fps = Math.round(frames * 1000 / (currentTime - lastTime));
            if (fps < 30) {
                console.warn(`低帧率警告: ${fps} FPS`);
            }
            frames = 0;
            lastTime = currentTime;
        }
        
        requestAnimationFrame(measureFPS);
    }
    
    // 启动FPS监控
    // measureFPS(); // 如果需要监控性能，取消注释
})();
</script>

<style>
/* 添加性能优化CSS */
.slide:not(.active) {
    opacity: 0 !important;
    visibility: hidden !important;
    pointer-events: none !important;
    /* 保持display: flex，让iframe可以正常加载 */
}

.slide:not(.active) * {
    animation-play-state: paused !important;
    transition: none !important;
}

/* GPU加速 */
.slide.active .visualization {
    will-change: transform;
    transform: translateZ(0);
}

/* 减少重绘 */
.visualization svg {
    backface-visibility: hidden;
    -webkit-backface-visibility: hidden;
}
</style>

<script>
// ========== 复合函数页面专门修复 ==========
// 替换原有的 visualizeCompositeMachine 函数

// 全局变量管理
window.compositeAnimationState = {
    running: false,
    timeouts: [],
    elements: [],
    currentContainer: null
};

// 清理函数（更彻底）
function cleanupCompositeAnimation() {
    const state = window.compositeAnimationState;
    
    // 停止运行标志
    state.running = false;
    
    // 清理所有定时器
    state.timeouts.forEach(id => clearTimeout(id));
    state.timeouts = [];
    
    // 清理所有动态创建的元素
    state.elements.forEach(el => {
        if (el && el.parentNode) {
            el.parentNode.removeChild(el);
        }
    });
    state.elements = [];
    
    // 清理所有带标记的元素
    document.querySelectorAll('[data-composite-element="true"]').forEach(el => {
        if (el && el.parentNode) {
            el.parentNode.removeChild(el);
        }
    });
    
    // 清理容器内容
    if (state.currentContainer) {
        const container = document.getElementById(state.currentContainer);
        if (container) {
            // 重置为初始状态而不是清空
            container.innerHTML = '';
            container.style.cssText = '';
        }
    }
}

// 新的可视化函数
function visualizeCompositeMachine(containerId) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    // 先彻底清理
    cleanupCompositeAnimation();
    
    // 保存容器引用
    window.compositeAnimationState.currentContainer = containerId;
    window.compositeAnimationState.running = true;
    
    // 重新初始化容器
    container.innerHTML = '';
    container.style.cssText = `
        font-family: 'JetBrains Mono', 'Noto Sans TC', monospace;
        background-color: #f8fafc;
        color: #1f2937;
        background-image:
            linear-gradient(rgba(0,0,0,0.04) 1px, transparent 1px),
            linear-gradient(90deg, rgba(0,0,0,0.04) 1px, transparent 1px);
        background-size: 20px 20px;
        height: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 2rem;
        opacity: 0;
        transition: opacity 0.3s ease-in;
    `;
    
    // 渐入效果
    setTimeout(() => {
        container.style.opacity = '1';
    }, 50);
    
    // 创建HTML结构
    const htmlContent = `
        <div id="problem-definition" style="width: 100%; max-width: 32rem; text-align: center; margin-bottom: 2rem; padding-top: 2rem;">
            <div style="font-size: 1.25rem; background: #f3f4f6; padding: 1rem; border-radius: 0.5rem; display: inline-block; border: 1px solid #d1d5db;">
                <span style="margin-right: 1rem;">令: <span style="color: #dc2626;">f(x) = x²</span></span>
                <span style="margin-right: 1rem;">且: <span style="color: #2563eb;">g(x) = x + 1</span></span>
                <span>解析: <span style="color: #d97706;">f(g(2))</span></span>
            </div>
        </div>
        <div id="main-expression-area" style="width: 100%; flex-grow: 1; display: flex; align-items: center; justify-content: center; font-size: 3rem; margin: 2rem 0;">
            <span id="f-scope" class="scope scope-f">
                f(<span id="g-scope" class="scope scope-g">
                    g(<span id="g-param">2</span>)
                </span>)
            </span>
        </div>
        <div id="calculation-area" style="width: 100%; display: flex; justify-content: center; margin-top: auto;">
            <div style="border: 2px dashed #9ca3af; border-radius: 0.5rem; padding: 2rem; min-width: 320px;">
                <h2 style="font-size: 1.5rem; color: #6b7280; margin-bottom: 1rem; text-align: center;">演算区</h2>
                <div id="calc-content" style="font-size: 2.5rem; display: flex; flex-direction: column; align-items: center; gap: 0.75rem;"></div>
            </div>
        </div>
    `;
    
    container.innerHTML = htmlContent;
    
    // 存储清理函数
    container.cleanup = cleanupCompositeAnimation;
    
    // 延迟启动动画，确保DOM完全准备好
    const startTimeout = setTimeout(() => {
        if (window.compositeAnimationState.running && 
            container.closest('.slide.active')) {
            startCompositeAnimation(container);
        }
    }, 500);
    
    window.compositeAnimationState.timeouts.push(startTimeout);
}

// 动画主函数（简化版）
function startCompositeAnimation(container) {
    const state = window.compositeAnimationState;
    if (!state.running) return;
    
    const fScope = container.querySelector('#f-scope');
    const gScope = container.querySelector('#g-scope');
    const calcContent = container.querySelector('#calc-content');
    
    if (!fScope || !gScope || !calcContent) return;
    
    // 重置内容
    calcContent.innerHTML = '';
    
    // 简化的动画序列
    animateStep1();
    
    function animateStep1() {
        if (!state.running) return;
        
        // 步骤1：高亮内层函数
        gScope.style.boxShadow = '0 0 20px rgba(37, 99, 235, 0.4)';
        
        const timeout1 = setTimeout(() => {
            if (!state.running) return;
            
            // 显示 g(2) = 2 + 1 = 3
            const step1 = document.createElement('div');
            step1.innerHTML = '<span style="color: #2563eb;">g(2) = 2 + 1 = 3</span>';
            step1.style.opacity = '0';
            calcContent.appendChild(step1);
            
            setTimeout(() => {
                step1.style.opacity = '1';
                step1.style.transition = 'opacity 0.5s';
            }, 50);
            
            animateStep2();
        }, 1000);
        
        state.timeouts.push(timeout1);
    }
    
    function animateStep2() {
        if (!state.running) return;
        
        const timeout2 = setTimeout(() => {
            if (!state.running) return;
            
            // 更新主表达式
            gScope.innerHTML = '3';
            gScope.style.color = '#16a34a';
            gScope.style.fontWeight = 'bold';
            gScope.style.boxShadow = 'none';
            
            // 步骤2：高亮外层函数
            fScope.style.boxShadow = '0 0 20px rgba(220, 38, 38, 0.4)';
            
            animateStep3();
        }, 1500);
        
        state.timeouts.push(timeout2);
    }
    
    function animateStep3() {
        if (!state.running) return;
        
        const timeout3 = setTimeout(() => {
            if (!state.running) return;
            
            // 显示 f(3) = 3² = 9
            const step2 = document.createElement('div');
            step2.innerHTML = '<span style="color: #dc2626;">f(3) = 3² = 9</span>';
            step2.style.opacity = '0';
            calcContent.appendChild(step2);
            
            setTimeout(() => {
                step2.style.opacity = '1';
                step2.style.transition = 'opacity 0.5s';
            }, 50);
            
            animateStep4();
        }, 1500);
        
        state.timeouts.push(timeout3);
    }
    
    function animateStep4() {
        if (!state.running) return;
        
        const timeout4 = setTimeout(() => {
            if (!state.running) return;
            
            // 显示最终答案
            const mainArea = container.querySelector('#main-expression-area');
            if (mainArea) {
                mainArea.style.transition = 'opacity 0.5s';
                mainArea.style.opacity = '0';
                
                setTimeout(() => {
                    if (!state.running) return;
                    mainArea.innerHTML = '<span style="font-size: 5rem; font-weight: bold; color: #16a34a;">9</span>';
                    mainArea.style.opacity = '1';
                }, 500);
            }
            
            // 3秒后重新开始
            const restartTimeout = setTimeout(() => {
                if (state.running && container.closest('.slide.active')) {
                    // 重新初始化
                    visualizeCompositeMachine(state.currentContainer);
                }
            }, 3000);
            
            state.timeouts.push(restartTimeout);
        }, 1500);
        
        state.timeouts.push(timeout4);
    }
}

// 修改 runVisualization 函数中的第34页处理
const originalRunVis = window.runVisualization;
window.runVisualization = function(slideIndex) {
    // 特殊处理复合函数页面
    if (slideIndex === 34) {
        // 确保完全清理
        cleanupCompositeAnimation();
        
        // 延迟初始化，确保DOM稳定
        setTimeout(() => {
            const slide = document.querySelector('.slide.active');
            if (slide && slide === slides[34]) {
                visualizeCompositeMachine('vis-composite-machine');
            }
        }, 300);
        
        return;
    }
    
    // 其他页面调用原函数
    if (originalRunVis) {
        originalRunVis(slideIndex);
    }
};

// 监听页面切换，确保离开第34页时清理
const originalShowSlide = window.showSlide;
window.showSlide = function(index) {
    // 如果离开第34页，清理动画
    if (currentSlide === 34 && index !== 34) {
        cleanupCompositeAnimation();
    }
    
    // 调用原函数
    if (originalShowSlide) {
        originalShowSlide.call(this, index);
    }
};

console.log('复合函数页面修复已应用');
</script>

</body>
</html>




