<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>第一章：函数基础 (滚动叙事版)</title>
    <script src="../common-assets/js/d3-7.8.5.min.js"></script>
    <script src="../common-assets/js/mathjax-config.js"></script>
    <script type="text/javascript" id="MathJax-script" async src="../common-assets/js/mathjax-3.2.2-tex-svg.min.js">
    </script>

        <style>
        @import url('../common-assets/css/fonts.css');

        :root {
            --chalkboard-bg: #2c3e50;
            --chalk-text: #ecf0f1;
            --visualization-bg: #ffffff;
            --primary-color: #3498db;
            --accent-color: #e67e22;
            --success-color: #2ecc71;
            --danger-color: #e74c3c;
            --warning-color: #f39c12;
            --info-color: #9b59b6;
            --text-color: #34495e;
            --heading-font: 'Noto Serif SC', serif;
            --handwriting-font: 'Noto Serif SC', serif;
        }

        body {
            font-family: var(--heading-font);
            margin: 0;
            background-color: #f0f2f5;
        }
        
        .return-home-panel {
            position: fixed;
            top: 16px;
            left: 16px;
            z-index: 1001; /* Ensure it's above fullscreen steps */
        }
        
        .return-home-panel .return-link {
            padding: 8px 14px;
            border-radius: 999px;
            background: rgba(15, 23, 42, 0.8);
            color: #f8fafc;
            text-decoration: none;
            backdrop-filter: blur(8px);
        }

        .scrolly-container {
            display: flex;
            width: 100%;
        }

        .lecture-notes {
            flex: 0 0 40%;
            max-width: 40%;
            word-wrap: break-word;
        }

        .step {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            padding: 40px;
            background-color: var(--chalkboard-bg);
            background-image: url('../common-assets/images/black-felt.png');
            border-bottom: 1px solid #444;
            color: var(--chalk-text);
            box-sizing: border-box;
            opacity: 0.3;
            transition: opacity 0.5s;
        }

        .step.is-active {
            opacity: 1;
        }
        
        .step:last-child {
            border-bottom: none;
        }

        .step h2, .step h3, .step p, .step li, .step .math-formula {
            max-width: 800px; /* Prevent text from being too wide */
            margin-left: auto;
            margin-right: auto;
            width: 90%;
        }

        .step h2 {
            font-family: var(--handwriting-font);
            font-size: 2.2rem;
            color: #f1c40f;
            border-bottom: 2px solid rgba(241, 196, 15, 0.5);
        }

        .step h3 {
            font-family: var(--handwriting-font);
            font-size: 1.5rem;
            color: var(--primary-color);
        }

        .step p, .step li {
            font-size: 1.1rem;
            line-height: 1.7;
        }
        
        .step ul {
            list-style-type: '→ ';
        }

        .math-formula {
            font-size: 1.3rem;
            color: #1abc9c;
            background: rgba(0,0,0,0.2);
            padding: 15px;
            border-radius: 5px;
            text-align: center;
            margin-top: 15px;
            margin-bottom: 15px;
        }

        .highlight {
            color: var(--warning-color);
            font-weight: bold;
        }

        .visualization-panel {
            flex: 1;
            position: relative;
        }

        #sticky-vis-container {
            position: sticky;
            top: 0;
            width: 100%;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: var(--visualization-bg);
        }

        /* --- FIX FOR FULLSCREEN --- */
        .step.fullscreen {
            padding: 0;
            border: none;
            /* It's a normal step when not active */
        }

        .step.fullscreen.is-active {
            position: fixed; /* Take it out of the document flow */
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 100; /* Place it on top of other content */
            opacity: 1;
        }

        .step.fullscreen .fullscreen-vis-container {
            width: 100%;
            height: 100%;
            background-color: var(--visualization-bg);
        }
        
        .step.fullscreen[data-theme="dark"].is-active .fullscreen-vis-container {
             background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
        }

    </style>
</head>
<body>
    <div class="return-home-panel">
        <a class="return-link" href="index.html">← 返回课件目录</a>
    </div>

    <div class="scrolly-container">
        <div class="lecture-notes">
            <section class="step" data-animation="intro">
                <h2 style="font-size: 4rem; border: none; text-align: center;">第一章</h2>
                <p style="font-size: 2.5rem; color: white; text-align: center;">代数与函数</p>
            </section>
            
            <section class="step" data-animation="toc">
                 <h2 style="text-align:center;">目录</h2>
                 <h3 style="color: #e74c3c;">第一节：集合与函数概念</h3>
                 <p>• 1.1 集合与区间</p>
                 <p>• 1.2 函数的概念 (定义、定义域、值域)</p>
                <h3 style="color: #3498db;">第二节：基本初等函数</h3>
                <p>• 2.1 幂函数 &amp; 指数运算</p>
                <p>• 2.2 指数函数 &amp; 2.3 对数函数</p>
                <p>• 2.4 三角函数与反三角函数</p>
            </section>

            <section class="step" data-animation="variables">
                <h2>集合、常量与变量</h2>
                <h3>集合</h3>
                <p>指具有某种<span class="highlight">特定性质</span>的、确定的、可以区分的事物的<span class="highlight">全体</span>。</p>
                <h3>常量</h3>
                <p>在问题研究过程中，<span class="highlight">取值始终保持不变</span>的量。 (e.g., $\pi, e$)</p>
                <h3>变量</h3>
                <p>在一定范围内，<span class="highlight">可以取不同数值</span>的量。 (e.g., 时间 $t$, 温度 $T$)</p>
            </section>

            <section class="step" data-animation="intervals">
                <h2>区间表示法</h2>
                <h3>闭区间 [a, b]</h3>
                <p>包括端点 $a$ 和 $b$。$a \le x \le b$</p>
                <h3>开区间 (a, b)</h3>
                <p>不包括端点 $a$ 和 $b$。$a < x < b$</p>
                <h3>半开半闭区间</h3>
                <p>$[a, b)$：包括 $a$，不包括 $b$。$a \le x < b$</p>
            </section>

            <section class="step" data-animation="function-machine">
                <h2>函数</h2>
                <p>函数是一种<span class="highlight">特殊的对应关系</span>，就像一个"加工机器"。</p>
                <p>对于每一个输入的数值 $x$，机器都能产出<span class="highlight">唯一确定</span>的输出数值 $y$。</p>
                <div class="math-formula"> $y = f(x)$ </div>
            </section>

            <section class="step" data-animation="domain">
                <h3>定义域</h3>
                <p>要让函数表达式有意义，$x$ 可以取哪些值？</p>
                <ul>
                    <li>分母不能为零: $f(x) = \frac{1}{x-2} \implies x \neq 2$</li>
                    <li>偶次根号下的数 $\ge 0$: $g(x) = \sqrt{x-3} \implies x \ge 3$</li>
                    <li>对数的真数 $> 0$</li>
                </ul>
            </section>

            <section class="step" data-animation="range">
                <h3>值域</h3>
                <p>当 $x$ 取遍定义域中的所有值时，对应的 $y$ 值组成了值域。</p>
                <ul>
                    <li>观察法：对于简单函数，直接观察图像</li>
                    <li>配方法：对于二次函数</li>
                </ul>
                <p>$f(x) = x^2$。值域是 $y \ge 0$</p>
                <p>$g(x) = \sin(x)$。值域是 $[-1, 1]$</p>
            </section>

            <section class="step fullscreen" data-animation="elementary-intro" data-theme="dark">
                <div id="vis-elementary-intro" class="fullscreen-vis-container"></div>
            </section>

            <section class="step fullscreen" data-animation="power-function" data-theme="light">
                <div id="vis-power-function" class="fullscreen-vis-container"></div>
            </section>
            
            <section class="step" data-animation="exponents">
                <h2>指数</h2>
                <p>指数表示一个数（底数）连续乘以自身多少次。</p>
                <div class="math-formula"> $a^n = \underbrace{a \times a \times \dots \times a}_{n \text{ 个}}$ </div>
                <p>$a$ 是 <span class="highlight">底数</span>，$n$ 是 <span class="highlight">指数</span>。</p>
            </section>

            <section class="step" data-animation="exponent-rules-1">
                <h3>乘法法则</h3>
                <div class="math-formula"> $a^m \cdot a^n = a^{m+n}$ </div>
                <p>同底数幂相乘，<span class="highlight">底数不变，指数相加</span>。</p>
                <h3>除法法则</h3>
                <div class="math-formula"> $\frac{a^m}{a^n} = a^{m-n}$ </div>
                <p>同底数幂相除，<span class="highlight">底数不变，指数相减</span>。</p>
            </section>

            <section class="step" data-animation="exponent-rules-2">
                <h3>幂的幂法则</h3>
                <div class="math-formula"> $(a^m)^n = a^{m \cdot n}$ </div>
                <p>幂的幂，<span class="highlight">底数不变，指数相乘</span>。</p>
                <h3>乘积的幂法则</h3>
                <div class="math-formula"> $(ab)^n = a^n \cdot b^n$ </div>
                <p>积的幂等于<span class="highlight">幂的积</span>。</p>
            </section>

            <section class="step" data-animation="special-exponents">
                <h3>零指数</h3>
                <div class="math-formula"> $a^0 = 1$ （$a \neq 0$）</div>
                <p>任何非零数的零次方都等于 <span class="highlight">1</span>。</p>
                <h3>负指数</h3>
                <div class="math-formula"> $a^{-n} = \frac{1}{a^n}$ </div>
                <p>负指数表示<span class="highlight">倒数</span>。</p>
            </section>

            <section class="step" data-animation="fractional-exponents">
                <h3>分数指数</h3>
                <p>分数指数是<span class="highlight">开方运算</span>的另一种写法。</p>
                <div class="math-formula"> $a^{\frac{1}{n}} = \sqrt[n]{a}$ </div>
                <p>• $27^{\frac{1}{3}} = \sqrt[3]{27} = 3$</p>
                <p>• $16^{\frac{1}{4}} = \sqrt[4]{16} = 2$</p>
            </section>

            <section class="step fullscreen" data-animation="interactive-exponential" data-theme="light">
                 <div id="vis-interactive-exponential" class="fullscreen-vis-container"></div>
            </section>
            
            <section class="step fullscreen" data-animation="log-history" data-theme="dark">
                 <div id="vis-log-history" class="fullscreen-vis-container"></div>
            </section>

            <section class="step" data-animation="log-definition">
                <h2>对数</h2>
                <p>对数是<strong>指数</strong>的逆运算。</p>
                <p>如果 $b^y = x$，那么 $\log_b(x) = y$</p>
                <p>对数 $y$ 回答了一个问题："底数 $b$ 需要自身相乘多少次才能得到 $x$？"</p>
            </section>
            
            <section class="step fullscreen" data-animation="interactive-logarithm" data-theme="light">
                <div id="vis-interactive-logarithm" class="fullscreen-vis-container"></div>
            </section>

            <section class="step" data-animation="log-properties">
                <h3>对数运算法则</h3>
                <p>$\log_b(xy) = \log_b(x) + \log_b(y)$</p>
                <p>$\log_b(\frac{x}{y}) = \log_b(x) - \log_b(y)$</p>
                <p>$\log_b(x^n) = n \cdot \log_b(x)$</p>
            </section>

            <section class="step" data-animation="common-logs">
                <h3>常用对数系统</h3>
                <h3 style="color: #e74c3c;">常用对数（lg）</h3>
                <p>以10为底的对数：$\lg(x) = \log_{10}(x)$</p>
                <h3 style="color: #27ae60;">自然对数（ln）</h3>
                <p>以$e$为底的对数：$\ln(x) = \log_e(x)$</p>
            </section>

            <section class="step" data-animation="log-operations" data-theme="light">
                <div id="vis-log-operations" class="fullscreen-vis-container"></div>
            </section>

            <section class="step" data-animation="interactive-trig">
                <h2>三角函数</h2>
                <h3>单位圆定义</h3>
                <p>在单位圆上，一个角 \(\theta\) 的终边与圆交于点 \(P(x, y)\)，则：</p>
                <ul>
                    <li>\(\sin(\theta) = y\) (正弦)</li>
                    <li>\(\cos(\theta) = x\) (余弦)</li>
                </ul>
            </section>

            <section class="step" data-animation="interactive-inv-trig">
                <h2>反三角函数</h2>
                <h3>定义</h3>
                <p>为了让三角函数有反函数，我们必须限制其定义域。</p>
                <ul>
                    <li>反正弦 (arcsin): 定义域 \([-1, 1]\), 值域 \([-\frac{\pi}{2}, \frac{\pi}{2}]\)</li>
                    <li>反余弦 (arccos): 定义域 \([-1, 1]\), 值域 \([0, \pi]\)</li>
                </ul>
            </section>

            <section class="step" data-animation="properties-intro">
                <h3>函数的基本性质</h3>
                <p>单调性、奇偶性、周期性、有界性</p>
            </section>

            <section class="step" data-animation="monotonicity-inc">
                <h3>单调递增</h3>
                <p>函数值 $y$ <span class="highlight">随着 $x$ 的增大而增大</span>。</p>
                <div class="math-formula">若 $x_1 < x_2$，则 $f(x_1) < f(x_2)$</div>
            </section>

            <section class="step" data-animation="monotonicity-dec">
                <h3>单调递减</h3>
                <p>函数值 $y$ <span class="highlight">随着 $x$ 的增大而减小</span>。</p>
                <div class="math-formula">若 $x_1 < x_2$，则 $f(x_1) > f(x_2)$</div>
            </section>

            <section class="step" data-animation="monotonicity-intervals">
                <h3>单调区间</h3>
                <p>$f(x) = x^2$</p>
                <ul>
                    <li>在 $(-\infty, 0]$ 上<span class="highlight">单调递减</span>。</li>
                    <li>在 $[0, +\infty)$ 上<span class="highlight">单调递增</span>。</li>
                </ul>
            </section>

            <section class="step" data-animation="parity-intro">
                <h3>奇偶性</h3>
                <p>函数的<span class="highlight">定义域必须关于原点对称</span>。</p>
                <ul>
                    <li><strong>偶函数</strong>：图像关于 Y 轴对称</li>
                    <li><strong>奇函数</strong>：图像关于原点对称</li>
                </ul>
            </section>

            <section class="step" data-animation="even-function">
                <h3>偶函数</h3>
                <div class="math-formula"> $f(-x) = f(x)$ </div>
                <p>图像关于 <span class="highlight">Y 轴对称</span>。</p>
            </section>

            <section class="step" data-animation="odd-function">
                <h3>奇函数</h3>
                <div class="math-formula"> $f(-x) = -f(x)$ </div>
                <p>图像关于 <span class="highlight">原点 (0,0) 对称</span>。</p>
            </section>

            <section class="step" data-animation="boundedness">
                <h3>有界性</h3>
                <p>函数图像被两条水平线"夹住"了。</p>
                <p>$y = \sin(x)$ 和 $y = \cos(x)$ 都是有界函数。</p>
            </section>

            <section class="step" data-animation="inverse-machine">
                <h3>反函数</h3>
                <p>如果函数 $f$ 把 $x$ 变成了 $y$，那么它的反函数 $f^{-1}$ 就是把 $y$ <span class="highlight">变回</span> $x$ 的操作。</p>
                <div class="math-formula">若 $y = f(x)$，则 $x = f^{-1}(y)$</div>
            </section>

            <section class="step" data-animation="inverse-graph">
                <h3>反函数与原函数</h3>
                <p>函数 $y=f(x)$ 和它的反函数 $y=f^{-1}(x)$ 的图像关于直线 <span class="highlight">$y=x$ 对称</span>。</p>
            </section>

            <section class="step fullscreen" data-animation="interactive-inverse-exp-log" data-theme="light">
                <div id="vis-interactive-inverse-exp-log" class="fullscreen-vis-container"></div>
            </section>

            <section class="step" data-animation="composite-machine">
                <h3>复合函数</h3>
                <p>如果 $u=g(x)$，而 $y=f(u)$，那么 $y=f(g(x))$ 就是一个复合函数。</p>
                <p>计算时，要<span class="highlight">由内向外</span>，层层计算。</p>
            </section>

        </div>

        <div class="visualization-panel">
            <div id="sticky-vis-container"></div>
        </div>
    </div>

<script>
    // === D3.js 辅助函数 ===
    function setupD3(containerId, margins = {top: 40, right: 40, bottom: 40, left: 40}) {
        const container = d3.select(`#${containerId}`);
        if (container.empty()) {
            console.error("Container not found:", containerId);
            return null;
        }
        container.html('');
        const bounds = container.node().getBoundingClientRect();
        if (bounds.width === 0 || bounds.height === 0) return null;
        const svg = container.append('svg').attr('width', bounds.width).attr('height', bounds.height);
        const width = bounds.width - margins.left - margins.right;
        const height = bounds.height - margins.top - margins.bottom;
        const g = svg.append('g').attr('transform', `translate(${margins.left}, ${margins.top})`);
        return { container, svg, g, width, height };
    }
    function drawAxes(g, xScale, yScale, width, height) {
        g.append('g').attr('transform', `translate(0, ${yScale(0)})`).call(d3.axisBottom(xScale));
        g.append('g').attr('transform', `translate(${xScale(0)}, 0)`).call(d3.axisLeft(yScale));
    }
    function animatePath(path) {
        if (!path.node()) return;
        const totalLength = path.node().getTotalLength();
        path.attr("stroke-dasharray", totalLength + " " + totalLength)
            .attr("stroke-dashoffset", totalLength)
            .transition().duration(2000).ease(d3.easeLinear).attr("stroke-dashoffset", 0);
    }

    // 保留后续的完整函数与滚动逻辑实现
    <div class="return-home-panel">
        <a class="return-link" href="index.html">← 返回课件目录</a>
    </div>

    <div class="scrolly-container">
        <div class="lecture-notes">
            <section class="step" data-animation="intro">
                <h2 style="font-size: 4rem; border: none; text-align: center;">第一章</h2>
                <p style="font-size: 2.5rem; color: white; text-align: center;">代数与函数</p>
            </section>
            
            <section class="step" data-animation="toc">
                 <h2 style="text-align:center;">目录</h2>
                 <h3 style="color: #e74c3c;">第一节：集合与函数概念</h3>
                 <p>• 1.1 集合与区间</p>
                 <p>• 1.2 函数的概念 (定义、定义域、值域)</p>
                 <h3 style="color: #3498db;">第二节：基本初等函数</h3>
                 <p>• 2.1 幂函数 &amp; 指数运算</p>
                 <p>• 2.2 指数函数 &amp; 2.3 对数函数</p>
                 <p>• 2.4 三角函数与反三角函数</p>
            </section>

            <section class="step" data-animation="variables">
                <h2>集合、常量与变量</h2>
                <h3>集合</h3>
                <p>指具有某种<span class="highlight">特定性质</span>的、确定的、可以区分的事物的<span class="highlight">全体</span>。</p>
                <h3>常量</h3>
                <p>在问题研究过程中，<span class="highlight">取值始终保持不变</span>的量。 (e.g., $\pi, e$)</p>
                <h3>变量</h3>
                <p>在一定范围内，<span class="highlight">可以取不同数值</span>的量。 (e.g., 时间 $t$, 温度 $T$)</p>
            </section>

            <section class="step" data-animation="intervals">
                <h2>区间表示法</h2>
                <h3>闭区间 [a, b]</h3>
                <p>包括端点 $a$ 和 $b$。$a \le x \le b$</p>
                <h3>开区间 (a, b)</h3>
                <p>不包括端点 $a$ 和 $b$。$a < x < b$</p>
                <h3>半开半闭区间</h3>
                <p>$[a, b)$：包括 $a$，不包括 $b$。$a \le x < b$</p>
            </section>

            <section class="step" data-animation="function-machine">
                <h2>函数</h2>
                <p>函数是一种<span class="highlight">特殊的对应关系</span>，就像一个"加工机器"。</p>
                <p>对于每一个输入的数值 $x$，机器都能产出<span class="highlight">唯一确定</span>的输出数值 $y$。</p>
                <div class="math-formula"> $y = f(x)$ </div>
            </section>

            <section class="step" data-animation="domain">
                <h3>定义域</h3>
                <p>要让函数表达式有意义，$x$ 可以取哪些值？</p>
                <ul>
                    <li>分母不能为零: $f(x) = \frac{1}{x-2} \implies x \neq 2$</li>
                    <li>偶次根号下的数 $\ge 0$: $g(x) = \sqrt{x-3} \implies x \ge 3$</li>
                    <li>对数的真数 $> 0$</li>
                </ul>
            </section>

            <section class="step" data-animation="range">
                <h3>值域</h3>
                <p>当 $x$ 取遍定义域中的所有值时，对应的 $y$ 值组成了值域。</p>
                <ul>
                    <li>观察法：对于简单函数，直接观察图像</li>
                    <li>配方法：对于二次函数</li>
                </ul>
                <p>$f(x) = x^2$。值域是 $y \ge 0$</p>
                <p>$g(x) = \sin(x)$。值域是 $[-1, 1]$</p>
            </section>

            <section class="step fullscreen" data-animation="elementary-intro" data-theme="dark">
                <div id="vis-elementary-intro" class="fullscreen-vis-container"></div>
            </section>

            <section class="step fullscreen" data-animation="power-function" data-theme="light">
                <div id="vis-power-function" class="fullscreen-vis-container"></div>
            </section>
            
            <section class="step" data-animation="exponents">
                <h2>指数</h2>
                <p>指数表示一个数（底数）连续乘以自身多少次。</p>
                <div class="math-formula"> $a^n = \underbrace{a \times a \times \dots \times a}_{n \text{ 个}}$ </div>
                <p>$a$ 是 <span class="highlight">底数</span>，$n$ 是 <span class="highlight">指数</span>。</p>
            </section>

            <section class="step" data-animation="exponent-rules-1">
                <h3>乘法法则</h3>
                <div class="math-formula"> $a^m \cdot a^n = a^{m+n}$ </div>
                <p>同底数幂相乘，<span class="highlight">底数不变，指数相加</span>。</p>
                <h3>除法法则</h3>
                <div class="math-formula"> $\frac{a^m}{a^n} = a^{m-n}$ </div>
                <p>同底数幂相除，<span class="highlight">底数不变，指数相减</span>。</p>
            </section>

            <section class="step" data-animation="exponent-rules-2">
                <h3>幂的幂法则</h3>
                <div class="math-formula"> $(a^m)^n = a^{m \cdot n}$ </div>
                <p>幂的幂，<span class="highlight">底数不变，指数相乘</span>。</p>
                <h3>乘积的幂法则</h3>
                <div class="math-formula"> $(ab)^n = a^n \cdot b^n$ </div>
                <p>积的幂等于<span class="highlight">幂的积</span>。</p>
            </section>

            <section class="step" data-animation="special-exponents">
                <h3>零指数</h3>
                <div class="math-formula"> $a^0 = 1$ （$a \neq 0$）</div>
                <p>任何非零数的零次方都等于 <span class="highlight">1</span>。</p>
                <h3>负指数</h3>
                <div class="math-formula"> $a^{-n} = \frac{1}{a^n}$ </div>
                <p>负指数表示<span class="highlight">倒数</span>。</p>
            </section>

            <section class="step" data-animation="fractional-exponents">
                <h3>分数指数</h3>
                <p>分数指数是<span class="highlight">开方运算</span>的另一种写法。</p>
                <div class="math-formula"> $a^{\frac{1}{n}} = \sqrt[n]{a}$ </div>
                <p>• $27^{\frac{1}{3}} = \sqrt[3]{27} = 3$</p>
                <p>• $16^{\frac{1}{4}} = \sqrt[4]{16} = 2$</p>
            </section>

            <section class="step fullscreen" data-animation="interactive-exponential" data-theme="light">
                 <div id="vis-interactive-exponential" class="fullscreen-vis-container"></div>
            </section>
            
            <section class="step fullscreen" data-animation="log-history" data-theme="dark">
                 <div id="vis-log-history" class="fullscreen-vis-container"></div>
            </section>

            <section class="step" data-animation="log-definition">
                <h2>对数</h2>
                <p>对数是<strong>指数</strong>的逆运算。</p>
                <p>如果 $b^y = x$，那么 $\log_b(x) = y$</p>
                <p>对数 $y$ 回答了一个问题："底数 $b$ 需要自身相乘多少次才能得到 $x$？"</p>
            </section>
            
            <section class="step fullscreen" data-animation="interactive-logarithm" data-theme="light">
                <div id="vis-interactive-logarithm" class="fullscreen-vis-container"></div>
            </section>

            <section class="step" data-animation="log-properties">
                <h3>对数运算法则</h3>
                <p>$\log_b(xy) = \log_b(x) + \log_b(y)$</p>
                <p>$\log_b(\frac{x}{y}) = \log_b(x) - \log_b(y)$</p>
                <p>$\log_b(x^n) = n \cdot \log_b(x)$</p>
            </section>

            <section class="step" data-animation="common-logs">
                <h3>常用对数系统</h3>
                <h3 style="color: #e74c3c;">常用对数（lg）</h3>
                <p>以10为底的对数：$\lg(x) = \log_{10}(x)$</p>
                <h3 style="color: #27ae60;">自然对数（ln）</h3>
                <p>以$e$为底的对数：$\ln(x) = \log_e(x)$</p>
            </section>

            <section class="step" data-animation="log-operations" data-theme="light">
                <div id="vis-log-operations" class="fullscreen-vis-container"></div>
            </section>

            <section class="step" data-animation="interactive-trig">
                <h2>三角函数</h2>
                <h3>单位圆定义</h3>
                <p>在单位圆上，一个角 \(\theta\) 的终边与圆交于点 \(P(x, y)\)，则：</p>
                <ul>
                    <li>\(\sin(\theta) = y\) (正弦)</li>
                    <li>\(\cos(\theta) = x\) (余弦)</li>
                </ul>
            </section>

            <section class="step" data-animation="interactive-inv-trig">
                <h2>反三角函数</h2>
                <h3>定义</h3>
                <p>为了让三角函数有反函数，我们必须限制其定义域。</p>
                <ul>
                    <li>反正弦 (arcsin): 定义域 \([-1, 1]\), 值域 \([-\frac{\pi}{2}, \frac{\pi}{2}]\)</li>
                    <li>反余弦 (arccos): 定义域 \([-1, 1]\), 值域 \([0, \pi]\)</li>
                </ul>
            </section>

            <section class="step" data-animation="properties-intro">
                <h3>函数的基本性质</h3>
                <p>单调性、奇偶性、周期性、有界性</p>
            </section>

            <section class="step" data-animation="monotonicity-inc">
                <h3>单调递增</h3>
                <p>函数值 $y$ <span class="highlight">随着 $x$ 的增大而增大</span>。</p>
                <div class="math-formula">若 $x_1 < x_2$，则 $f(x_1) < f(x_2)$</div>
            </section>

            <section class="step" data-animation="monotonicity-dec">
                <h3>单调递减</h3>
                <p>函数值 $y$ <span class="highlight">随着 $x$ 的增大而减小</span>。</p>
                <div class="math-formula">若 $x_1 < x_2$，则 $f(x_1) > f(x_2)$</div>
            </section>

            <section class="step" data-animation="monotonicity-intervals">
                <h3>单调区间</h3>
                <p>$f(x) = x^2$</p>
                <ul>
                    <li>在 $(-\infty, 0]$ 上<span class="highlight">单调递减</span>。</li>
                    <li>在 $[0, +\infty)$ 上<span class="highlight">单调递增</span>。</li>
                </ul>
            </section>

            <section class="step" data-animation="parity-intro">
                <h3>奇偶性</h3>
                <p>函数的<span class="highlight">定义域必须关于原点对称</span>。</p>
                <ul>
                    <li><strong>偶函数</strong>：图像关于 Y 轴对称</li>
                    <li><strong>奇函数</strong>：图像关于原点对称</li>
                </ul>
            </section>

            <section class="step" data-animation="even-function">
                <h3>偶函数</h3>
                <div class="math-formula"> $f(-x) = f(x)$ </div>
                <p>图像关于 <span class="highlight">Y 轴对称</span>。</p>
            </section>

            <section class="step" data-animation="odd-function">
                <h3>奇函数</h3>
                <div class="math-formula"> $f(-x) = -f(x)$ </div>
                <p>图像关于 <span class="highlight">原点 (0,0) 对称</span>。</p>
            </section>

            <section class="step" data-animation="boundedness">
                <h3>有界性</h3>
                <p>函数图像被两条水平线"夹住"了。</p>
                <p>$y = \sin(x)$ 和 $y = \cos(x)$ 都是有界函数。</p>
            </section>

            <section class="step" data-animation="inverse-machine">
                <h3>反函数</h3>
                <p>如果函数 $f$ 把 $x$ 变成了 $y$，那么它的反函数 $f^{-1}$ 就是把 $y$ <span class="highlight">变回</span> $x$ 的操作。</p>
                <div class="math-formula">若 $y = f(x)$，则 $x = f^{-1}(y)$</div>
            </section>

            <section class="step" data-animation="inverse-graph">
                <h3>反函数与原函数</h3>
                <p>函数 $y=f(x)$ 和它的反函数 $y=f^{-1}(x)$ 的图像关于直线 <span class="highlight">$y=x$ 对称</span>。</p>
            </section>

            <section class="step fullscreen" data-animation="interactive-inverse-exp-log" data-theme="light">
                <div id="vis-interactive-inverse-exp-log" class="fullscreen-vis-container"></div>
            </section>

            <section class="step" data-animation="composite-machine">
                <h3>复合函数</h3>
                <p>如果 $u=g(x)$，而 $y=f(u)$，那么 $y=f(g(x))$ 就是一个复合函数。</p>
                <p>计算时，要<span class="highlight">由内向外</span>，层层计算。</p>
            </section>

        </div>

        <div class="visualization-panel">
            <div id="sticky-vis-container"></div>
        </div>
    </div>

<script>
    // === D3.js 辅助函数 ===
    function setupD3(containerId, margins = {top: 40, right: 40, bottom: 40, left: 40}) {
        const container = d3.select(`#${containerId}`);
        if (container.empty()) {
            console.error("Container not found:", containerId);
            return null;
        }
        container.html('');
        const bounds = container.node().getBoundingClientRect();
        if (bounds.width === 0 || bounds.height === 0) return null;
        const svg = container.append('svg').attr('width', bounds.width).attr('height', bounds.height);
        const width = bounds.width - margins.left - margins.right;
        const height = bounds.height - margins.top - margins.bottom;
        const g = svg.append('g').attr('transform', `translate(${margins.left}, ${margins.top})`);
        return { container, svg, g, width, height };
    }
    function drawAxes(g, xScale, yScale, width, height) {
        g.append('g').attr('transform', `translate(0, ${yScale(0)})`).call(d3.axisBottom(xScale));
        g.append('g').attr('transform', `translate(${xScale(0)}, 0)`).call(d3.axisLeft(yScale));
    }
    function animatePath(path) {
        if (!path.node()) return;
        const totalLength = path.node().getTotalLength();
        path.attr("stroke-dasharray", totalLength + " " + totalLength)
            .attr("stroke-dashoffset", totalLength)
            .transition().duration(2000).ease(d3.easeLinear).attr("stroke-dashoffset", 0);
    }

    // === 所有可视化函数 ===
    // NOTE: These are copied from the original file. Some may need adjustments for the new layout.
    function visualizeIntro(containerId) {
        const setup = setupD3(containerId);
        if (!setup) return;
        setup.g.append("text").attr("x", setup.width/2).attr("y", setup.height/2).attr("text-anchor", "middle").style("font-size", "24px").text("滚动以开始");
    }
    function visualizeToc(containerId) {
        const setup = setupD3(containerId);
        if (!setup) return;
        setup.g.append("text").attr("x", setup.width/2).attr("y", setup.height/2).attr("text-anchor", "middle").style("font-size", "24px").text("课程内容概览");
    }
    function visualizeVariables(containerId) {
            const setup = setupD3(containerId);
            if (!setup) return;
            const { g, width, height } = setup;

            // 常量示例（π）
            g.append("circle")
                .attr("cx", width * 0.25)
                .attr("cy", height * 0.5)
                .attr("r", 10)
                .attr("fill", "var(--danger-color)");
            
            g.append("text")
                .attr("x", width * 0.25)
                .attr("y", height * 0.5 + 40)
                .text("常量 π")
                .attr("text-anchor", "middle")
                .attr("font-size", "1.2em");

            // 变量示例（动态移动的点）
            g.append("line")
                .attr("x1", width * 0.6)
                .attr("y1", height * 0.5)
                .attr("x2", width * 0.9)
                .attr("y2", height * 0.5)
                .attr("stroke", "#ccc")
                .attr("stroke-width", 2);
            
            const variablePoint = g.append("circle")
                .attr("cy", height * 0.5)
                .attr("r", 10)
                .attr("fill", "var(--primary-color)");
            
            g.append("text")
                .attr("x", width * 0.75)
                .attr("y", height * 0.5 + 40)
                .text("变量 x")
                .attr("text-anchor", "middle")
                .attr("font-size", "1.2em");

            function animate() {
                variablePoint.attr("cx", width * 0.6)
                    .transition().duration(2000).ease(d3.easeLinear)
                    .attr("cx", width * 0.9)
                    .transition().duration(2000).ease(d3.easeLinear)
                    .attr("cx", width * 0.6)
                    .on("end", animate);
            }
            animate();
    }
    function visualizeIntervals(containerId) {
            const setup = setupD3(containerId);
            if (!setup) return;
            const { g, width, height } = setup;
            
            const axisY = height * 0.2;

            // 闭区间
            g.append("line").attr("x1", 0).attr("y1", axisY).attr("x2", width).attr("y2", axisY).attr("stroke", "black");
            g.append("line").attr("x1", width*0.1).attr("y1", axisY).attr("x2", width*0.4).attr("y2", axisY).attr("stroke", "var(--success-color)").attr("stroke-width", 5);
            g.append("circle").attr("cx", width*0.1).attr("cy", axisY).attr("r", 5).attr("fill", "var(--success-color)");
            g.append("circle").attr("cx", width*0.4).attr("cy", axisY).attr("r", 5).attr("fill", "var(--success-color)");
            g.append("text").attr("x", width*0.25).attr("y", axisY + 40).text("闭区间 [a, b]").attr("text-anchor", "middle");

            // 开区间
            const axisY2 = height * 0.5;
            g.append("line").attr("x1", 0).attr("y1", axisY2).attr("x2", width).attr("y2", axisY2).attr("stroke", "black");
            g.append("line").attr("x1", width*0.1).attr("y1", axisY2).attr("x2", width*0.4).attr("y2", axisY2).attr("stroke", "var(--warning-color)").attr("stroke-width", 5);
            g.append("circle").attr("cx", width*0.1).attr("cy", axisY2).attr("r", 5).attr("fill", "white").attr("stroke", "var(--warning-color)").attr("stroke-width", 2);
            g.append("circle").attr("cx", width*0.4).attr("cy", axisY2).attr("r", 5).attr("fill", "white").attr("stroke", "var(--warning-color)").attr("stroke-width", 2);
            g.append("text").attr("x", width*0.25).attr("y", axisY2 + 40).text("开区间 (a, b)").attr("text-anchor", "middle");

            // 半开区间
            const axisY3 = height * 0.8;
            g.append("line").attr("x1", 0).attr("y1", axisY3).attr("x2", width).attr("y2", axisY3).attr("stroke", "black");
            g.append("line").attr("x1", width*0.1).attr("y1", axisY3).attr("x2", width*0.4).attr("y2", axisY3).attr("stroke", "var(--info-color)").attr("stroke-width", 5);
            g.append("circle").attr("cx", width*0.1).attr("cy", axisY3).attr("r", 5).attr("fill", "var(--info-color)");
            g.append("circle").attr("cx", width*0.4).attr("cy", axisY3).attr("r", 5).attr("fill", "white").attr("stroke", "var(--info-color)").attr("stroke-width", 2);
            g.append("text").attr("x", width*0.25).attr("y", axisY3 + 40).text("半开区间 [a, b)").attr("text-anchor", "middle");
    }
    function visualizeFunctionMachine(containerId) {
            const container = d3.select(`#${containerId}`);
            container.html("");
            const width = container.node().clientWidth;
            const height = container.node().clientHeight;
            
            const svg = container.append("svg")
                .attr("width", width)
                .attr("height", height);

            // 函数机器
            const machine = { x: width / 2, y: height / 2, width: 150, height: 100 };
            
            svg.append("rect")
                .attr("x", machine.x - machine.width / 2)
                .attr("y", machine.y - machine.height / 2)
                .attr("width", machine.width)
                .attr("height", machine.height)
                .attr("rx", 10)
                .attr("fill", "#4a90e2")
                .attr("stroke", "#357ABD")
                .attr("stroke-width", 3);

            svg.append("text")
                .text("f(x) = 2x + 1")
                .attr("x", machine.x)
                .attr("y", machine.y)
                .attr("text-anchor", "middle")
                .attr("dy", ".3em")
                .attr("fill", "white")
                .style("font-size", "18px")
                .style("font-weight", "bold");
            
            function animateNumber() {
                const input = Math.floor(Math.random() * 10) - 5;
                const output = 2 * input + 1;

                const inputText = svg.append("text")
                    .text(input)
                    .attr("x", machine.x - 100)
                    .attr("y", machine.y)
                    .attr("fill", "#333")
                    .style("font-size", "20px");

                inputText.transition()
                    .duration(1500)
                    .attr("x", machine.x)
                    .style("opacity", 0)
                    .remove();

                setTimeout(() => {
                    const outputText = svg.append("text")
                        .text(output)
                        .attr("x", machine.x + 100)
                        .attr("y", machine.y)
                        .attr("fill", "#2ecc71")
                        .style("font-size", "20px")
                        .style("opacity", 0);

                    outputText.transition()
                        .duration(500)
                        .style("opacity", 1)
                        .transition()
                        .delay(1000)
                        .duration(500)
                        .style("opacity", 0)
                        .remove();
                }, 1500);
            }
            
            animateNumber();
            setInterval(animateNumber, 3500);
    }
    function visualizeDomain(containerId) {
            const container = d3.select(`#${containerId}`);
            container.html("");
            const width = container.node().clientWidth;
            const height = container.node().clientHeight;
            const svg = container.append("svg").attr("width", width).attr("height", height);

            const machine = { x: width / 2, y: height / 2, width: 150, height: 100 };

            svg.append("rect").attr("x", machine.x - machine.width / 2).attr("y", machine.y - machine.height / 2).attr("width", machine.width).attr("height", machine.height).attr("rx", 10).attr("fill", "#4a90e2");
            svg.append("text").text("f(x) = √(x-2)").attr("x", machine.x).attr("y", machine.y).attr("text-anchor", "middle").attr("dy", ".3em").attr("fill", "white").style("font-size", "18px");

            function generateParticle() {
                const value = Math.floor(Math.random() * 12) - 1;
                const isValid = value >= 2;
                const particle = svg.append("text").text(value).attr("x", width * 0.2).attr("y", height * 0.2).attr("fill", isValid ? "#2ecc71" : "#e74c3c").style("font-size", "20px");
                particle.transition().duration(2000).attr("x", machine.x).attr("y", machine.y - machine.height/2 - 20).transition().duration(1000).style("opacity", 0).remove();
            }
            generateParticle();
            setInterval(generateParticle, 3000);
    }
    function visualizeRange(containerId) {
            const container = d3.select(`#${containerId}`);
            container.html("");
            const width = container.node().clientWidth;
            const height = container.node().clientHeight;
            const svg = container.append("svg").attr("width", width).attr("height", height);
            const machine = { x: width / 2, y: height / 2, width: 150, height: 100 };
            svg.append("rect").attr("x", machine.x - machine.width / 2).attr("y", machine.y - machine.height / 2).attr("width", machine.width).attr("height", machine.height).attr("rx", 10).attr("fill", "#4a90e2");
            svg.append("text").text("f(x) = x²").attr("x", machine.x).attr("y", machine.y).attr("text-anchor", "middle").attr("dy", ".3em").attr("fill", "white").style("font-size", "20px");

            function generateParticle() {
                const value = (Math.random() * 6) - 3;
                const outputValue = value * value;
                const particle = svg.append("text").text(value.toFixed(1)).attr("x", 50).attr("y", machine.y).style("font-size", "20px");
                particle.transition().duration(1500).attr("x", machine.x - machine.width/2 - 20).style("opacity", 0).remove().on("end", () => {
                    const outputParticle = svg.append("text").text(outputValue.toFixed(1)).attr("x", machine.x + machine.width/2 + 20).attr("y", machine.y).attr("fill", "#f5a623").style("font-size", "20px");
                    outputParticle.transition().duration(1500).attr("x", width - 50).style("opacity", 0).remove();
                });
            }
            generateParticle();
            setInterval(generateParticle, 3500);
    }
    function visualizeElementaryIntro(containerId) {
            const setup = setupD3(containerId, { top: 0, right: 0, bottom: 0, left: 0 });
            if (!setup) return;
            const { svg, g, width, height } = setup;
            svg.style('background', 'radial-gradient(ellipse at center, #1a1a2e 0%, #16213e 50%, #0f0f23 100%)');
            svg.append('text').attr('x', width / 2).attr('y', 60).attr('text-anchor', 'middle').attr('fill', 'white').style('font-size', '48px').text('基本初等函数星系');
            const planetsData = [
                { name: "幂函数", color: "#e74c3c", radius: 22, orbitRadius: 100, speed: 0.002 },
                { name: "指数函数", color: "#3498db", radius: 25, orbitRadius: 160, speed: 0.0015 },
                { name: "对数函数", color: "#2ecc71", radius: 25, orbitRadius: 220, speed: 0.0012 },
                { name: "三角函数", color: "#f1c40f", radius: 28, orbitRadius: 280, speed: 0.001 },
            ];
            const planets = g.selectAll(".planet").data(planetsData).enter().append("g").attr("class", "planet");
            planets.append("circle").attr("r", d => d.radius).attr("fill", d => d.color);
            planets.append("text").attr("dy", d => d.radius + 15).attr("text-anchor", "middle").attr("fill", "#fff").text(d => d.name);
            let angle = 0;
            function animate() {
                angle += 0.01;
                planets.attr("transform", d => `translate(${width/2 + d.orbitRadius * Math.cos(angle * d.speed * 100)}, ${height/2 + d.orbitRadius * Math.sin(angle * d.speed * 100)})`);
                requestAnimationFrame(animate);
            }
            animate();
    }
    function visualizePowerFunction(containerId) {
            const setup = setupD3(containerId, {top: 60, right: 40, bottom: 60, left: 50});
            if (!setup) return;
            const { container, svg, g, width, height } = setup;
            svg.append('text').attr('x', width / 2 + 50).attr('y', 30).attr('text-anchor', 'middle').style('font-size', '20px').text('幂函数 y = a^x');
            const xScale = d3.scaleLinear().domain([-4, 4]).range([0, width]);
            const yScale = d3.scaleLinear().domain([-1, 8]).range([height, 0]);
            drawAxes(g, xScale, yScale, width, height);
            const sliderContainer = container.append('div').style('position', 'absolute').style('bottom', '20px').style('left', '50%').style('transform', 'translateX(-50%)');
            sliderContainer.append('label').text('指数 a: ');
            const slider = sliderContainer.append('input').attr('type', 'range').attr('min', -2).attr('max', 4).attr('step', 0.1).attr('value', 2);
            const label = sliderContainer.append('span').text('2.0');
            const path = g.append("path").attr("fill", "none").attr("stroke-width", 3);
            function update(a) {
                label.text(a.toFixed(1));
                path.attr("stroke", a > 0 ? "var(--danger-color)" : "var(--success-color)");
                const line = d3.line().x(d => xScale(d)).y(d => yScale(Math.pow(d, a)));
                const data = d3.range(-4, 4.1, 0.1).filter(x => x > 0 || a % 1 === 0); // Handle negative base for integer exponents
                path.datum(data).attr("d", line);
            }
            update(2);
            slider.on('input', function() { update(+this.value); });
    }
    function visualizeExponents(containerId) {
            const setup = setupD3(containerId);
            if (!setup) return;
            const { g, width, height } = setup;
            const data = [{ x: 0, y: 1, label: "2^0" },{ x: 1, y: 2, label: "2^1" },{ x: 2, y: 4, label: "2^2" },{ x: 3, y: 8, label: "2^3" }];
            const xScale = d3.scaleLinear().domain([-1, 4]).range([0, width]);
            const yScale = d3.scaleLinear().domain([0, 10]).range([height, 0]);
            g.selectAll("rect").data(data).enter().append("rect").attr("x", d => xScale(d.x) - width/10).attr("y", height).attr("width", width/5).attr("height", 0).attr("fill", "var(--primary-color)").transition().duration(1000).delay((d, i) => i * 300).attr("y", d => yScale(d.y)).attr("height", d => height - yScale(d.y));
    }
    function visualizeExponentRules1(containerId) {
            const setup = setupD3(containerId);
            if (!setup) return;
            const { svg, g, width, height } = setup;
            const mulY = height * 0.25;
            const mulGroup = g.append("g");
            mulGroup.append("text").attr("x", width / 2).attr("y", mulY - 30).attr("text-anchor", "middle").attr("font-size", "1.8em").text("2³ × 2² = 2⁵");
            const circles1 = g.selectAll(".c1").data(d3.range(3)).enter().append("circle").attr("class", "c1").attr("cy", mulY).attr("cx", (d, i) => width * 0.2 + i * 40).attr("r", 15).attr("fill", "var(--primary-color)");
            const circles2 = g.selectAll(".c2").data(d3.range(2)).enter().append("circle").attr("class", "c2").attr("cy", mulY).attr("cx", (d, i) => width * 0.8 - i * 40).attr("r", 15).attr("fill", "var(--accent-color)");
            circles1.transition().delay(1000).duration(1500).attr("cx", (d, i) => width/2 - 100 + i * 40);
            circles2.transition().delay(1000).duration(1500).attr("cx", (d, i) => width/2 + 20 + i * 40);
    }
    function visualizeExponentRules2(containerId) {
            const setup = setupD3(containerId, {top: 0, right: 0, bottom: 0, left: 0});
            if (!setup) return;
            const { svg, g, width, height } = setup;
            g.append("text").attr("x", width/2).attr("y", 50).attr("text-anchor", "middle").attr("font-size", "2em").text("(2³)⁴ = 2¹²");
            const bigCircle = g.append("circle").attr("cx", width/2).attr("cy", height/2).attr("r", 0).attr("fill", "#74b9ff").transition().duration(1000).attr("r", 60);
    }
    function visualizeSpecialExponentsNew(containerId) {
            const setup = setupD3(containerId);
            if (!setup) return;
            const { svg, g, width, height } = setup;
            const sectionHeight = height / 2;
            const zeroGroup = g.append("g");
            const scaleGroup = zeroGroup.append("g").attr("transform", `translate(${width / 2}, ${sectionHeight * 0.6})`);
            scaleGroup.append("polygon").attr("points", "-10,0 10,0 0,15").attr("fill", "#555");
            scaleGroup.append("line").attr("x1", -100).attr("x2", 100).attr("stroke", "#555").attr("stroke-width", 4);
            const leftPan = scaleGroup.append("text").attr("x", -70).attr("y", -15).attr("font-size", "1.5em").attr("text-anchor", "middle").text("a³ ÷ a³");
            const rightPan = scaleGroup.append("text").attr("x", 70).attr("y", -15).attr("font-size", "1.5em").attr("text-anchor", "middle").text("1");
            setTimeout(() => { leftPan.html("a⁰").attr("fill", "var(--danger-color)"); }, 1000);
    }
    function visualizeFractionalExponents(containerId) {
            const setup = setupD3(containerId);
            if (!setup) return;
            const { svg, g, width, height } = setup;
            g.append("text").attr("x", width/2).attr("y", 50).attr("text-anchor", "middle").attr("font-size", "28px").html("分数指数: $a^{\\frac{m}{n}} = \\sqrt[n]{a^m}$");
            const examples = [{ base: 27, exp: "1/3", res: 3, color: "#e74c3c" },{ base: 16, exp: "1/2", res: 4, color: "#3498db" }];
            examples.forEach((ex, i) => {
                const cardGroup = g.append("g").attr("transform", `translate(${(width / 3) * (i + 1)}, ${height * 0.5})`);
                cardGroup.append("circle").attr("r", 80).attr("fill", ex.color).attr("fill-opacity", 0.15);
                cardGroup.append("text").attr("y", -20).attr("text-anchor", "middle").style("font-size", "20px").html(`${ex.base}<sup>${ex.exp}</sup>`);
                cardGroup.append("text").attr("y", 20).attr("text-anchor", "middle").style("font-size", "28px").text(`= ${ex.res}`);
            });
            if (window.MathJax && window.MathJax.typesetPromise) { window.MathJax.typesetPromise([g.node()]); }
    }
    function visualizeInteractiveExponential(containerId) {
            const setup = setupD3(containerId, {top: 60, right: 40, bottom: 60, left: 50});
            if (!setup) return;
            const { container, svg, g, width, height } = setup;
            svg.append('text').attr('x', width / 2 + 50).attr('y', 30).attr('text-anchor', 'middle').style('font-size', '20px').text('指数函数 y = a^x');
            const xScale = d3.scaleLinear().domain([-4, 4]).range([0, width]);
            const yScale = d3.scaleLinear().domain([-1, 8]).range([height, 0]);
            drawAxes(g, xScale, yScale, width, height);
            const sliderContainer = container.append('div').style('position', 'absolute').style('bottom', '20px').style('left', '50%').style('transform', 'translateX(-50%)').style('background', 'rgba(255,255,255,0.9)').style('padding','10px').style('border-radius','8px');
            sliderContainer.append('label').text('底数 a: ');
            const slider = sliderContainer.append('input').attr('type', 'range').attr('min', 0.2).attr('max', 4).attr('step', 0.1).attr('value', 2);
            const label = sliderContainer.append('span').text('2.0');
            const path = g.append("path").attr("fill", "none").attr("stroke-width", 3);
            function update(a) {
                label.text(a.toFixed(1));
                path.attr("stroke", a > 1 ? "var(--danger-color)" : "var(--success-color)");
                const line = d3.line().x(d => xScale(d)).y(d => yScale(Math.pow(a, d)));
                const data = d3.range(-4, 4.1, 0.1);
                path.datum(data).attr("d", line);
            }
            update(2);
            slider.on('input', function() { update(+this.value); });
    }
    function visualizeLogHistory(containerId) {
            const setup = setupD3(containerId, { top: 0, right: 0, bottom: 0, left: 0 });
            if (!setup) return;
            const { svg, g, width, height } = setup;
            svg.style('background', 'radial-gradient(ellipse at center, #1a1a2e 0%, #16213e 50%, #0f0f23 100%)');
            svg.append('text').attr('x', width / 2).attr('y', 60).attr('text-anchor', 'middle').attr('fill', 'white').style('font-size', '48px').text('对数的历史长河');
            const events = [{ year: 1614, desc: "纳皮尔发明对数", x: 0.2 },{ year: 1617, desc: "布里格斯制作常用对数表", x: 0.5 },{ year: 1622, desc: "计算尺发明", x: 0.8 }];
            const timeline = g.append("line").attr("x1", width * 0.1).attr("y1", height/2).attr("x2", width * 0.9).attr("y2", height/2).attr("stroke", "rgba(255, 255, 255, 0.5)").attr("stroke-width", 4);
            events.forEach((event, i) => {
                const eventGroup = g.append("g").attr("transform", `translate(${width * event.x}, ${height/2})`).style("opacity", 0);
                eventGroup.append("circle").attr("r", 10).attr("fill", "#f1c40f");
                eventGroup.append("text").attr("y", -20).attr("text-anchor", "middle").attr("fill", "white").text(event.year);
                eventGroup.append("text").attr("y", 30).attr("text-anchor", "middle").attr("fill", "white").text(event.desc);
                eventGroup.transition().delay(500 + i * 500).duration(500).style("opacity", 1);
            });
    }
    function visualizeLogDefinition(containerId) {
            const setup = setupD3(containerId);
            if (!setup) return;
            const { svg, g, width, height } = setup;
            svg.append("text").attr("x", width / 2).attr("y", 50).attr("text-anchor", "middle").style("font-size", "20px").text("求 log₂(8) = ?");
            svg.append("text").attr("x", width / 2).attr("y", 80).attr("text-anchor", "middle").text("也就是，2的几次方等于8？");
            const expGroup = svg.append("g");
            expGroup.append("text").attr("x", 50).attr("y", 150).text("指数过程:").style("font-weight", "bold");
            const expPath = expGroup.append("path").attr("d", "M 150 145 L 250 145 L 350 145 L 450 145").attr("stroke", "#3498db").attr("stroke-width", 2).attr("fill", "none");
            animatePath(expPath);
            [1, 2, 4, 8].forEach((val, i) => {
                const node = expGroup.append("g").attr("transform", `translate(${150 + i * 100}, 145)`).style("opacity", 0);
                node.append("circle").attr("r", 15).attr("fill", "#3498db");
                node.append("text").text(val).attr("y", 40).attr("text-anchor", "middle");
                node.transition().delay(1000 + i * 500).duration(500).style("opacity", 1);
            });
            svg.append("text").attr("x", width/2).attr("y", 300).attr("text-anchor", "middle").style("font-size", "24px").style("fill", "#e74c3c").text("log₂(8) = 3").style("opacity", 0).transition().delay(4000).duration(500).style("opacity", 1);
    }
    function visualizeInteractiveLogarithm(containerId) {
            const setup = setupD3(containerId, {top: 60, right: 40, bottom: 60, left: 50});
            if (!setup) return;
            const { container, svg, g, width, height } = setup;
            svg.append('text').attr('x', width / 2 + 50).attr('y', 30).attr('text-anchor', 'middle').style('font-size', '20px').text('对数函数 y = logₐ(x)');
            const xScale = d3.scaleLinear().domain([-1, 8]).range([0, width]);
            const yScale = d3.scaleLinear().domain([-4, 4]).range([height, 0]);
            drawAxes(g, xScale, yScale, width, height);
            const sliderContainer = container.append('div').style('position', 'absolute').style('bottom', '20px').style('left', '50%').style('transform', 'translateX(-50%)').style('background', 'rgba(255,255,255,0.9)').style('padding','10px').style('border-radius','8px');
            sliderContainer.append('label').text('底数 a: ');
            const slider = sliderContainer.append('input').attr('type', 'range').attr('min', 0.2).attr('max', 4).attr('step', 0.1).attr('value', 2);
            const label = sliderContainer.append('span').text('2.0');
            const path = g.append("path").attr("fill", "none").attr("stroke-width", 3);
            function update(a) {
                label.text(a.toFixed(1));
                path.attr("stroke", a > 1 ? "var(--danger-color)" : "var(--success-color)");
                const line = d3.line().x(d => xScale(d)).y(d => yScale(Math.log(d) / Math.log(a)));
                const data = d3.range(0.01, 8.1, 0.01);
                path.datum(data).attr("d", line);
            }
            update(2);
            slider.on('input', function() { update(+this.value); });
    }
    function visualizeLogProperties(containerId) {
            const setup = setupD3(containerId);
            if (!setup) return;
            const { svg, g, width, height } = setup;
            const properties = [{ title: "log(x·y) = log(x) + log(y)", y: height*0.2 },{ title: "log(x/y) = log(x) - log(y)", y: height*0.5 },{ title: "log(x^n) = n·log(x)", y: height*0.8 }];
            properties.forEach((prop, index) => {
                const propGroup = svg.append("g").attr("transform", `translate(${width/2}, ${prop.y})`);
                propGroup.append("text").attr("text-anchor", "middle").style("font-size", "18px").text(prop.title);
            });
    }
    function visualizeCommonLogs(containerId) {
            const setup = setupD3(containerId);
            if (!setup) return;
            const { svg, g, width, height } = setup;
            svg.append("text").attr("x", width / 2).attr("y", 40).attr("text-anchor", "middle").style("font-size", "18px").text("常用对数与自然对数");
            const lgGroup = svg.append("g").attr("transform", `translate(${width*0.25}, 80)`);
            lgGroup.append("text").text("常用对数 (lg)").style("fill", "#e74c3c");
            [{input: "10", output: "1"}, {input: "100", output: "2"}].forEach((ex, i) => {
                lgGroup.append("text").attr("y", 30 + i * 30).text(`lg(${ex.input}) = ${ex.output}`);
            });
            const lnGroup = svg.append("g").attr("transform", `translate(${width*0.75}, 80)`);
            lnGroup.append("text").text("自然对数 (ln)").style("fill", "#27ae60");
            [{input: "e", output: "1"}, {input: "e²", output: "2"}].forEach((ex, i) => {
                lnGroup.append("text").attr("y", 30 + i * 30).text(`ln(${ex.input}) = ${ex.output}`);
            });
    }
    function visualizeLogOperations(containerId) {
            const setup = setupD3(containerId);
            if (!setup) return;
            const { svg, g, width, height } = setup;
            g.append("text").attr("x", width/2).attr("y", height/2).attr("text-anchor", "middle").style("font-size", "24px").text("对数运算: 乘->加, 除->减");
    }
    function visualizeInteractiveTrig(containerId) {
            const container = d3.select(`#${containerId}`);
            if (container.empty()) return;
            container.html('');
            const width = container.node().clientWidth, height = container.node().clientHeight;
            const radius = Math.min(width, height) / 3;
            const svg = container.append('svg').attr('width', width).attr('height', height);
            const g = svg.append('g').attr('transform', `translate(${width / 2}, ${height / 2})`);
            const xScale = d3.scaleLinear().domain([-1.5, 1.5]).range([-radius * 1.5, radius * 1.5]);
            const yScale = d3.scaleLinear().domain([-1.5, 1.5]).range([radius * 1.5, -radius * 1.5]);
            g.append('g').call(d3.axisBottom(xScale));
            g.append('g').call(d3.axisLeft(yScale));
            g.append('circle').attr('r', radius).attr('fill', 'none').attr('stroke', '#888');
            const angleLine = g.append('line').attr('x1', 0).attr('y1', 0).attr('stroke', '#555');
            const sineLine = g.append('line').attr('stroke', 'var(--danger-color)').attr('stroke-width', 2.5);
            const cosineLine = g.append('line').attr('stroke', 'var(--primary-color)').attr('stroke-width', 2.5);
            const draggablePoint = g.append('circle').attr('r', 8).attr('fill', 'var(--accent-color)').style('cursor', 'pointer');
            function update(angle) {
                const x = radius * Math.cos(angle), y = -radius * Math.sin(angle);
                draggablePoint.attr('cx', x).attr('cy', y);
                angleLine.attr('x2', x).attr('y2', y);
                sineLine.attr('x1', x).attr('y1', y).attr('x2', x).attr('y2', 0);
                cosineLine.attr('x1', x).attr('y1', 0).attr('x2', 0).attr('y2', 0);
            }
            draggablePoint.call(d3.drag().on('drag', event => update(Math.atan2(-event.y, event.x))));
            update(-Math.PI / 4);
    }
    function visualizeInteractiveInvTrig(containerId) {
            const setup = setupD3(containerId, {top: 60, right: 40, bottom: 60, left: 60});
            if (!setup) return;
            const { container, svg, g, width, height } = setup;
            svg.append('text').attr('x', width / 2 + 30).attr('y', 30).attr('text-anchor', 'middle').style('font-size', '20px').text('Sine 与 Arcsine');
            const pi = Math.PI;
            const xScale = d3.scaleLinear().domain([-pi, pi]).range([0, width]);
            const yScale = d3.scaleLinear().domain([-1.6, 1.6]).range([height, 0]);
            g.append('g').attr('transform', `translate(0, ${yScale(0)})`).call(d3.axisBottom(xScale).tickValues([-pi, -pi/2, 0, pi/2, pi]).tickFormat(d => ({["-3.141592653589793"]: '−π',["-1.5707963267948966"]: '−π/2',["0"]: '0',["1.5707963267948966"]: 'π/2',["3.141592653589793"]: 'π'}[d])));
            g.append('g').call(d3.axisLeft(yScale).tickValues([-1, 0, 1]));
            const sineLine = d3.line().x(d => xScale(d)).y(d => yScale(Math.sin(d)));
            const data = d3.range(-pi, pi, 0.01);
            g.append("path").datum(data).attr("fill", "none").attr("stroke", "#ccc").attr("stroke-width", 2).attr("d", sineLine);
            const restrictedData = d3.range(-pi / 2, pi / 2 + 0.01, 0.01);
            g.append("path").datum(restrictedData).attr("fill", "none").attr("stroke", "var(--danger-color)").attr("stroke-width", 4).attr("d", sineLine);
    }
    function visualizePropertiesIntro(containerId) {
            const setup = setupD3(containerId);
            if (!setup) return;
            const { g, width, height } = setup;
            const properties = [{ name: "单调性", x: width * 0.25, y: height * 0.25, color: "#e74c3c" },{ name: "奇偶性", x: width * 0.75, y: height * 0.25, color: "#3498db" },{ name: "周期性", x: width * 0.25, y: height * 0.75, color: "#2ecc71" },{ name: "有界性", x: width * 0.75, y: height * 0.75, color: "#f39c12" }];
            properties.forEach((prop, i) => {
                const group = g.append("g").attr("transform", `translate(${prop.x}, ${prop.y})`).style("opacity", 0);
                group.append("circle").attr("r", 60).attr("fill", prop.color).attr("fill-opacity", 0.3);
                group.append("text").attr("text-anchor", "middle").attr("dy", "0.3em").style("font-size", "20px").text(prop.name);
                group.transition().delay(i * 300).duration(800).style("opacity", 1);
            });
    }
    function visualizeMonotonicityInc(containerId) {
            const setup = setupD3(containerId);
            if (!setup) return;
            const { g, width, height } = setup;
            const xScale = d3.scaleLinear().domain([-5, 5]).range([0, width]);
            const yScale = d3.scaleLinear().domain([-5, 5]).range([height, 0]);
            drawAxes(g, xScale, yScale, width, height);
            const line = d3.line().x(d => xScale(d)).y(d => yScale(d)).curve(d3.curveMonotoneX);
            const data = d3.range(-4, 4.1, 0.1);
            const path = g.append("path").datum(data).attr("d", line).attr("stroke", "#2ecc71").attr("stroke-width", 3).attr("fill", "none");
            animatePath(path);
            g.append("text").attr("x", xScale(3)).attr("y", yScale(3) - 20).text("↗").style("font-size", "30px").style("fill", "#2ecc71");
    }
    function visualizeMonotonicityDec(containerId) {
            const setup = setupD3(containerId);
            if (!setup) return;
            const { g, width, height } = setup;
            const xScale = d3.scaleLinear().domain([-5, 5]).range([0, width]);
            const yScale = d3.scaleLinear().domain([-5, 5]).range([height, 0]);
            drawAxes(g, xScale, yScale, width, height);
            const line = d3.line().x(d => xScale(d)).y(d => yScale(-d)).curve(d3.curveMonotoneX);
            const data = d3.range(-4, 4.1, 0.1);
            const path = g.append("path").datum(data).attr("d", line).attr("stroke", "#e74c3c").attr("stroke-width", 3).attr("fill", "none");
            animatePath(path);
            g.append("text").attr("x", xScale(3)).attr("y", yScale(-3) + 40).text("↘").style("font-size", "30px").style("fill", "#e74c3c");
    }
    function visualizeMonotonicityIntervals(containerId) {
            const setup = setupD3(containerId);
            if (!setup) return;
            const { g, width, height } = setup;
            const xScale = d3.scaleLinear().domain([-4, 4]).range([0, width]);
            const yScale = d3.scaleLinear().domain([-2, 10]).range([height, 0]);
            drawAxes(g, xScale, yScale, width, height);
            const data = d3.range(-3, 5, 0.1);
            const parabola = d3.line().x(d => xScale(d)).y(d => yScale(Math.pow(d - 1, 2)));
            const leftData = data.filter(d => d <= 1);
            const rightData = data.filter(d => d >= 1);
            g.append("path").datum(leftData).attr("d", parabola).attr("stroke", "#e74c3c").attr("stroke-width", 4).attr("fill", "none");
            g.append("path").datum(rightData).attr("d", parabola).attr("stroke", "#2ecc71").attr("stroke-width", 4).attr("fill", "none");
            g.append("circle").attr("cx", xScale(1)).attr("cy", yScale(0)).attr("r", 5).attr("fill", "#f39c12");
    }
    function visualizeParityIntro(containerId) {
            const setup = setupD3(containerId);
            if (!setup) return;
            const { g, width, height } = setup;
            const evenGroup = g.append("g").attr("transform", `translate(${width * 0.25}, ${height * 0.5})`);
            evenGroup.append("rect").attr("x", -80).attr("y", -80).attr("width", 160).attr("height", 160).attr("fill", "#3498db").attr("fill-opacity", 0.2);
            evenGroup.append("text").attr("text-anchor", "middle").text("偶函数 (Y轴对称)");
            const oddGroup = g.append("g").attr("transform", `translate(${width * 0.75}, ${height * 0.5})`);
            oddGroup.append("circle").attr("r", 80).attr("fill", "#e74c3c").attr("fill-opacity", 0.2);
            oddGroup.append("text").attr("text-anchor", "middle").text("奇函数 (原点对称)");
    }
    function visualizeEvenFunction(containerId) {
            const setup = setupD3(containerId);
            if (!setup) return;
            const { g, width, height } = setup;
            const xScale = d3.scaleLinear().domain([-5, 5]).range([0, width]);
            const yScale = d3.scaleLinear().domain([-2, 10]).range([height, 0]);
            drawAxes(g, xScale, yScale, width, height);
            const line = d3.line().x(d => xScale(d)).y(d => yScale(d * d));
            const data = d3.range(-4, 4.1, 0.1);
            g.append("path").datum(data).attr("d", line).attr("stroke", "#3498db").attr("stroke-width", 3).attr("fill", "none");
            g.append("line").attr("x1", xScale(0)).attr("y1", 0).attr("x2", xScale(0)).attr("y2", height).attr("stroke", "#e74c3c").attr("stroke-dasharray", "5,5");
    }
    function visualizeOddFunction(containerId) {
            const setup = setupD3(containerId);
            if (!setup) return;
            const { g, width, height } = setup;
            const xScale = d3.scaleLinear().domain([-3, 3]).range([0, width]);
            const yScale = d3.scaleLinear().domain([-10, 10]).range([height, 0]);
            drawAxes(g, xScale, yScale, width, height);
            const line = d3.line().x(d => xScale(d)).y(d => yScale(d * d * d));
            const data = d3.range(-3, 3.1, 0.1);
            g.append("path").datum(data).attr("d", line).attr("stroke", "#e74c3c").attr("stroke-width", 3).attr("fill", "none");
            g.append("circle").attr("cx", xScale(0)).attr("cy", yScale(0)).attr("r", 5).attr("fill", "#f39c12");
    }
    function visualizeBoundedness(containerId) {
            const setup = setupD3(containerId);
            if (!setup) return;
            const { g, width, height } = setup;
            const xScale = d3.scaleLinear().domain([-10, 10]).range([0, width]);
            const yScale = d3.scaleLinear().domain([-2, 2]).range([height, 0]);
            drawAxes(g, xScale, yScale, width, height);
            const line = d3.line().x(d => xScale(d)).y(d => yScale(Math.sin(d)));
            const data = d3.range(-10, 10.1, 0.1);
            g.append("path").datum(data).attr("d", line).attr("stroke", "#3498db").attr("stroke-width", 3).attr("fill", "none");
            g.append("line").attr("x1", 0).attr("y1", yScale(1)).attr("x2", width).attr("y2", yScale(1)).attr("stroke", "#e74c3c").attr("stroke-dasharray", "10, 5");
            g.append("line").attr("x1", 0).attr("y1", yScale(-1)).attr("x2", width).attr("y2", yScale(-1)).attr("stroke", "#e74c3c").attr("stroke-dasharray", "10, 5");
    }
    function visualizeInverseMachine(containerId) {
            const setup = setupD3(containerId);
            if (!setup) return;
            const { g, width, height } = setup;
            const machine1 = g.append("g").attr("transform", `translate(${width * 0.25}, ${height / 2})`);
            machine1.append("rect").attr("x", -80).attr("y", -60).attr("width", 160).attr("height", 120).attr("rx", 15).attr("fill", "#3498db");
            machine1.append("text").attr("text-anchor", "middle").attr("fill", "white").html("<tspan x=0 dy='-0.5em'>f(x)</tspan><tspan x=0 dy='1.2em'>y = 2x + 3</tspan>");
            const machine2 = g.append("g").attr("transform", `translate(${width * 0.75}, ${height / 2})`);
            machine2.append("rect").attr("x", -80).attr("y", -60).attr("width", 160).attr("height", 120).attr("rx", 15).attr("fill", "#e74c3c");
            machine2.append("text").attr("text-anchor", "middle").attr("fill", "white").html("<tspan x=0 dy='-0.5em'>f⁻¹(x)</tspan><tspan x=0 dy='1.2em'>x = (y-3)/2</tspan>");
    }
    function visualizeInverseGraph(containerId) {
            const setup = setupD3(containerId);
            if (!setup) return;
            const { g, width, height } = setup;
            const xScale = d3.scaleLinear().domain([-5, 5]).range([0, width]);
            const yScale = d3.scaleLinear().domain([-5, 5]).range([height, 0]);
            drawAxes(g, xScale, yScale, width, height);
            g.append("line").attr("x1", xScale(-5)).attr("y1", yScale(-5)).attr("x2", xScale(5)).attr("y2", yScale(5)).attr("stroke", "#95a5a6").attr("stroke-dasharray", "5,5");
            const lineF = d3.line().x(d => xScale(d)).y(d => yScale(2 * d));
            const data = d3.range(-2.5, 2.6, 0.1);
            g.append("path").datum(data).attr("d", lineF).attr("stroke", "#3498db").attr("stroke-width", 3).attr("fill", "none");
            const lineInv = d3.line().x(d => xScale(d)).y(d => yScale(d / 2));
            g.append("path").datum(data).attr("d", lineInv).attr("stroke", "#e74c3c").attr("stroke-width", 3).attr("fill", "none");
    }
    function visualizeInteractiveInverseExpLog(containerId) {
            const setup = setupD3(containerId, {top: 60, right: 40, bottom: 60, left: 50});
            if (!setup) return;
            const { container, svg, g, width, height } = setup;
            svg.append('text').attr('x', width / 2 + 50).attr('y', 30).attr('text-anchor', 'middle').style('font-size', '20px').text('指数/对数互为反函数');
            const domainRange = 5;
            const xScale = d3.scaleLinear().domain([-domainRange, domainRange]).range([0, width]);
            const yScale = d3.scaleLinear().domain([-domainRange, domainRange]).range([height, 0]);
            drawAxes(g, xScale, yScale, width, height);
            g.append("line").attr("x1", xScale(-domainRange)).attr("y1", yScale(-domainRange)).attr("x2", xScale(domainRange)).attr("y2", yScale(domainRange)).attr("stroke", "#aaa").attr("stroke-dasharray", "5,5");
            const expPath = g.append("path").attr("fill", "none").attr("stroke", "var(--danger-color)").attr("stroke-width", 2.5);
            const logPath = g.append("path").attr("fill", "none").attr("stroke", "var(--primary-color)").attr("stroke-width", 2.5);
            function update(a) {
                const expLine = d3.line().x(d => xScale(d)).y(d => yScale(Math.pow(a, d)));
                const logLine = d3.line().x(d => xScale(d)).y(d => yScale(Math.log(d) / Math.log(a)));
                const expData = d3.range(-domainRange, domainRange, 0.1).filter(x => Math.pow(a, x) < domainRange);
                const logData = d3.range(0.01, domainRange, 0.1);
                expPath.datum(expData).attr("d", expLine);
                logPath.datum(logData).attr("d", logLine);
            }
            update(2);
    }
    function visualizeCompositeMachine(containerId) {
            const setup = setupD3(containerId);
            if (!setup) return;
            const { g, width, height } = setup;
            const stages = [{ x: width * 0.2, label: "g(x)=x+1" },{ x: width * 0.5, label: "f(u)=u²" },{ x: width * 0.8, label: "y=f(g(x))" }];
            stages.forEach(stage => {
                const stageGroup = g.append("g").attr("transform", `translate(${stage.x}, ${height/2})`);
                stageGroup.append("rect").attr("x", -70).attr("y", -50).attr("width", 140).attr("height", 100).attr("rx", 15).attr("fill", "#bdc3c7");
                stageGroup.append("text").attr("text-anchor", "middle").text(stage.label);
            });
    }

    // === 新的滚动叙事逻辑 ===
    document.addEventListener('DOMContentLoaded', () => {
        const steps = d3.selectAll(".step");
        const visContainer = d3.select("#sticky-vis-container");
        let activeStep = null;

        // The full animation map from the previous successful steps
        const animationMap = {
            'intro': visualizeIntro,
            'toc': visualizeToc,
            'variables': visualizeVariables,
            'intervals': visualizeIntervals,
            'function-machine': visualizeFunctionMachine,
            'domain': visualizeDomain,
            'range': visualizeRange,
            'elementary-intro': visualizeElementaryIntro,
            'power-function': visualizePowerFunction,
            'exponents': visualizeExponents,
            'exponent-rules-1': visualizeExponentRules1,
            'exponent-rules-2': visualizeExponentRules2,
            'special-exponents': visualizeSpecialExponentsNew,
            'fractional-exponents': visualizeFractionalExponents,
            'interactive-exponential': visualizeInteractiveExponential,
            'log-history': visualizeLogHistory,
            'log-definition': visualizeLogDefinition,
            'interactive-logarithm': visualizeInteractiveLogarithm,
            'log-properties': visualizeLogProperties,
            'common-logs': visualizeCommonLogs,
            'log-operations': visualizeLogOperations,
            'interactive-trig': visualizeInteractiveTrig,
            'interactive-inv-trig': visualizeInteractiveInvTrig,
            'properties-intro': visualizePropertiesIntro,
            'monotonicity-inc': visualizeMonotonicityInc,
            'monotonicity-dec': visualizeMonotonicityDec,
            'monotonicity-intervals': visualizeMonotonicityIntervals,
            'parity-intro': visualizeParityIntro,
            'even-function': visualizeEvenFunction,
            'odd-function': visualizeOddFunction,
            'boundedness': visualizeBoundedness,
            'inverse-machine': visualizeInverseMachine,
            'inverse-graph': visualizeInverseGraph,
            'interactive-inverse-exp-log': visualizeInteractiveInverseExpLog,
            'composite-machine': visualizeCompositeMachine
        };

        // Corrected logic for handling step changes
        function handleStepEnter(step) {
            if (activeStep === step) return; 
            activeStep = step;

            steps.classed('is-active', false);
            d3.select(step).classed('is-active', true);

            const animationKey = step.dataset.animation;
            const isFullscreen = step.classList.contains('fullscreen');
            
            const targetContainerId = isFullscreen ? `vis-${animationKey}` : 'sticky-vis-container';

            // No longer need to toggle opacity of visContainer, CSS handles it

            if (animationMap[animationKey]) {
                // For non-fullscreen, clear container before drawing. Fullscreen containers are part of the step, so they get cleared implicitly.
                if (!isFullscreen) {
                    visContainer.html('');
                }
                animationMap[animationKey](targetContainerId);
            }
        }

        const observer = new IntersectionObserver(
            (entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        handleStepEnter(entry.target);
                    }
                });
            },
            {
                rootMargin: '-50% 0px -50% 0px',
                threshold: 0
            }
        );

        steps.each(function() {
            observer.observe(this);
        });
        
        // --- FIX FOR MATHJAX ---
        // Typeset the whole document once on load and let it be.
        if (window.MathJax && window.MathJax.typesetPromise) {
            window.MathJax.typesetPromise();
        }
    });
</script>
</body>
</html>