<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>中值定理虚拟实验室</title>
    <script defer src="../common-assets/js/mathjax-3.2.2-tex-svg.min.js"></script>
    <style>
    :root {
        --primary: #4f46e5;
        --primary-dark: #3730a3;
        --primary-light: #6366f1;
        --success: #10b981;
        --warning: #f59e0b;
        --danger: #ef4444;
        --gray-50: #f9fafb;
        --gray-100: #f3f4f6;
        --gray-200: #e5e7eb;
        --gray-300: #d1d5db;
        --gray-500: #6b7280;
        --gray-600: #4b5563;
        --gray-700: #1f2937;
        --white: #ffffff;
        --light: #ffffff;
        --border: #e5e7eb;
        --h1-size: 22px;
        --h3-size: 18px;
        --text-size: 16px;
        --formula-size: 20px;
    }
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        *::-webkit-scrollbar {
            width: 0;
            background: transparent;
        }
        
        * {
            scrollbar-width: none;
            -ms-overflow-style: none;
        }

            body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "PingFang SC", "Microsoft YaHei", Arial, sans-serif;
        font-size: var(--text-size);
        line-height: 1.5;
        background: var(--gray-50);
        color: var(--gray-700);
    }

            .container {
        width: 100%;
        max-width: 1400px;
        height: min(100vh, 700px);
        margin: 0 auto;
        display: flex;
        flex-direction: column;
        background: var(--white);
    }

            .header {
        height: 40px;
        background: var(--primary);
        color: var(--white);
        display: flex;
        align-items: center;
        padding: 0 20px;
    }

            .header h1 { font-size: var(--h1-size); margin: 0; }

            .main { flex: 1; display: flex; overflow: hidden; }

            .sidebar {
        width: 120px;
        background: var(--gray-50);
        border-right: 1px solid var(--border);
        padding: 10px 8px;
        display: flex;
        flex-direction: column;
        gap: 8px;
    }

            .nav-btn {
        width: 100%;
        padding: 8px;
        background: transparent;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-size: var(--text-size);
        color: var(--gray-600);
        text-align: left;
        transition: background 0.2s ease, color 0.2s ease;
    }

            .nav-btn:hover { background: var(--gray-100); }

            .nav-btn.active { background: var(--primary); color: var(--white); }

            .page-content {
        flex: 1;
        position: relative;
        overflow: hidden;
        display: none;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 18px;
        padding: 16px;
    }

    .page-content.active {
        display: grid;
    }

            .column { display: flex; flex-direction: column; gap: 16px; overflow-y: auto; padding-right: 4px; }

            .card { background: var(--white); border: 1px solid var(--border); border-radius: 12px; padding: 12px; display: flex; flex-direction: column; gap: 10px; }

        .card h3 {
            font-size: 18px;
            color: var(--primary);
            margin-bottom: 12px;
        }

        .info-box {
            background: var(--gray-50);
            padding: 10px;
            border-radius: 4px;
            margin: 8px 0;
            font-size: 16px;
            text-align: center;
        }

        .info-box.success {
            background: #f0fdf4;
            border: 1px solid #10b981;
            color: #15803d;
        }

        .info-box.warning {
            background: #fefce8;
            border: 1px solid #f59e0b;
            color: #854d0e;
        }

        .info-box.danger {
            background: #fef2f2;
            border: 1px solid #ef4444;
            color: #991b1b;
        }

        .formula-box {
            background: #f0f7ff;
            padding: 12px;
            border-radius: 4px;
            border-left: 3px solid var(--primary);
            margin: 12px 0;
            text-align: center;
            font-size: 20px;
        }

        .steps {
            background: #fff9e6;
            padding: 12px;
            border-radius: 4px;
            border-left: 3px solid #f59e0b;
            line-height: 1.8;
            font-size: 16px;
        }

        .input-group {
            margin-bottom: 12px;
        }

        .input-group label {
            display: block;
            margin-bottom: 4px;
            font-size: 16px;
            font-weight: 500;
        }

        .input-group select,
        .input-group input {
            width: 100%;
            padding: 8px;
            border: 1px solid var(--border);
            border-radius: 4px;
            font-size: 16px;
            background: var(--gray-50);
        }

        .slider-group {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: var(--gray-50);
            border-radius: 4px;
            margin-top: 12px;
        }

        .slider-group label {
            min-width: 60px;
            font-size: 16px;
        }

        .slider {
            flex: 1;
            height: 4px;
            -webkit-appearance: none;
            appearance: none;
            background: var(--gray-200);
            outline: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
        }

        .slider-value {
            min-width: 40px;
            text-align: center;
            font-weight: 600;
            color: var(--primary);
        }

        .canvas-container {
            border: 1px solid var(--gray-200);
            border-radius: 4px;
            background: #fafafa;
            padding: 10px;
            min-height: 300px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .canvas-container canvas {
            display: block;
            max-width: 100%;
            max-height: 100%;
        }

        .btn {
            padding: 8px 16px;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.2s;
            margin-right: 8px;
        }

        .btn:hover {
            background: var(--primary-dark);
        }

        .btn-success {
            background: var(--success);
        }

        .btn-success:hover {
            background: #059669;
        }

        .highlight-box {
            background: linear-gradient(to right, #eff6ff, #dbeafe);
            border: 2px solid var(--info);
            border-radius: 8px;
            padding: 16px;
            margin: 12px 0;
            position: relative;
        }

        .highlight-box::before {
            content: '💡';
            position: absolute;
            top: -10px;
            left: 20px;
            background: white;
            padding: 0 8px;
            font-size: 20px;
        }

        @media (max-width: 768px) {
                .main { flex: 1; display: flex; overflow: hidden; }

                .sidebar {
        width: 120px;
        background: var(--gray-50);
        border-right: 1px solid var(--border);
        padding: 10px 8px;
        display: flex;
        flex-direction: column;
        gap: 8px;
    }

                .nav-btn {
        width: 100%;
        padding: 8px;
        background: transparent;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-size: var(--text-size);
        color: var(--gray-600);
        text-align: left;
        transition: background 0.2s ease, color 0.2s ease;
    }

            .content.active {
                grid-template-columns: 1fr;
            }

                .container {
        width: 100%;
        max-width: 1400px;
        height: min(100vh, 700px);
        margin: 0 auto;
        display: flex;
        flex-direction: column;
        background: var(--white);
    }
        }
    </style>

    <style>
        .return-home-panel {
            position: fixed;
            top: 16px;
            left: 16px;
            display: flex;
            gap: 10px;
            z-index: 9999;
            flex-wrap: wrap;
        }
        .return-home-panel .return-link {
            padding: 8px 14px;
            border-radius: 999px;
            background: rgba(15, 23, 42, 0.8);
            color: #f8fafc;
            font-size: 14px;
            text-decoration: none;
            box-shadow: 0 6px 20px rgba(15, 23, 42, 0.25);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .return-home-panel .return-link:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 24px rgba(15, 23, 42, 0.35);
        }
        .return-home-panel .return-link.return-main {
            background: rgba(79, 70, 229, 0.85);
        }
        @media (max-width: 640px) {
            .return-home-panel {
                top: 12px;
                left: 12px;
                right: 12px;
                justify-content: center;
            }
            .return-home-panel .return-link {
                width: 100%;
                text-align: center;
            }
        }
    </style>
</head>
<body>
    <div class="return-home-panel">
        <a class="return-link return-sub" href="index.html">← 返回目录</a>
        <a class="return-link return-main" href="../index.html">⌂ 返回主站</a>
    </div>
    <div class="container">
        <header class="header">
            <h1>中值定理虚拟实验室</h1>
        </header>

        <div class="main">
            <nav class="sidebar">
                <button class="nav-btn active" data-section="intro">概念引入</button>
                <button class="nav-btn" data-section="practice">动手实践</button>
                <button class="nav-btn" data-section="application">实际应用</button>
            </nav>

            <!-- 概念引入页面 -->
            <div class="page-content active" id="intro">
                <div class="column">
                    <div class="card">
                        <h3>🚗 速度的秘密</h3>
                        <div class="steps">
                            想象你开车从A城到B城，全程120公里，用了2小时。
                            <br><br>
                            <strong>平均速度</strong> = 120公里 ÷ 2小时 = <span style="color: #3b82f6;">60公里/小时</span>
                            <br><br>
                            <strong>中值定理告诉我们：</strong>
                            在这2小时的旅程中，<span style="color: #ef4444;">必然有某个时刻</span>，你的速度表指针<span style="color: #ef4444;">恰好指在60公里/小时</span>！
                        </div>
                    </div>

                    <div class="card">
                        <h3>📐 几何意义</h3>
                        <div class="info-box">
                            割线斜率 = 平均变化率 = <span style="color: #3b82f6;">平均速度</span>
                        </div>
                        <div class="info-box">
                            切线斜率 = 瞬时变化率 = <span style="color: #ef4444;">瞬时速度</span>
                        </div>
                        <div class="formula-box">
                            $f'(c) = \frac{f(b) - f(a)}{b - a}$
                        </div>
                        <div style="font-size: 14px; color: #6b7280; text-align: center; margin-top: 8px;">
                            某点c的切线斜率 = 整体的割线斜率
                        </div>
                    </div>
                    <div class="highlight-box">
                        ✅ 我们很容易测量一个过程的开始和结束，算出平均值<br>
                        ❌ 但很难持续监控过程中的每一个瞬间
                    </div>
                </div>

                <div class="column">
                    <div class="card">
                        <h3>📊 图形演示</h3>
                        <div class="canvas-container">
                            <canvas id="introCanvas" width="500" height="300"></canvas>
                        </div>
                        <div class="info-box">
                            <span style="color: #3b82f6;">蓝色虚线</span>是割线（平均速度）<br>
                            <span style="color: #ef4444;">红色切线</span>是某点的切线（瞬时速度）<br>
                            它们<strong>平行</strong>时，斜率就相等了！
                        </div>
                        <button class="btn" onclick="animateIntro()">播放动画</button>
                        <button class="btn btn-success" onclick="resetIntro()">重置</button>
                    </div>
                    <div class="highlight-box">
                        中值定理解决了现实中的测量难题——我们不需要监控每个瞬间，只要知道起点和终点，就能确定某个瞬时值的存在。
                    </div>
                </div>
            </div>

            <!-- 动手实践页面 -->
            <div class="page-content" id="practice">
                <div class="column">
                    <div class="card">
                        <h3>🧪 实验挑战</h3>
                        <div class="highlight-box" style="background: linear-gradient(135deg, #fef3c7, #fde68a); border-color: #f59e0b;">
                            <strong>任务：</strong>直接用鼠标拖动画布中的点！
                            <br>• 拖动<span style="color: #3b82f6;">A、B点</span>改变区间
                            <br>• 拖动<span style="color: #ef4444;">C点</span>找到中值点
                            <br>• 让两个斜率数值相等即可！
                        </div>
                        
                        <div class="input-group">
                            <label>选择实验函数</label>
                            <select id="funcSelect" onchange="changeFunction()">
                                <option value="parabola">平滑抛物线</option>
                                <option value="sine">正弦波浪</option>
                                <option value="cubic">三次曲线</option>
                                <option value="abs">⚠️ 破坏性函数（有尖角）</option>
                            </select>
                        </div>

                        <div class="slope-display" style="display: flex; gap: 10px; margin-top: 15px;">
                            <div style="flex: 1; padding: 15px; border-radius: 8px; text-align: center; background: linear-gradient(135deg, #3b82f6, #2563eb); color: white;">
                                <div style="font-size: 24px; font-weight: bold;" id="secantSlope">0.000</div>
                                <div style="font-size: 12px; margin-top: 5px;">割线斜率<br>(平均速度)</div>
                            </div>
                            <div style="flex: 1; padding: 15px; border-radius: 8px; text-align: center; background: linear-gradient(135deg, #ef4444, #dc2626); color: white;">
                                <div style="font-size: 24px; font-weight: bold;" id="tangentSlope">0.000</div>
                                <div style="font-size: 12px; margin-top: 5px;">切线斜率<br>(瞬时速度)</div>
                            </div>
                        </div>

                        <div class="info-box" id="resultMessage" style="margin-top: 15px;">
                            拖动C点来匹配斜率...
                        </div>

                        <button class="btn" onclick="autoFindC()" style="width: 100%; margin-top: 10px;">
                            🔍 自动寻找中值点
                        </button>
                    </div>

                    <div class="card">
                        <h3>📝 实验数据</h3>
                        <div id="experimentData" class="steps">
                            <div>A点位置：x = <span id="pointAX">0.8</span></div>
                            <div>B点位置：x = <span id="pointBX">4.2</span></div>
                            <div>C点位置：x = <span id="pointCX">2.5</span></div>
                            <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #d1d5db;">
                                斜率差值：<span id="slopeDiff" style="font-weight: bold;">0.000</span>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="column">
                    <div class="card">
                        <h3>📈 交互实验区</h3>
                        <div class="canvas-container" style="min-height: 400px;">
                            <canvas id="practiceCanvas" width="500" height="400"></canvas>
                        </div>
                        <div class="info-box" style="font-size: 14px;">
                            💡 直接拖动图中的点进行实验！<br>
                            当<span style="color: #ef4444;">红色切线</span>与<span style="color: #3b82f6;">蓝色割线</span>平行时即为成功
                        </div>
                    </div>

                    <div class="card">
                        <h3>🎯 实验技巧</h3>
                        <div class="steps">
                            <div><strong>技巧1：</strong>先拖动A、B点确定区间，再调整C点</div>
                            <div><strong>技巧2：</strong>观察斜率差值，当接近0时即为成功</div>
                            <div><strong>技巧3：</strong>使用"自动寻找"功能验证结果</div>
                            <div><strong>技巧4：</strong>尝试不同函数，观察中值点的位置变化</div>
                        </div>
                        <div class="info-box" style="margin-top: 15px;">
                            🔍 <strong>深度思考：</strong>为什么有些函数（如绝对值函数）无法找到中值点？这与中值定理的条件有什么关系？
                        </div>
                    </div>
                </div>
            </div>

            <!-- 实际应用页面 -->
            <div class="page-content" id="application">
                <div class="column">
                    <div class="card">
                        <h3>🚔 区间测速原理</h3>
                        <div class="steps">
                            <strong>场景：</strong>高速公路限速100公里/小时
                            <br><br>
                            某司机的行车记录：
                            <br>• 10:00 进入测速区（0公里处）
                            <br>• 11:00 离开测速区（120公里处）
                            <br><br>
                            <strong>计算：</strong>
                            <br>平均速度 = 120公里 ÷ 1小时 = <span style="color: #ef4444;">120公里/小时</span>
                            <br><br>
                            <strong>结论：</strong>
                            根据中值定理，必然存在某个时刻，该司机的瞬时速度达到120公里/小时，超过了限速！
                        </div>
                        <div class="info-box danger">
                            ⚠️ 罚单已开出：超速20公里/小时
                        </div>
                    </div>

                    <div class="card">
                        <h3>🏭 生产线质检</h3>
                        <div class="steps">
                            某工厂生产线：
                            <br>• 早上8:00 已生产100件
                            <br>• 下午5:00 已生产1000件
                            <br><br>
                            平均产速 = (1000-100)件 ÷ 9小时 = 100件/小时
                            <br><br>
                            <strong>中值定理应用：</strong>
                            必然存在某个时刻，生产线的瞬时产速恰好是100件/小时。
                            这可以用来检查生产线是否有异常波动。
                        </div>
                    </div>
                </div>

                <div class="column">
                    <div class="card">
                        <h3>🚗 模拟区间测速</h3>
                        <div class="canvas-container">
                            <canvas id="speedCanvas" width="500" height="250"></canvas>
                        </div>
                        <div class="slider-group">
                            <label>时间</label>
                            <input type="range" class="slider" id="timeSlider" 
                                   min="0" max="60" step="1" value="0" 
                                   oninput="updateSpeedSimulation()">
                            <span class="slider-value" id="timeValue">0分钟</span>
                        </div>
                        <div class="info-box" id="speedInfo">
                            当前位置：0公里 | 瞬时速度：80公里/小时
                        </div>
                        <button class="btn" onclick="startSpeedSimulation()">开始模拟</button>
                        <button class="btn btn-success" onclick="resetSpeedSimulation()">重置</button>
                    </div>

                    <div class="card">
                        <h3>💰 投资收益分析</h3>
                        <div class="steps">
                            某股票：
                            <br>• 年初价格：100元
                            <br>• 年末价格：150元
                            <br><br>
                            年均涨幅 = 50%
                            <br><br>
                            根据中值定理，这一年中必然有某个时刻，股票的瞬时涨幅率恰好是50%/年。
                        </div>
                        <div class="info-box success">
                            这帮助投资者理解：即使股价波动，也会有"平均表现"的时刻
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 全局变量
        let practiceCanvas, practiceCtx;
        let isDragging = false;
        let dragPoint = null;
        let practiceFunc = 'parabola';
        let points = {
            A: { x: 0.8, y: 0 },
            B: { x: 4.2, y: 0 },
            C: { x: 2.5, y: 0 }
        };
        let speedTime = 0;
        let speedAnimation = null;
        let introAnimationFrame = 0;
        let introAnimation = null;

        const functions = {
            parabola: {
                f: (x) => -0.3 * (x - 2.5) * (x - 2.5) + 3,
                df: (x) => -0.6 * (x - 2.5),
                name: '平滑抛物线',
                smooth: true
            },
            sine: {
                f: (x) => Math.sin(2 * x) + x / 3,
                df: (x) => 2 * Math.cos(2 * x) + 1/3,
                name: '正弦波浪',
                smooth: true
            },
            cubic: {
                f: (x) => Math.pow(x, 3) / 4 - x,
                df: (x) => 3 * x * x / 4 - 1,
                name: '三次曲线',
                smooth: true
            },
            abs: {
                f: (x) => Math.abs(x - 2.5) + 1,
                df: (x) => x > 2.5 ? 1 : (x < 2.5 ? -1 : undefined),
                name: '破坏性函数（有尖角）',
                smooth: false
            }
        };

        // 概念引入页面的图形
        function drawIntro() {
            const canvas = document.getElementById('introCanvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.clearRect(0, 0, width, height);
            
            const padding = 60;
            const graphWidth = width - 2 * padding;
            const graphHeight = height - 2 * padding;
            
            // 绘制网格
            ctx.strokeStyle = '#e5e7eb';
            ctx.lineWidth = 0.5;
            for (let i = 0; i <= 10; i++) {
                const x = padding + (i * graphWidth / 10);
                const y = padding + (i * graphHeight / 10);
                ctx.beginPath();
                ctx.moveTo(x, padding);
                ctx.lineTo(x, height - padding);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(width - padding, y);
                ctx.stroke();
            }
            
            // 绘制坐标轴
            ctx.strokeStyle = '#374151';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, height - padding);
            ctx.stroke();
            
            // 定义函数
            const func = (x) => -0.3 * (x - 2.5) * (x - 2.5) + 3;
            
            const xa = 0.8;
            const xb = 4.2;
            const xc = 2.5;
            
            const ya = func(xa);
            const yb = func(xb);
            const yc = func(xc);
            
            const toCanvasX = (x) => padding + (x / 5) * graphWidth;
            const toCanvasY = (y) => height - padding - (y / 4) * graphHeight;
            
            // 绘制函数曲线
            ctx.strokeStyle = '#4f46e5';
            ctx.lineWidth = 3;
            ctx.beginPath();
            for (let x = 0; x <= 5; x += 0.05) {
                const y = func(x);
                const canvasX = toCanvasX(x);
                const canvasY = toCanvasY(y);
                
                if (x === 0) {
                    ctx.moveTo(canvasX, canvasY);
                } else {
                    ctx.lineTo(canvasX, canvasY);
                }
            }
            ctx.stroke();
            
            // 绘制割线
            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 2.5;
            ctx.setLineDash([8, 4]);
            ctx.beginPath();
            ctx.moveTo(toCanvasX(xa), toCanvasY(ya));
            ctx.lineTo(toCanvasX(xb), toCanvasY(yb));
            ctx.stroke();
            ctx.setLineDash([]);
            
            // 计算割线斜率
            const secantSlope = (yb - ya) / (xb - xa);
            
            // 绘制C点的切线
            const tangentLength = 1.5;
            ctx.strokeStyle = '#ef4444';
            ctx.lineWidth = 2.5;
            ctx.beginPath();
            const x1 = xc - tangentLength;
            const y1 = yc - secantSlope * tangentLength;
            const x2 = xc + tangentLength;
            const y2 = yc + secantSlope * tangentLength;
            ctx.moveTo(toCanvasX(x1), toCanvasY(y1));
            ctx.lineTo(toCanvasX(x2), toCanvasY(y2));
            ctx.stroke();
            
            // 标记点A、B、C
            ctx.fillStyle = '#3b82f6';
            ctx.beginPath();
            ctx.arc(toCanvasX(xa), toCanvasY(ya), 6, 0, 2 * Math.PI);
            ctx.fill();
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.fillStyle = '#3b82f6';
            ctx.beginPath();
            ctx.arc(toCanvasX(xb), toCanvasY(yb), 6, 0, 2 * Math.PI);
            ctx.fill();
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.fillStyle = '#ef4444';
            ctx.beginPath();
            ctx.arc(toCanvasX(xc), toCanvasY(yc), 7, 0, 2 * Math.PI);
            ctx.fill();
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // 添加标签
            ctx.fillStyle = '#1f2937';
            ctx.font = 'bold 16px Arial';
            ctx.fillText('A(起点)', toCanvasX(xa) - 30, toCanvasY(ya) + 25);
            ctx.fillText('B(终点)', toCanvasX(xb) - 20, toCanvasY(yb) + 25);
            ctx.fillText('C(中值点)', toCanvasX(xc) - 35, toCanvasY(yc) - 15);
            
            ctx.font = '14px Arial';
            ctx.fillStyle = '#3b82f6';
            ctx.fillText('割线（平均速度）', toCanvasX(2.5), toCanvasY(1.2));
            
            ctx.fillStyle = '#ef4444';
            ctx.fillText('切线（瞬时速度）', toCanvasX(xc) + 70, toCanvasY(yc) + 20);
            
            ctx.fillStyle = '#10b981';
            ctx.font = 'bold 14px Arial';
            ctx.fillText('✓ 平行！', toCanvasX(3.5), toCanvasY(2.5));
            
            ctx.fillStyle = '#374151';
            ctx.font = '14px Arial';
            ctx.fillText('x（时间）', width - padding + 5, height - padding + 5);
            ctx.fillText('y（路程）', padding - 45, padding - 10);
        }

        function animateIntro() {
            if (introAnimation) return;
            
            const canvas = document.getElementById('introCanvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const padding = 60;
            const graphWidth = width - 2 * padding;
            const graphHeight = height - 2 * padding;
            
            const func = (x) => -0.3 * (x - 2.5) * (x - 2.5) + 3;
            const dfunc = (x) => -0.6 * (x - 2.5);
            const toCanvasX = (x) => padding + (x / 5) * graphWidth;
            const toCanvasY = (y) => height - padding - (y / 4) * graphHeight;
            
            const xa = 0.8;
            const xb = 4.2;
            const ya = func(xa);
            const yb = func(xb);
            const secantSlope = (yb - ya) / (xb - xa);
            
            introAnimation = setInterval(() => {
                introAnimationFrame += 2;
                if (introAnimationFrame > 100) {
                    introAnimationFrame = 0;
                }
                
                ctx.clearRect(0, 0, width, height);
                
                // 重绘网格
                ctx.strokeStyle = '#e5e7eb';
                ctx.lineWidth = 0.5;
                for (let i = 0; i <= 10; i++) {
                    const x = padding + (i * graphWidth / 10);
                    const y = padding + (i * graphHeight / 10);
                    ctx.beginPath();
                    ctx.moveTo(x, padding);
                    ctx.lineTo(x, height - padding);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(padding, y);
                    ctx.lineTo(width - padding, y);
                    ctx.stroke();
                }
                
                // 重绘坐标轴
                ctx.strokeStyle = '#374151';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(padding, height - padding);
                ctx.lineTo(width - padding, height - padding);
                ctx.moveTo(padding, padding);
                ctx.lineTo(padding, height - padding);
                ctx.stroke();
                
                // 重绘函数曲线
                ctx.strokeStyle = '#4f46e5';
                ctx.lineWidth = 3;
                ctx.beginPath();
                for (let x = 0; x <= 5; x += 0.05) {
                    const y = func(x);
                    const canvasX = toCanvasX(x);
                    const canvasY = toCanvasY(y);
                    if (x === 0) {
                        ctx.moveTo(canvasX, canvasY);
                    } else {
                        ctx.lineTo(canvasX, canvasY);
                    }
                }
                ctx.stroke();
                
                // 重绘割线
                ctx.strokeStyle = '#3b82f6';
                ctx.lineWidth = 2.5;
                ctx.setLineDash([8, 4]);
                ctx.beginPath();
                ctx.moveTo(toCanvasX(xa), toCanvasY(ya));
                ctx.lineTo(toCanvasX(xb), toCanvasY(yb));
                ctx.stroke();
                ctx.setLineDash([]);
                
                // 标记A、B点
                ctx.fillStyle = '#3b82f6';
                ctx.beginPath();
                ctx.arc(toCanvasX(xa), toCanvasY(ya), 6, 0, 2 * Math.PI);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(toCanvasX(xb), toCanvasY(yb), 6, 0, 2 * Math.PI);
                ctx.fill();
                
                // 计算当前动画点的位置
                const t = introAnimationFrame / 100;
                const currentX = xa + t * (xb - xa);
                const currentY = func(currentX);
                const currentSlope = dfunc(currentX);
                
                // 绘制当前点的切线
                const tangentLength = 1.2;
                ctx.strokeStyle = '#10b981';
                ctx.lineWidth = 3;
                ctx.beginPath();
                const x1 = currentX - tangentLength;
                const y1 = currentY - currentSlope * tangentLength;
                const x2 = currentX + tangentLength;
                const y2 = currentY + currentSlope * tangentLength;
                ctx.moveTo(toCanvasX(x1), toCanvasY(y1));
                ctx.lineTo(toCanvasX(x2), toCanvasY(y2));
                ctx.stroke();
                
                // 绘制移动的点
                ctx.fillStyle = '#10b981';
                ctx.beginPath();
                ctx.arc(toCanvasX(currentX), toCanvasY(currentY), 7, 0, 2 * Math.PI);
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // 显示斜率信息
                const slopeDiff = Math.abs(currentSlope - secantSlope);
                ctx.fillStyle = '#374151';
                ctx.font = '14px Arial';
                ctx.fillText(`移动点位置：x = ${currentX.toFixed(2)}`, padding, padding - 30);
                ctx.fillText(`切线斜率（瞬时速度）= ${currentSlope.toFixed(3)}`, padding, padding - 10);
                ctx.fillText(`割线斜率（平均速度）= ${secantSlope.toFixed(3)}`, padding + 250, padding - 10);
                
                // 当切线与割线接近平行时高亮显示
                if (slopeDiff < 0.05) {
                    ctx.fillStyle = '#ef4444';
                    ctx.font = 'bold 18px Arial';
                    ctx.fillText('✨ 找到了！切线与割线平行！', width/2 - 100, padding - 30);
                    
                    ctx.strokeStyle = '#ef4444';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(toCanvasX(x1), toCanvasY(y1));
                    ctx.lineTo(toCanvasX(x2), toCanvasY(y2));
                    ctx.stroke();
                }
                
                ctx.fillStyle = '#1f2937';
                ctx.font = 'bold 14px Arial';
                ctx.fillText('A', toCanvasX(xa) - 20, toCanvasY(ya) + 25);
                ctx.fillText('B', toCanvasX(xb) + 10, toCanvasY(yb) + 25);
                
            }, 80);
        }

        function resetIntro() {
            if (introAnimation) {
                clearInterval(introAnimation);
                introAnimation = null;
            }
            introAnimationFrame = 0;
            drawIntro();
        }

        // 动手实践页面函数
        function initPracticeCanvas() {
            practiceCanvas = document.getElementById('practiceCanvas');
            if (!practiceCanvas) return;
            
            practiceCtx = practiceCanvas.getContext('2d');
            
            // 设置画布大小
            practiceCanvas.width = 500;
            practiceCanvas.height = 400;
            
            // 清除之前的事件监听器
            const newCanvas = practiceCanvas.cloneNode(true);
            practiceCanvas.parentNode.replaceChild(newCanvas, practiceCanvas);
            practiceCanvas = newCanvas;
            practiceCtx = practiceCanvas.getContext('2d');
            
            // 鼠标事件
            practiceCanvas.addEventListener('mousedown', handleMouseDown);
            practiceCanvas.addEventListener('mousemove', handleMouseMove);
            practiceCanvas.addEventListener('mouseup', handleMouseUp);
            practiceCanvas.addEventListener('mouseleave', handleMouseUp);
            
            // 触摸事件
            practiceCanvas.addEventListener('touchstart', (e) => {
                const touch = e.touches[0];
                const rect = practiceCanvas.getBoundingClientRect();
                handleMouseDown({
                    clientX: touch.clientX,
                    clientY: touch.clientY,
                    target: practiceCanvas
                });
                e.preventDefault();
            });
            
            practiceCanvas.addEventListener('touchmove', (e) => {
                const touch = e.touches[0];
                handleMouseMove({
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                e.preventDefault();
            });
            
            practiceCanvas.addEventListener('touchend', handleMouseUp);
            
            // 立即更新画布
            updatePractice();
        }

        function toCanvasCoords(x, y) {
            const width = practiceCanvas.width;
            const height = practiceCanvas.height;
            const padding = 50;
            
            const canvasX = padding + (x / 5) * (width - 2 * padding);
            const canvasY = height - padding - (y / 4) * (height - 2 * padding);
            
            return { x: canvasX, y: canvasY };
        }

        function fromCanvasCoords(canvasX, canvasY) {
            const width = practiceCanvas.width;
            const height = practiceCanvas.height;
            const padding = 50;
            
            const x = (canvasX - padding) / (width - 2 * padding) * 5;
            const y = (height - padding - canvasY) / (height - 2 * padding) * 4;
            
            return { x, y };
        }

        function handleMouseDown(e) {
            const rect = practiceCanvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            for (let pointName in points) {
                const point = points[pointName];
                const canvasPoint = toCanvasCoords(point.x, point.y);
                const dist = Math.sqrt(Math.pow(mouseX - canvasPoint.x, 2) + Math.pow(mouseY - canvasPoint.y, 2));
                
                if (dist < 12) {
                    isDragging = true;
                    dragPoint = pointName;
                    practiceCanvas.style.cursor = 'grabbing';
                    break;
                }
            }
        }

        function handleMouseMove(e) {
            const rect = practiceCanvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            if (isDragging && dragPoint) {
                const coords = fromCanvasCoords(mouseX, mouseY);
                let newX = Math.max(0, Math.min(5, coords.x));
                
                if (dragPoint === 'A') {
                    newX = Math.min(newX, points.B.x - 0.5);
                } else if (dragPoint === 'B') {
                    newX = Math.max(newX, points.A.x + 0.5);
                } else if (dragPoint === 'C') {
                    newX = Math.max(points.A.x + 0.1, Math.min(newX, points.B.x - 0.1));
                }
                
                points[dragPoint].x = newX;
                points[dragPoint].y = functions[practiceFunc].f(newX);
                
                updatePractice();
            } else {
                let hoverPoint = false;
                for (let pointName in points) {
                    const point = points[pointName];
                    const canvasPoint = toCanvasCoords(point.x, point.y);
                    const dist = Math.sqrt(Math.pow(mouseX - canvasPoint.x, 2) + Math.pow(mouseY - canvasPoint.y, 2));
                    
                    if (dist < 12) {
                        hoverPoint = true;
                        break;
                    }
                }
                
                practiceCanvas.style.cursor = hoverPoint ? 'grab' : 'crosshair';
            }
        }

        function handleMouseUp() {
            isDragging = false;
            dragPoint = null;
            practiceCanvas.style.cursor = 'crosshair';
        }

        function changeFunction() {
            practiceFunc = document.getElementById('funcSelect').value;
            
            if (practiceFunc === 'abs') {
                points.A.x = 1;
                points.B.x = 4;
                points.C.x = 2.5;
            } else {
                points.A.x = 0.8;
                points.B.x = 4.2;
                points.C.x = 2.5;
            }
            
            updatePractice();
        }

        function updatePractice() {
            if (!practiceCanvas || !practiceCtx) return;
            
            const func = functions[practiceFunc];
            const width = practiceCanvas.width;
            const height = practiceCanvas.height;
            
            practiceCtx.clearRect(0, 0, width, height);
            
            const padding = 50;
            
            // 更新点的y值
            points.A.y = func.f(points.A.x);
            points.B.y = func.f(points.B.x);
            points.C.y = func.f(points.C.x);
            
            // 绘制网格
            practiceCtx.strokeStyle = '#e5e7eb';
            practiceCtx.lineWidth = 0.5;
            for (let i = 0; i <= 10; i++) {
                const x = padding + (i / 10) * (width - 2 * padding);
                const y = padding + (i / 10) * (height - 2 * padding);
                
                practiceCtx.beginPath();
                practiceCtx.moveTo(x, padding);
                practiceCtx.lineTo(x, height - padding);
                practiceCtx.stroke();
                
                practiceCtx.beginPath();
                practiceCtx.moveTo(padding, y);
                practiceCtx.lineTo(width - padding, y);
                practiceCtx.stroke();
            }
            
            // 绘制坐标轴
            practiceCtx.strokeStyle = '#374151';
            practiceCtx.lineWidth = 2;
            practiceCtx.beginPath();
            practiceCtx.moveTo(padding, height - padding);
            practiceCtx.lineTo(width - padding, height - padding);
            practiceCtx.moveTo(padding, padding);
            practiceCtx.lineTo(padding, height - padding);
            practiceCtx.stroke();
            
            // 绘制函数曲线
            practiceCtx.strokeStyle = practiceFunc === 'abs' ? '#f59e0b' : '#4f46e5';
            practiceCtx.lineWidth = 3;
            practiceCtx.beginPath();
            
            for (let x = 0; x <= 5; x += 0.02) {
                const y = func.f(x);
                const canvasPoint = toCanvasCoords(x, y);
                
                if (x === 0) {
                    practiceCtx.moveTo(canvasPoint.x, canvasPoint.y);
                } else {
                    practiceCtx.lineTo(canvasPoint.x, canvasPoint.y);
                }
            }
            practiceCtx.stroke();
            
            // 计算斜率
            const secantSlope = (points.B.y - points.A.y) / (points.B.x - points.A.x);
            const tangentSlope = func.df(points.C.x);
            
            // 绘制割线
            practiceCtx.strokeStyle = '#3b82f6';
            practiceCtx.lineWidth = 2.5;
            practiceCtx.setLineDash([8, 4]);
            const pointA = toCanvasCoords(points.A.x, points.A.y);
            const pointB = toCanvasCoords(points.B.x, points.B.y);
            practiceCtx.beginPath();
            practiceCtx.moveTo(pointA.x, pointA.y);
            practiceCtx.lineTo(pointB.x, pointB.y);
            practiceCtx.stroke();
            practiceCtx.setLineDash([]);
            
            // 绘制切线
            if (tangentSlope !== undefined) {
                practiceCtx.strokeStyle = '#ef4444';
                practiceCtx.lineWidth = 2.5;
                practiceCtx.beginPath();
                
                const tangentLength = 1.2;
                const x1 = points.C.x - tangentLength;
                const y1 = points.C.y - tangentSlope * tangentLength;
                const x2 = points.C.x + tangentLength;
                const y2 = points.C.y + tangentSlope * tangentLength;
                
                const p1 = toCanvasCoords(x1, y1);
                const p2 = toCanvasCoords(x2, y2);
                
                practiceCtx.moveTo(p1.x, p1.y);
                practiceCtx.lineTo(p2.x, p2.y);
                practiceCtx.stroke();
            }
            
            // 绘制点
            const pointC = toCanvasCoords(points.C.x, points.C.y);
            
            // A点
            practiceCtx.fillStyle = '#3b82f6';
            practiceCtx.beginPath();
            practiceCtx.arc(pointA.x, pointA.y, 8, 0, 2 * Math.PI);
            practiceCtx.fill();
            practiceCtx.strokeStyle = 'white';
            practiceCtx.lineWidth = 2;
            practiceCtx.stroke();
            
            // B点
            practiceCtx.fillStyle = '#3b82f6';
            practiceCtx.beginPath();
            practiceCtx.arc(pointB.x, pointB.y, 8, 0, 2 * Math.PI);
            practiceCtx.fill();
            practiceCtx.strokeStyle = 'white';
            practiceCtx.stroke();
            
            // C点
            practiceCtx.fillStyle = '#ef4444';
            practiceCtx.beginPath();
            practiceCtx.arc(pointC.x, pointC.y, 8, 0, 2 * Math.PI);
            practiceCtx.fill();
            practiceCtx.strokeStyle = 'white';
            practiceCtx.stroke();
            
            // 添加点标签
            practiceCtx.fillStyle = '#1f2937';
            practiceCtx.font = 'bold 14px Arial';
            practiceCtx.fillText('A', pointA.x - 20, pointA.y - 10);
            practiceCtx.fillText('B', pointB.x + 10, pointB.y - 10);
            practiceCtx.fillText('C', pointC.x - 5, pointC.y - 15);
            
            // 更新UI
            updatePracticeUI(secantSlope, tangentSlope);
        }

        function updatePracticeUI(secantSlope, tangentSlope) {
            document.getElementById('secantSlope').textContent = secantSlope.toFixed(3);
            document.getElementById('tangentSlope').textContent = 
                tangentSlope !== undefined ? tangentSlope.toFixed(3) : '不可导';
            
            document.getElementById('pointAX').textContent = points.A.x.toFixed(2);
            document.getElementById('pointBX').textContent = points.B.x.toFixed(2);
            document.getElementById('pointCX').textContent = points.C.x.toFixed(2);
            
            const diff = tangentSlope !== undefined ? 
                Math.abs(secantSlope - tangentSlope) : Infinity;
            
            document.getElementById('slopeDiff').textContent = 
                diff !== Infinity ? diff.toFixed(4) : '--';
            
            const msgBox = document.getElementById('resultMessage');
            
            if (tangentSlope === undefined) {
                msgBox.className = 'info-box danger';
                msgBox.innerHTML = '⚠️ 此点不可导！中值定理不适用！';
            } else if (diff < 0.01) {
                msgBox.className = 'info-box success';
                msgBox.innerHTML = '🎉 完美！你找到了中值点！切线与割线平行！';
            } else if (diff < 0.1) {
                msgBox.className = 'info-box warning';
                msgBox.innerHTML = '很接近了！继续调整C点...';
            } else {
                msgBox.className = 'info-box';
                msgBox.innerHTML = '拖动C点来匹配斜率...';
            }
        }

        function autoFindC() {
            const func = functions[practiceFunc];
            
            if (!func.smooth) {
                alert('当前函数存在不可导点，中值定理不适用！\n尝试换个函数试试？');
                return;
            }
            
            const targetSlope = (points.B.y - points.A.y) / (points.B.x - points.A.x);
            let left = points.A.x + 0.01;
            let right = points.B.x - 0.01;
            let animationSteps = [];
            
            for (let i = 0; i < 30; i++) {
                const mid = (left + right) / 2;
                animationSteps.push(mid);
                
                const midSlope = func.df(mid);
                if (Math.abs(midSlope - targetSlope) < 0.001) {
                    break;
                }
                
                if (midSlope < targetSlope) {
                    left = mid;
                } else {
                    right = mid;
                }
            }
            
            let step = 0;
            const animate = () => {
                if (step < animationSteps.length) {
                    points.C.x = animationSteps[step];
                    points.C.y = func.f(points.C.x);
                    updatePractice();
                    step++;
                    setTimeout(animate, 100);
                }
            };
            
            animate();
        }

        // 速度模拟
        function drawSpeedChart() {
            const canvas = document.getElementById('speedCanvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.clearRect(0, 0, width, height);
            
            // 绘制道路
            ctx.fillStyle = '#6b7280';
            ctx.fillRect(50, height / 2 - 20, width - 100, 40);
            
            ctx.fillStyle = '#fbbf24';
            ctx.setLineDash([20, 10]);
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(50, height / 2);
            ctx.lineTo(width - 50, height / 2);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // 绘制里程标记
            ctx.fillStyle = '#374151';
            ctx.font = '12px Arial';
            ctx.fillText('0km', 45, height / 2 + 50);
            ctx.fillText('120km', width - 70, height / 2 + 50);
            
            // 绘制速度曲线
            ctx.strokeStyle = '#ef4444';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let t = 0; t <= 60; t++) {
                const x = 50 + (t / 60) * (width - 100);
                const speed = 80 + 40 * Math.sin(t / 10);
                const y = height / 2 - 60 - speed / 3;
                
                if (t === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            
            // 绘制平均速度线
            ctx.strokeStyle = '#3b82f6';
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(50, height / 2 - 100);
            ctx.lineTo(width - 50, height / 2 - 100);
            ctx.stroke();
            ctx.setLineDash([]);
            
            ctx.fillStyle = '#3b82f6';
            ctx.font = '12px Arial';
            ctx.fillText('平均: 120km/h', width - 140, height / 2 - 105);
        }

        function updateSpeedSimulation() {
            speedTime = parseInt(document.getElementById('timeSlider').value);
            document.getElementById('timeValue').textContent = speedTime + '分钟';
            
            const distance = speedTime * 2;
            const speed = 80 + 40 * Math.sin(speedTime / 10);
            
            document.getElementById('speedInfo').innerHTML = 
                `当前位置：${distance.toFixed(1)}公里 | 瞬时速度：${speed.toFixed(1)}公里/小时`;
            
            const canvas = document.getElementById('speedCanvas');
            if (!canvas) return;
            
            drawSpeedChart();
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // 绘制汽车位置
            const carX = 50 + (speedTime / 60) * (width - 100);
            ctx.fillStyle = '#10b981';
            ctx.beginPath();
            ctx.arc(carX, height / 2, 8, 0, 2 * Math.PI);
            ctx.fill();
            
            // 标记当前速度点
            const speedY = height / 2 - 60 - speed / 3;
            ctx.fillStyle = '#ef4444';
            ctx.beginPath();
            ctx.arc(carX, speedY, 5, 0, 2 * Math.PI);
            ctx.fill();
        }

        function startSpeedSimulation() {
            if (speedAnimation) clearInterval(speedAnimation);
            
            speedAnimation = setInterval(() => {
                speedTime += 1;
                if (speedTime > 60) speedTime = 0;
                
                document.getElementById('timeSlider').value = speedTime;
                updateSpeedSimulation();
            }, 100);
        }

        function resetSpeedSimulation() {
            if (speedAnimation) {
                clearInterval(speedAnimation);
                speedAnimation = null;
            }
            speedTime = 0;
            document.getElementById('timeSlider').value = 0;
            updateSpeedSimulation();
        }

        // 页面切换
        function switchPage(section) {
            const pages = document.querySelectorAll('.page-content');
            const navButtons = document.querySelectorAll('.nav-btn');
            
            pages.forEach(page => {
                page.classList.toggle('active', page.id === section);
            });
            navButtons.forEach(btn => {
                btn.classList.toggle('active', btn.dataset.section === section);
            });

            // 渲染MathJax
            if (window.MathJax && MathJax.typesetPromise) {
                setTimeout(() => {
                    MathJax.typesetPromise();
                }, 100);
            }

            // 初始化对应页面的内容
            setTimeout(() => {
                if (section === 'intro') {
                    drawIntro();
                    resetIntro();
                } else if (section === 'practice') {
                    initPracticeCanvas();
                } else if (section === 'application') {
                    drawSpeedChart();
                    updateSpeedSimulation();
                }
            }, 100);
        }

        // 初始化导航
        function initNavigation() {
            const navButtons = document.querySelectorAll('.nav-btn');
            navButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    const section = btn.dataset.section;
                    switchPage(section);
                });
            });
        }

        // 页面加载完成后初始化
        window.addEventListener('DOMContentLoaded', () => {
            initNavigation();
            switchPage('intro');
        });
    </script>
</body>
</html>